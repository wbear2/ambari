(function(/*! Brunch !*/) {
  'use strict';

  var globals = typeof window !== 'undefined' ? window : global;
  if (typeof globals.require === 'function') return;

  var modules = {};
  var cache = {};

  var has = function(object, name) {
    return ({}).hasOwnProperty.call(object, name);
  };

  var expand = function(root, name) {
    var results = [], parts, part;
    if (/^\.\.?(\/|$)/.test(name)) {
      parts = [root, name].join('/').split('/');
    } else {
      parts = name.split('/');
    }
    for (var i = 0, length = parts.length; i < length; i++) {
      part = parts[i];
      if (part === '..') {
        results.pop();
      } else if (part !== '.' && part !== '') {
        results.push(part);
      }
    }
    return results.join('/');
  };

  var dirname = function(path) {
    return path.split('/').slice(0, -1).join('/');
  };

  var localRequire = function(path) {
    return function(name) {
      var dir = dirname(path);
      var absolute = expand(dir, name);
      return globals.require(absolute, path);
    };
  };

  var initModule = function(name, definition) {
    var module = {id: name, exports: {}};
    cache[name] = module;
    definition(module.exports, localRequire(name), module);
    return module.exports;
  };

  var require = function(name, loaderPath) {
    var path = expand(name, '.');
    if (loaderPath == null) loaderPath = '/';

    if (has(cache, path)) return cache[path].exports;
    if (has(modules, path)) return initModule(path, modules[path]);

    var dirIndex = expand(path, './index');
    if (has(cache, dirIndex)) return cache[dirIndex].exports;
    if (has(modules, dirIndex)) return initModule(dirIndex, modules[dirIndex]);

    throw new Error('Cannot find module "' + name + '" from '+ '"' + loaderPath + '"');
  };

  var define = function(bundle, fn) {
    if (typeof bundle === 'object') {
      for (var key in bundle) {
        if (has(bundle, key)) {
          modules[key] = bundle[key];
        }
      }
    } else {
      modules[bundle] = fn;
    }
  };

  var list = function() {
    var result = [];
    for (var item in modules) {
      if (has(modules, item)) {
        result.push(item);
      }
    }
    return result;
  };

  globals.require = require;
  globals.require.define = define;
  globals.require.register = define;
  globals.require.list = list;
  globals.require.brunch = true;
})();
require.register("test/app_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/quick_view_link_view');
require('models/host_component');
require('models/stack_service_component');
var modelSetup = require('test/init_model_test');

describe('#App', function() {

  describe('App.isHadoop21Stack', function() {
    var tests = [{
      v:'',
      e:false
    }, {
      v:'HDP',
      e: false
    }, {
      v:'HDP1',
      e: false
    }, {
      v:'HDP-1',
      e: false
    }, {
      v:'HDP-2.0',
      e: false
    }, {
      v:'HDP-2.0.1000',
      e: false
    }, {
      v:'HDP-2.1',
      e: true
    }, {
      v:'HDP-2.1.3434',
      e: true
    }, {
      v:'HDP-2.2',
      e: true
    }, {
      v:'HDP-2.2.1212',
      e: true
    }];
    tests.forEach(function(test){
      it(test.v, function() {
        App.QuickViewLinks.prototype.setQuickLinks = function(){};
        App.set('currentStackVersion', test.v);
        var calculated = App.get('isHadoop21Stack');
        var expected = test.e;
        expect(calculated).to.equal(expected);
      });
    });
  });

  describe('Disable/enable components', function() {

    App.set('handleStackDependencyTest', true);
    modelSetup.setupStackVersion(this, 'HDP-2.1');

    var testableComponent =  Em.Object.create({
      componentName: 'APP_TIMELINE_SERVER',
      serviceName: 'YARN'
    });
    var expectedInfo = {
      componentName: 'APP_TIMELINE_SERVER',
      properties: {
        global_properties: ['ats_host', 'apptimelineserver_heapsize'],
        site_properties: ['yarn.timeline-service.generic-application-history.store-class', 'yarn.timeline-service.store-class', 'yarn.timeline-service.leveldb-timeline-store.path']
      },
      reviewConfigs: {
        component_name: 'APP_TIMELINE_SERVER'
      },
      configCategory: {
        name: 'AppTimelineServer'
      }
    };

    var globalProperties = require('data/HDP2/global_properties');
    var siteProperties = require('data/HDP2/site_properties');
    var reviewConfigs = require('data/review_configs');
    var disableResult = App.disableComponent(testableComponent);

    describe('#disableComponent()', function() {
      // copy
      var _globalProperties = $.extend({}, globalProperties);
      var _siteProperties = $.extend({}, siteProperties);
      var _reviewConfigs = JSON.parse(JSON.stringify(reviewConfigs));

      describe('result validation', function() {

        it('component name should be "' + expectedInfo.componentName + '"', function() {
          expect(disableResult.get('componentName')).to.eql(expectedInfo.componentName);
        });

        it('config category name should be "' + expectedInfo.configCategory.name +'"', function() {
          expect(disableResult.get('configCategory.name')).to.eql(expectedInfo.configCategory.name);
        });

        for(var siteName in expectedInfo.properties) {
          (function(site) {
            expectedInfo.properties[site].forEach(function(property) {
              it(property + ' present in ' + site, function() {
                expect(disableResult.get('properties.' + site).mapProperty('name')).to.include(property);
              });
            }, this);
          })(siteName);
        }

        it('site and global properties should not be equal', function() {
          expect(disableResult.get('properties.global_properties')).to.not.include.members(disableResult.get('properties.site_properties'));
        });


      });

      describe('effect validation',function() {


        it('should remove global properties of component', function() {
          expect(_globalProperties.configProperties.mapProperty('name')).to.not.include.members(expectedInfo.properties.global_properties);
        });

        it('should remove site properties of component', function() {
          expect(_siteProperties.configProperties.mapProperty('name')).to.not.include.members(expectedInfo.properties.site_properties);
        });

        it('should remove review config for component', function() {
          var reviewConfig = _reviewConfigs.findProperty('config_name', 'services')
            .config_value.findProperty('service_name', testableComponent.get('serviceName'))
            .service_components.mapProperty('component_name');
          expect(reviewConfig).to.not.include(expectedInfo.reviewConfigs.component_name);
        });
      });
    });

    describe('#enableComponent', function() {
      App.enableComponent(disableResult);

      it('should add global properties of component', function() {
        expect(globalProperties.configProperties.mapProperty('name')).to.include.members(expectedInfo.properties.global_properties);
      });

      it('should add site properties of component', function() {
        expect(siteProperties.configProperties.mapProperty('name')).to.include.members(expectedInfo.properties.site_properties);
      });

      it('should add review config for component', function() {
        var reviewConfig = reviewConfigs.findProperty('config_name', 'services')
          .config_value.findProperty('service_name', testableComponent.get('serviceName'))
          .get('service_components').mapProperty('component_name');
        expect(reviewConfig).to.include(expectedInfo.reviewConfigs.component_name);
      });
    });

    modelSetup.restoreStackVersion(this);
  });

  describe('#stackVersionURL', function () {

    App.QuickViewLinks.reopen({
      loadTags: function () {}
    });

    var testCases = [
      {
        title: 'if currentStackVersion and defaultStackVersion are empty then stackVersionURL should contain prefix',
        currentStackVersion: '',
        defaultStackVersion: '',
        result: '/stacks/HDP/version/'
      },
      {
        title: 'if currentStackVersion is "HDP-1.3.1" then stackVersionURL should be "/stacks/HDP/version/1.3.1"',
        currentStackVersion: 'HDP-1.3.1',
        defaultStackVersion: '',
        result: '/stacks/HDP/version/1.3.1'
      },
      {
        title: 'if defaultStackVersion is "HDP-1.3.1" then stackVersionURL should be "/stacks/HDP/version/1.3.1"',
        currentStackVersion: '',
        defaultStackVersion: 'HDP-1.3.1',
        result: '/stacks/HDP/version/1.3.1'
      },
      {
        title: 'if defaultStackVersion and currentStackVersion are different then stackVersionURL should have currentStackVersion value',
        currentStackVersion: 'HDP-1.3.2',
        defaultStackVersion: 'HDP-1.3.1',
        result: '/stacks/HDP/version/1.3.2'
      },
      {
        title: 'if defaultStackVersion is "HDPLocal-1.3.1" then stackVersionURL should be "/stacks/HDPLocal/version/1.3.1"',
        currentStackVersion: '',
        defaultStackVersion: 'HDPLocal-1.3.1',
        result: '/stacks/HDPLocal/version/1.3.1'
      },
      {
        title: 'if currentStackVersion is "HDPLocal-1.3.1" then stackVersionURL should be "/stacks/HDPLocal/version/1.3.1"',
        currentStackVersion: 'HDPLocal-1.3.1',
        defaultStackVersion: '',
        result: '/stacks/HDPLocal/version/1.3.1'
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        App.set('currentStackVersion', test.currentStackVersion);
        App.set('defaultStackVersion', test.defaultStackVersion);
        expect(App.get('stackVersionURL')).to.equal(test.result);
        App.set('currentStackVersion', "HDP-1.2.2");
        App.set('defaultStackVersion', "HDP-1.2.2");
      });
    });
  });

  describe('#stack2VersionURL', function () {

    var testCases = [
      {
        title: 'if currentStackVersion and defaultStackVersion are empty then stack2VersionURL should contain prefix',
        currentStackVersion: '',
        defaultStackVersion: '',
        result: '/stacks2/HDP/versions/'
      },
      {
        title: 'if currentStackVersion is "HDP-1.3.1" then stack2VersionURL should be "/stacks2/HDP/versions/1.3.1"',
        currentStackVersion: 'HDP-1.3.1',
        defaultStackVersion: '',
        result: '/stacks2/HDP/versions/1.3.1'
      },
      {
        title: 'if defaultStackVersion is "HDP-1.3.1" then stack2VersionURL should be "/stacks/HDP/versions/1.3.1"',
        currentStackVersion: '',
        defaultStackVersion: 'HDP-1.3.1',
        result: '/stacks2/HDP/versions/1.3.1'
      },
      {
        title: 'if defaultStackVersion and currentStackVersion are different then stack2VersionURL should have currentStackVersion value',
        currentStackVersion: 'HDP-1.3.2',
        defaultStackVersion: 'HDP-1.3.1',
        result: '/stacks2/HDP/versions/1.3.2'
      },
      {
        title: 'if defaultStackVersion is "HDPLocal-1.3.1" then stack2VersionURL should be "/stacks2/HDPLocal/versions/1.3.1"',
        currentStackVersion: '',
        defaultStackVersion: 'HDPLocal-1.3.1',
        result: '/stacks2/HDPLocal/versions/1.3.1'
      },
      {
        title: 'if currentStackVersion is "HDPLocal-1.3.1" then stack2VersionURL should be "/stacks2/HDPLocal/versions/1.3.1"',
        currentStackVersion: 'HDPLocal-1.3.1',
        defaultStackVersion: '',
        result: '/stacks2/HDPLocal/versions/1.3.1'
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        App.set('currentStackVersion', test.currentStackVersion);
        App.set('defaultStackVersion', test.defaultStackVersion);
        expect(App.get('stack2VersionURL')).to.equal(test.result);
        App.set('currentStackVersion', "HDP-1.2.2");
        App.set('defaultStackVersion', "HDP-1.2.2");
      });
    });
  });

  describe('#currentStackVersionNumber', function () {

    var testCases = [
      {
        title: 'if currentStackVersion is empty then currentStackVersionNumber should be empty',
        currentStackVersion: '',
        result: ''
      },
      {
        title: 'if currentStackVersion is "HDP-1.3.1" then currentStackVersionNumber should be "1.3.1',
        currentStackVersion: 'HDP-1.3.1',
        result: '1.3.1'
      },
      {
        title: 'if currentStackVersion is "HDPLocal-1.3.1" then currentStackVersionNumber should be "1.3.1',
        currentStackVersion: 'HDPLocal-1.3.1',
        result: '1.3.1'
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        App.set('currentStackVersion', test.currentStackVersion);
        expect(App.get('currentStackVersionNumber')).to.equal(test.result);
        App.set('currentStackVersion', "HDP-1.2.2");
      });
    });
  });

  describe('#isHadoop2Stack', function () {

    var testCases = [
      {
        title: 'if currentStackVersion is empty then isHadoop2Stack should be false',
        currentStackVersion: '',
        result: false
      },
      {
        title: 'if currentStackVersion is "HDP-1.9.9" then isHadoop2Stack should be false',
        currentStackVersion: 'HDP-1.9.9',
        result: false
      },
      {
        title: 'if currentStackVersion is "HDP-2.0.0" then isHadoop2Stack should be true',
        currentStackVersion: 'HDP-2.0.0',
        result: true
      },
      {
        title: 'if currentStackVersion is "HDP-2.0.1" then isHadoop2Stack should be true',
        currentStackVersion: 'HDP-2.0.1',
        result: true
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        App.set('currentStackVersion', test.currentStackVersion);
        expect(App.get('isHadoop2Stack')).to.equal(test.result);
        App.set('currentStackVersion', "HDP-1.2.2");
      });
    });
  });

  describe('#isHaEnabled', function () {

    it('if hadoop stack version less than 2 then isHaEnabled should be false', function () {
      App.set('currentStackVersion', 'HDP-1.3.1');
      expect(App.get('isHaEnabled')).to.equal(false);
      App.set('currentStackVersion', "HDP-1.2.2");
    });
    it('if hadoop stack version higher than 2 then isHaEnabled should be true', function () {
      App.set('currentStackVersion', 'HDP-2.0.1');
      expect(App.get('isHaEnabled')).to.equal(true);
      App.set('currentStackVersion', "HDP-1.2.2");
    });
    it('if cluster has SECONDARY_NAMENODE then isHaEnabled should be false', function () {
      App.store.load(App.HostComponent, {
        id: 'SECONDARY_NAMENODE',
        component_name: 'SECONDARY_NAMENODE'
      });
      App.set('currentStackVersion', 'HDP-2.0.1');
      expect(App.get('isHaEnabled')).to.equal(false);
      App.set('currentStackVersion', "HDP-1.2.2");
    });
  });

  describe('#handleStackDependedComponents()', function () {

    beforeEach(function(){
      modelSetup.setupStackServiceComponent();
    });

    afterEach(function(){
      modelSetup.cleanStackServiceComponent();
    });

    it('if handleStackDependencyTest is true then stackDependedComponents should be unmodified', function () {
      App.set('testMode', false);
      App.set('handleStackDependencyTest', true);
      App.handleStackDependedComponents();
      expect(App.get('stackDependedComponents')).to.be.empty;
    });

    it('if testMode is true then stackDependedComponents should be unmodified', function () {
      App.set('handleStackDependencyTest', false);
      App.set('testMode', true);
      App.handleStackDependedComponents();
      expect(App.get('stackDependedComponents')).to.be.empty;
    });

    it('if stack contains all components then stackDependedComponents should be empty', function () {
      App.set('testMode', false);
      App.set('handleStackDependencyTest', false);
      App.handleStackDependedComponents();
      expect(App.get('stackDependedComponents')).to.be.empty;
    });

    it('if stack is missing component then push it to stackDependedComponents', function () {
      App.set('testMode', false);
      App.set('handleStackDependencyTest', false);
      var dtRecord = App.StackServiceComponent.find('DATANODE');
      dtRecord.deleteRecord();
      dtRecord.get('stateManager').transitionTo('loading');
      App.handleStackDependedComponents();
      expect(App.get('stackDependedComponents').mapProperty('componentName')).to.eql(["DATANODE"]);
      App.store.load(App.StackServiceComponent, {
        id: 'DATANODE',
        component_name: 'DATANODE',
        service_name: 'HDFS',
        component_category: 'SLAVE',
        is_master: false,
        is_client: false,
        stack_name: 'HDP',
        stack_version: '2.1'
      });
    });

    it('remove stack components from stackDependedComponents', function () {
      App.set('testMode', false);
      App.set('handleStackDependencyTest', false);
      App.set('stackDependedComponents', [
        Em.Object.create({
          componentName: "DATANODE",
          serviceName: "HDFS",
          properties: {},
          reviewConfigs: {},
          configCategory: {}
        }),
        Em.Object.create({
          componentName: "categoryComponent",
          serviceName: "",
          properties: {},
          reviewConfigs: {},
          configCategory: {}
        })
      ]);
      App.handleStackDependedComponents();
      expect(App.get('stackDependedComponents').mapProperty('componentName')).to.eql(["categoryComponent"]);
    });
  });
});

});

;require.register("test/controllers/global/background_operations_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('config');
require('utils/updater');
require('utils/ajax/ajax');

require('models/host_component');

require('controllers/global/background_operations_controller');
require('views/common/modal_popup');
require('utils/host_progress_popup');

describe('App.BackgroundOperationsController', function () {

  var controller = App.BackgroundOperationsController.create();

  describe('#getQueryParams', function () {
    /**
     * Predefined data
     *
     */
    App.set('clusterName', 'testName');
    App.bgOperationsUpdateInterval = 100;

    var tests = Em.A([
      {
        levelInfo: Em.Object.create({
          name: 'REQUESTS_LIST',
          requestId: null,
          taskId: null,
          sync: false
        }),
        e: {
          name: 'background_operations.get_most_recent',
          successCallback: 'callBackForMostRecent',
          data: {}
        },
        response: {items: []},
        m: '"Get Most Recent"'
      },
      {
        levelInfo: Em.Object.create({
          name: 'TASK_DETAILS',
          requestId: 1,
          taskId: 1,
          sync: false
        }),
        e: {
          name: 'background_operations.get_by_task',
          successCallback: 'callBackFilteredByTask',
          data: {
            taskId: 1,
            requestId: 1,
            sync: false
          }
        },
        response: {items: {Tasks: {request_id: 0}}},
        m: '"Filtered By task"'
      },
      {
        levelInfo: Em.Object.create({
          name: 'TASKS_LIST',
          requestId: 1,
          taskId: 1,
          sync: false
        }),
        e: {
          name: 'background_operations.get_by_request',
          successCallback: 'callBackFilteredByRequest',
          data: {
            requestId: 1,
            sync: false
          }
        },
        response: {items: {Requests: {id: 0}}},
        m: '"Filtered By Request (TASKS_LIST)"'
      },
      {
        levelInfo: Em.Object.create({
          name: 'HOSTS_LIST',
          requestId: 1,
          taskId: 1,
          sync: false
        }),
        e: {
          name: 'background_operations.get_by_request',
          successCallback: 'callBackFilteredByRequest',
          data: {
            requestId: 1,
            sync: false
          }
        },
        response: {items: {Requests: {id: 0}}},
        m: '"Filtered By Request (HOSTS_LIST)"'
      }
    ]);

    beforeEach(function () {
      App.testMode = false;
    });
    afterEach(function () {
      App.testMode = true;
    });

    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('levelInfo', test.levelInfo);
        var r = controller.getQueryParams();
        expect(r.name).to.equal(test.e.name);
        expect(r.successCallback).to.equal(test.e.successCallback);
        expect(r.data).to.eql(test.e.data);
      });
    });
  });

  describe('#startPolling()', function () {

    beforeEach(function () {
      sinon.spy(App.updater, 'run');
      sinon.spy(controller, 'requestMostRecent');
    });
    afterEach(function () {
      App.updater.run.restore();
      controller.requestMostRecent.restore();
    });

    it('isWorking = false', function () {
      controller.set('isWorking', false);
      expect(App.updater.run.calledOnce).to.equal(false);
      expect(controller.requestMostRecent.calledOnce).to.equal(false);
    });
    it('isWorking = true', function () {
      controller.set('isWorking', true);
      expect(App.updater.run.calledOnce).to.equal(true);
      expect(controller.requestMostRecent.calledOnce).to.equal(true);
    });
  });

  describe('#callBackForMostRecent()', function () {
    it('No requests exists', function () {
      var data = {
        items: []
      };
      controller.callBackForMostRecent(data);
      expect(controller.get("allOperationsCount")).to.equal(0);
      expect(controller.get("services.length")).to.equal(0);
    });
    it('One non-running request', function () {
      var data = {
        items: [
          {
            Requests: {
              id: 1,
              request_context: '',
              task_count: 0,
              aborted_task_count: 0,
              completed_task_count: 0,
              failed_task_count: 0,
              timed_out_task_count: 0,
              queued_task_count: 0
            }
          }
        ]
      };
      controller.callBackForMostRecent(data);
      expect(controller.get("allOperationsCount")).to.equal(0);
      expect(controller.get("services").mapProperty('id')).to.eql([1]);
    });


    it('One running request', function () {
      var data = {
        items: [
          {
            Requests: {
              id: 1,
              request_context: '',
              task_count: 1,
              aborted_task_count: 0,
              completed_task_count: 0,
              failed_task_count: 0,
              timed_out_task_count: 0,
              queued_task_count: 0
            }
          }
        ]
      };
      controller.callBackForMostRecent(data);
      expect(controller.get("allOperationsCount")).to.equal(1);
      expect(controller.get("services").mapProperty('id')).to.eql([1]);
    });
    it('Two requests in order', function () {
      var data = {
        items: [
          {
            Requests: {
              id: 1,
              request_context: ''
            }
          },
          {
            Requests: {
              id: 2,
              request_context: ''
            }
          }
        ]
      };
      controller.callBackForMostRecent(data);
      expect(controller.get("allOperationsCount")).to.equal(0);
      expect(controller.get("services").mapProperty('id')).to.eql([2, 1]);
    });
  });

  describe('#removeOldRequests()', function () {
    var testCases = [
      {
        title: 'No requests exist',
        content: {
          currentRequestIds: [],
          services: []
        },
        result: []
      },
      {
        title: 'One current request',
        content: {
          currentRequestIds: [1],
          services: [
            {id: 1}
          ]
        },
        result: [
          {id: 1}
        ]
      },
      {
        title: 'One old request',
        content: {
          currentRequestIds: [2],
          services: [
            {id: 1}
          ]
        },
        result: []
      },
      {
        title: 'One old request and one is current',
        content: {
          currentRequestIds: [2],
          services: [
            {id: 1},
            {id: 2}
          ]
        },
        result: [
          {id: 2}
        ]
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('services', test.content.services);
        controller.removeOldRequests(test.content.currentRequestIds);
        expect(controller.get('services')).to.eql(test.result);
      });
    });
  });

  describe('#isRequestRunning()', function () {
    var testCases = [
      {
        title: 'Counters are missing',
        request: {
          Requests: {}
        },
        result: false
      },
      {
        title: 'Request has zero tasks',
        request: {
          Requests: {
            task_count: 0,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in running status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: true
      },
      {
        title: 'One task in queued status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 1
          }
        },
        result: true
      },
      {
        title: 'One task in aborted status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 1,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in completed status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 1,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in failed status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 1,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in timed out status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 1,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in timed out status and the second one in running',
        request: {
          Requests: {
            task_count: 2,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 1,
            queued_task_count: 0
          }
        },
        result: true
      },
      {
        title: 'One task in each status',
        request: {
          Requests: {
            task_count: 5,
            aborted_task_count: 1,
            completed_task_count: 1,
            failed_task_count: 1,
            timed_out_task_count: 1,
            queued_task_count: 1
          }
        },
        result: true
      },
      {
        title: 'One task in each status except queued',
        request: {
          Requests: {
            task_count: 5,
            aborted_task_count: 1,
            completed_task_count: 1,
            failed_task_count: 1,
            timed_out_task_count: 1,
            queued_task_count: 0
          }
        },
        result: true
      },
      {
        title: 'No tasks in running status',
        request: {
          Requests: {
            task_count: 4,
            aborted_task_count: 1,
            completed_task_count: 1,
            failed_task_count: 1,
            timed_out_task_count: 1,
            queued_task_count: 0
          }
        },
        result: false
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.isRequestRunning(test.request)).to.eql(test.result);
      });
    });
  });

  describe('#isOneHost()', function () {
    var testCases = [
      {
        title: 'inputs is null',
        inputs: null,
        result: false
      },
      {
        title: 'inputs is "null"',
        inputs: 'null',
        result: false
      },
      {
        title: 'inputs is empty object',
        inputs: '{}',
        result: false
      },
      {
        title: 'included_hosts is empty',
        inputs: '{"included_hosts": ""}',
        result: false
      },
      {
        title: 'included_hosts contain one host',
        inputs: '{"included_hosts": "host1"}',
        result: true
      },
      {
        title: 'included_hosts contain two hosts',
        inputs: '{"included_hosts": "host1,host2"}',
        result: false
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.isOneHost(test.inputs)).to.eql(test.result);
      });
    });
  });

  describe('#assignScheduleId()', function () {
    var testCases = [
      {
        title: 'isOneHost is false',
        content: {
          request: {
            Requests: {
              request_schedule: {
                schedule_id: 1
              },
              inputs: null
            }
          },
          requestParams: ''
        },
        result: 1
      },
      {
        title: 'isOneHost is true and requestContext is empty',
        content: {
          request: {
            Requests: {
              request_schedule: {
                schedule_id: 1
              },
              inputs: '{"included_hosts": "host1"}'
            }
          },
          requestParams: {
            requestContext: ''
          }
        },
        result: 1
      },
      {
        title: 'isOneHost is true and requestContext contains "Recommission"',
        content: {
          request: {
            Requests: {
              request_schedule: {
                schedule_id: 1
              },
              inputs: '{"included_hosts": "host1"}'
            }
          },
          requestParams: {
            requestContext: 'Recommission'
          }
        },
        result: null
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.assignScheduleId(test.content.request, test.content.requestParams);
        expect(test.content.request.Requests.request_schedule.schedule_id).to.equal(test.result);
      });
    });
  });

  describe('#callBackFilteredByRequest()', function () {

    it('request haven\'t tasks and isRunning false', function () {
      var data = {
        Requests: {id: 1},
        tasks: []
      };
      var request = Em.Object.create({
        id: 1,
        previousTaskStatusMap: {},
        isRunning: false,
        progress: 0,
        status:''
      });
      controller.set('services', [request]);
      controller.callBackFilteredByRequest(data);
      expect(request.get('previousTaskStatusMap')).to.eql({});
      expect(request.get('hostsMap')).to.eql({});
      expect(request.get('isRunning')).to.equal(false);
    });

    it('request haven\'t tasks and isRunning true', function () {
      var data = {
        Requests: {id: 1},
        tasks: []
      };
      var request = Em.Object.create({
        id: 1,
        previousTaskStatusMap: {},
        isRunning: true,
        progress: 0,
        status:''
      });
      controller.set('services', [request]);
      controller.callBackFilteredByRequest(data);
      expect(request.get('previousTaskStatusMap')).to.eql({});
      expect(request.get('hostsMap')).to.eql({});
      expect(request.get('isRunning')).to.equal(true);
    });

    it('request has one completed task', function () {
      var data = {
        Requests: {id: 1},
        tasks: [
          {
            Tasks: {
              id: 1,
              host_name: 'host1',
              status: 'COMPLETED'
            }
          }
        ]
      };
      var request = Em.Object.create({
        id: 1,
        previousTaskStatusMap: {},
        isRunning: true,
        progress: 100,
        status:''
      });
      controller.set('services', [request]);
      controller.callBackFilteredByRequest(data);
      expect(request.get('previousTaskStatusMap')).to.eql({"1": "COMPLETED"});
      expect(request.get('hostsMap')['host1'].logTasks.length).to.equal(1);
      expect(request.get('isRunning')).to.equal(false);
    });

    it('request has one completed task and one running task', function () {
      var data = {
        Requests: {id: 1},
        tasks: [
          {
            Tasks: {
              id: 1,
              host_name: 'host1',
              status: 'COMPLETED'
            }
          },
          {
            Tasks: {
              id: 2,
              host_name: 'host1',
              status: 'IN_PROGRESS'
            }
          }
        ]
      };
      var request = Em.Object.create({
        id: 1,
        previousTaskStatusMap: {},
        isRunning: true,
        progress: 100,
        status:''
      });
      controller.set('services', [request]);
      controller.callBackFilteredByRequest(data);
      expect(request.get('previousTaskStatusMap')).to.eql({"1": "COMPLETED", "2": "IN_PROGRESS"});
      expect(request.get('hostsMap')['host1'].logTasks.length).to.equal(2);
      expect(request.get('isRunning')).to.equal(true);
    });
  });
});

});

;require.register("test/controllers/global/cluster_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/global/cluster_controller');
require('models/host_component');
require('utils/http_client');
require('models/service');
require('models/host');
require('utils/ajax/ajax');

var modelSetup = require('test/init_model_test');

describe('App.clusterController', function () {
  var controller = App.ClusterController.create();
  App.Service.FIXTURES = [
    {service_name: 'NAGIOS'}
  ];

  describe('#updateLoadStatus()', function () {

    controller.set('dataLoadList', Em.Object.create({
      'item1': false,
      'item2': false
    }));

    it('when none item is loaded then width should be "width:0"', function () {
      expect(controller.get('clusterDataLoadedPercent')).to.equal('width:0');
    });
    it('when first item is loaded then isLoaded should be false', function () {
      controller.updateLoadStatus.call(controller, 'item1');
      expect(controller.get('isLoaded')).to.equal(false);
    });
    it('when first item is loaded then width should be "width:50%"', function () {
      controller.updateLoadStatus.call(controller, 'item1');
      expect(controller.get('clusterDataLoadedPercent')).to.equal('width:50%');
    });

    it('when all items are loaded then isLoaded should be true', function () {
      controller.updateLoadStatus.call(controller, 'item2');
      expect(controller.get('isLoaded')).to.equal(true);
    });
    it('when all items are loaded then width should be "width:100%"', function () {
      controller.updateLoadStatus.call(controller, 'item2');
      expect(controller.get('clusterDataLoadedPercent')).to.equal('width:100%');
    });
  });

  describe('#loadClusterName()', function () {

    beforeEach(function () {
      modelSetup.setupStackVersion(this, 'HDP-2.0.5');
      sinon.spy(App.ajax, 'send');
    });
    afterEach(function () {
      modelSetup.restoreStackVersion(this);
      App.ajax.send.restore();
    });

    it('if clusterName is "mycluster" and reload is false then loadClusterName should return false', function () {
      controller.set('cluster', {Clusters: {cluster_name: 'mycluster'}});
      expect(controller.loadClusterName(false)).to.equal(false);
    });

    it('reload is true and clusterName is not empty', function () {
      controller.loadClusterName(true);
      expect(App.ajax.send.calledOnce).to.equal(true);
      expect(App.get('currentStackVersion')).to.equal('HDP-2.0.5');
    });

    it('reload is false and clusterName is empty', function () {
      controller.set('cluster', {Clusters: {cluster_name: ''}});
      controller.loadClusterName(false);
      expect(App.ajax.send.calledOnce).to.equal(true);
      expect(App.get('currentStackVersion')).to.equal('HDP-2.0.5');
    });


  });

  describe('#loadClusterNameSuccessCallback', function () {
    var test_data = {
      "items": [
        {
          "Clusters": {
            "cluster_name": "tdk",
            "version": "HDP-1.3.0"
          }
        }
      ]
    };
    it('Check cluster', function () {
      controller.loadClusterNameSuccessCallback(test_data);
      expect(controller.get('cluster.Clusters.cluster_name')).to.equal('tdk');
      expect(controller.get('cluster.Clusters.version')).to.equal('HDP-1.3.0');
      expect(App.get('clusterName')).to.equal('tdk');
    });
  });

  describe('#loadClusterNameErrorCallback', function () {
    controller.loadClusterNameErrorCallback();
    it('', function () {
      expect(controller.get('isLoaded')).to.equal(true);
    });
  });

  describe('#getServerClockSuccessCallback()', function () {
    var testCases = [
      {
        title: 'if server clock is 1 then currentServerTime should be 1000',
        data: {
          RootServiceComponents: {
            server_clock: 1
          }
        },
        result: 1000
      },
      {
        title: 'if server clock is 0 then currentServerTime should be 0',
        data: {
          RootServiceComponents: {
            server_clock: 0
          }
        },
        result: 0
      },
      {
        title: 'if server clock is 111111111111 then currentServerTime should be 111111111111000',
        data: {
          RootServiceComponents: {
            server_clock: 111111111111
          }
        },
        result: 111111111111000
      },
      {
        title: 'if server clock is 1111111111113 then currentServerTime should be 1111111111113',
        data: {
          RootServiceComponents: {
            server_clock: 1111111111113
          }
        },
        result: 1111111111113
      }
    ];
    var currentServerTime = App.get('currentServerTime');
    var clockDistance = App.get('clockDistance');

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.getServerClockSuccessCallback(test.data);
        expect(App.get('currentServerTime')).to.equal(test.result);
        App.set('clockDistance', clockDistance);
        App.set('currentServerTime', currentServerTime);
      });
    });
  });

  describe('#getUrl', function () {
    controller.set('clusterName', 'tdk');
    var tests = ['test1', 'test2', 'test3'];
    it('testMode = true', function () {
      App.testMode = true;
      tests.forEach(function (test) {
        expect(controller.getUrl(test, test)).to.equal(test);
      });
    });
    it('testMode = false', function () {
      App.testMode = false;
      tests.forEach(function (test) {
        expect(controller.getUrl(test, test)).to.equal(App.apiPrefix + '/clusters/' + controller.get('clusterName') + test);
      });
    });
  });

  describe('#gangliaUrl', function () {
    it('testMode = true', function () {
      App.testMode = true;
      expect(controller.get('gangliaUrl')).to.equal('http://gangliaserver/ganglia/?t=yes');
    });
    it('Ganglia service is absent', function () {
      App.testMode = false;
      controller.set('gangliaWebProtocol', '');
      expect(controller.get('gangliaUrl')).to.equal(null);
    });
    it('Ganglia doesn\'t  have any components', function () {
      App.store.load(App.Service, {
        id: 'GANGLIA',
        service_name: 'GANGLIA'
      });
      controller.set('gangliaWebProtocol', '');
      expect(controller.get('gangliaUrl')).to.equal(null);
      expect(controller.get('isGangliaInstalled')).to.equal(true);
    });
    it('Ganglia Server doesn\'t  have host', function () {
      App.store.load(App.HostComponent, {
        id: 'GANGLIA_SERVER_GANGLIA_host',
        component_name: 'GANGLIA_SERVER',
        service_id: 'GANGLIA',
        host_id: 'GANGLIA_host'
      });
      App.store.load(App.Service, {
        id: 'GANGLIA',
        service_name: 'GANGLIA',
        host_components: ['GANGLIA_SERVER_GANGLIA_host']
      });
      controller.set('gangliaWebProtocol', '');
      expect(controller.get('gangliaUrl')).to.equal(null);
    });
    it('Ganglia Server host is "GANGLIA_host"', function () {
      App.store.load(App.Host, {
        id: 'GANGLIA_host',
        host_name: 'GANGLIA_host',
        host_components: ['GANGLIA_SERVER_GANGLIA_host'],
        public_host_name: 'GANGLIA_host'
      });
      controller.set('gangliaWebProtocol', '');
      expect(controller.get('gangliaUrl')).to.equal("http://GANGLIA_host/ganglia");
    });
    it('singleNodeInstall = true', function () {
      App.set('singleNodeInstall', true);
      controller.set('gangliaWebProtocol', '');
      expect(controller.get('gangliaUrl')).to.equal("http://" + location.hostname + ":42080/ganglia");
    });
    it('singleNodeAlias is "alias"', function () {
      App.set('singleNodeAlias', 'alias');
      controller.set('gangliaWebProtocol', '');
      expect(controller.get('gangliaUrl')).to.equal("http://alias:42080/ganglia");
      App.set('singleNodeInstall', false);
      App.set('singleNodeAlias', '');
    });
  });

  describe('#nagiosUrl', function () {
    it('testMode = true', function () {
      App.testMode = true;
      controller.set('nagiosWebProtocol', '');
      expect(controller.get('nagiosUrl')).to.equal('http://nagiosserver/nagios');
    });
    it('Nagios service is absent', function () {
      App.testMode = false;
      controller.set('nagiosWebProtocol', '');
      expect(controller.get('nagiosUrl')).to.equal(null);
    });
    it('Nagios doesn\'t  have any components', function () {
      App.store.load(App.Service, {
        id: 'NAGIOS',
        service_name: 'NAGIOS'
      });
      controller.set('nagiosWebProtocol', '');
      expect(controller.get('nagiosUrl')).to.equal(null);
      expect(controller.get('isNagiosInstalled')).to.equal(true);
    });
    it('NAGIOS Server doesn\'t  have host', function () {
      App.store.load(App.HostComponent, {
        id: 'NAGIOS_SERVER_NAGIOS_host',
        component_name: 'NAGIOS_SERVER',
        service_id: 'NAGIOS',
        host_id: 'NAGIOS_host'
      });
      App.store.load(App.Service, {
        id: 'NAGIOS',
        service_name: 'NAGIOS',
        host_components: ['NAGIOS_SERVER_NAGIOS_host']
      });
      controller.set('nagiosWebProtocol', '');
      expect(controller.get('nagiosUrl')).to.equal(null);
    });
    it('NAGIOS Server host is "NAGIOS_host"', function () {
      App.store.load(App.Host, {
        id: 'NAGIOS_host',
        host_name: 'NAGIOS_host',
        host_components: ['NAGIOS_SERVER_NAGIOS_host'],
        public_host_name: 'NAGIOS_host'
      });
      controller.set('nagiosWebProtocol', '');
      expect(controller.get('nagiosUrl')).to.equal("http://NAGIOS_host/nagios");
    });
    it('singleNodeInstall = true', function () {
      App.set('singleNodeInstall', true);
      controller.set('nagiosWebProtocol', '');
      expect(controller.get('nagiosUrl')).to.equal("http://:42080/nagios");
    });
    it('singleNodeAlias is "alias"', function () {
      App.set('singleNodeAlias', 'alias');
      controller.set('nagiosWebProtocol', '');
      expect(controller.get('nagiosUrl')).to.equal("http://alias:42080/nagios");
    });
  });

  describe('#nagiosWebProtocol', function () {
    var testCases = [
      {
        title: 'if ambariProperties is null then nagiosWebProtocol should be "http"',
        data: null,
        result: 'http'
      },
      {
        title: 'if ambariProperties is empty object then nagiosWebProtocol should be "http"',
        data: {},
        result: 'http'
      },
      {
        title: 'if nagios.https is false then nagiosWebProtocol should be "http"',
        data: {'nagios.https': false},
        result: 'http'
      },
      {
        title: 'if nagios.https is true then nagiosWebProtocol should be "http"',
        data: {'nagios.https': true},
        result: 'https'
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('ambariProperties', test.data);
        expect(controller.get('nagiosWebProtocol')).to.equal(test.result);
      });
    });
  });

  describe('#gangliaWebProtocol', function () {
    var testCases = [
      {
        title: 'if ambariProperties is null then nagiosWebProtocol should be "http"',
        data: null,
        result: 'http'
      },
      {
        title: 'if ambariProperties is empty object then nagiosWebProtocol should be "http"',
        data: {},
        result: 'http'
      },
      {
        title: 'if nagios.https is false then nagiosWebProtocol should be "http"',
        data: {'ganglia.https': false},
        result: 'http'
      },
      {
        title: 'if nagios.https is true then nagiosWebProtocol should be "http"',
        data: {'ganglia.https': true},
        result: 'https'
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('ambariProperties', test.data);
        expect(controller.get('gangliaWebProtocol')).to.equal(test.result);
      });
    });
  });

  describe('#startPolling()', function () {

    beforeEach(function () {
      sinon.spy(App.updater, 'run');
    });
    afterEach(function () {
      App.updater.run.restore();
    });
    it('isWorking = false', function () {
      controller.set('isWorking', false);
      expect(App.updater.run.calledOnce).to.equal(false);
      expect(controller.startPolling()).to.equal(false);
    });

    it('isWorking = true', function () {
      controller.set('isWorking', true);
      expect(App.updater.run.calledOnce).to.equal(true);
      expect(controller.startPolling()).to.equal(true);
    });
  });

  describe('#clusterName', function () {
    var testCases = [
      {
        title: 'if cluster is null then clusterName should be null',
        data: null,
        result: null
      },
      {
        title: 'if cluster.Clusters.cluster_name is null then clusterName should be null',
        data: {
          Clusters: {
            cluster_name: null
          }
        },
        result: null
      },
      {
        title: 'if cluster.Clusters.cluster_name is null then clusterName should be null',
        data: {
          Clusters: {
            cluster_name: 'mycluster'
          }
        },
        result: 'mycluster'
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('cluster', test.data);
        expect(controller.get('clusterName')).to.equal(test.result);
      });
    });
  });

});

});

;require.register("test/controllers/global/configuration_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/global/configuration_controller');


describe('App.ConfigurationController', function () {
  var controller = App.ConfigurationController.create();

  describe('#checkTagsChanges()', function () {
    var testCases = [
      {
        title: 'Tags haven\'t been uploaded',
        content: {
          tags: [],
          storedTags: []
        },
        result: false
      },
      {
        title: 'New tag uploaded',
        content: {
          tags: [
            {
              siteName: 'site1',
              tagName: 1
            }
          ],
          storedTags: []
        },
        result: true
      },
      {
        title: 'Existing tag with with new tagName',
        content: {
          tags: [
            {
              siteName: 'site1',
              tagName: 1
            }
          ],
          storedTags: [
            {
              siteName: 'site1',
              tagName: 2
            }
          ]
        },
        result: true
      },
      {
        title: 'Tags with different tagNames',
        content: {
          tags: [
            {
              siteName: 'site1',
              tagName: 1
            }
          ],
          storedTags: [
            {
              siteName: 'site2',
              tagName: 1
            }
          ]
        },
        result: true
      },
      {
        title: 'One new tag uploaded',
        content: {
          tags: [
            {
              siteName: 'site2',
              tagName: 1
            },
            {
              siteName: 'site1',
              tagName: 1
            }
          ],
          storedTags: [
            {
              siteName: 'site2',
              tagName: 1
            }
          ]
        },
        result: true
      },
      {
        title: 'Tags haven\'t been changed',
        content: {
          tags: [
            {
              siteName: 'site2',
              tagName: 1
            }
          ],
          storedTags: [
            {
              siteName: 'site2',
              tagName: 1
            }
          ]
        },
        result: false
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.checkTagsChanges(test.content.tags, test.content.storedTags)).to.equal(test.result);
      });
    });
  });
});
});

;require.register("test/controllers/global/update_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/global/update_controller');


describe('App.UpdateController', function () {
  var controller = App.UpdateController.create({
    clusterName: '',
    location: '',
    updateServiceMetric: function(){}
  });

  describe('#getUrl()', function () {

    it('testMode = true', function () {
      App.set('testMode', true);
      expect(controller.getUrl('test', '/real')).to.equal('test');
    });

    it('testMode = false', function () {
      App.set('testMode', false);
      expect(controller.getUrl('test', '/real')).to.equal('/api/v1/clusters//real');
    });

    it('testMode = false', function () {
      App.set('testMode', false);
      controller.set('clusterName', 'mycluster');
      expect(controller.getUrl('test', '/real')).to.equal('/api/v1/clusters/mycluster/real');
    });
  });

  describe('#updateAll()', function () {

    beforeEach(function () {
      sinon.stub(App.updater, 'run', Em.K);
    });
    afterEach(function () {
      App.updater.run.restore();
    });
    it('isWorking = false', function () {
      controller.set('isWorking', false);
      expect(App.updater.run.called).to.equal(false);
    });

    it('isWorking = true, App.supports.hostOverrides = false', function () {
      App.supports.hostOverrides = false;
      controller.set('isWorking', true);
      expect(App.updater.run.callCount).to.equal(5);
      controller.set('isWorking', false);
    });

    it('isWorking = true, App.supports.hostOverrides = true', function () {
      App.supports.hostOverrides = true;
      controller.set('isWorking', true);
      expect(App.updater.run.callCount).to.equal(6);
    });
  });

  describe('#updateHostConditionally()', function () {
    var context = {
      callback: function(){}
    };

    beforeEach(function () {
      sinon.stub(controller, 'updateHost', Em.K);
      sinon.spy(context, 'callback');
    });
    afterEach(function () {
      controller.updateHost.restore();
      context.callback.restore();
    });

    it('location is empty', function () {
      controller.set('location', '');
      controller.updateHostConditionally(context.callback);
      expect(controller.updateHost.called).to.equal(false);
      expect(context.callback.called).to.equal(true);
    });
    it('location is "/main/dashboard"', function () {
      controller.set('location', '/main/dashboard');
      controller.updateHostConditionally(context.callback);
      expect(controller.updateHost.called).to.equal(false);
      expect(context.callback.called).to.equal(true);
    });
    it('location is "/main/hosts"', function () {
      controller.set('location', '/main/hosts');
      controller.updateHostConditionally(context.callback);
      expect(controller.updateHost.called).to.equal(true);
      expect(context.callback.called).to.equal(false);
    });
    it('location is "/main/charts/heatmap"', function () {
      controller.set('location', '/main/charts/heatmap');
      controller.updateHostConditionally(context.callback);
      expect(controller.updateHost.called).to.equal(true);
      expect(context.callback.called).to.equal(false);
    });
    it('location is "/main/hosts/host1"', function () {
      controller.set('location', '/main/hosts/host1');
      controller.updateHostConditionally(context.callback);
      expect(controller.updateHost.called).to.equal(true);
      expect(context.callback.called).to.equal(false);
    });
  });

  describe('#updateServiceMetricConditionally()', function () {
    var context = {
      callback: function(){}
    };

    beforeEach(function () {
      sinon.spy(controller, 'updateServiceMetric');
      sinon.spy(context, 'callback');
    });
    afterEach(function () {
      controller.updateServiceMetric.restore();
      context.callback.restore();
    });

    it('location is empty', function () {
      controller.set('location', '');
      controller.updateServiceMetricConditionally(context.callback);
      expect(controller.updateServiceMetric.called).to.equal(false);
      expect(context.callback.called).to.equal(true);
    });
    it('location is "/main/hosts"', function () {
      controller.set('location', '/main/hosts');
      controller.updateServiceMetricConditionally(context.callback);
      expect(controller.updateServiceMetric.called).to.equal(false);
      expect(context.callback.called).to.equal(true);
    });
    it('location is "/main/dashboard"', function () {
      controller.set('location', '/main/dashboard');
      controller.updateServiceMetricConditionally(context.callback);
      expect(controller.updateServiceMetric.called).to.equal(true);
      expect(context.callback.called).to.equal(false);
    });
    it('location is "/main/services/HDFS"', function () {
      controller.set('location', '/main/services/HDFS');
      controller.updateServiceMetricConditionally(context.callback);
      expect(controller.updateServiceMetric.called).to.equal(true);
      expect(context.callback.called).to.equal(false);
    });
  });


  describe('#getConditionalFields()', function () {

    var testCases = [
      {
        title: 'No services exist',
        services: [],
        result: []
      },
      {
        title: 'HDFS service',
        services: [
          {
            ServiceInfo: {
              service_name: 'HDFS'
            }
          }
        ],
        result: []
      },
      {
        title: 'FLUME service',
        services: [
          {
            ServiceInfo: {
              service_name: 'FLUME'
            }
          }
        ],
        result: ["host_components/metrics/flume/flume,"+
          "host_components/processes/HostComponentProcess"]
      },
      {
        title: 'YARN service',
        services: [
          {
            ServiceInfo: {
              service_name: 'YARN'
            }
          }
        ],
        result: ["host_components/metrics/yarn/Queue," +
          "ServiceComponentInfo/rm_metrics/cluster/activeNMcount," +
          "ServiceComponentInfo/rm_metrics/cluster/unhealthyNMcount," +
          "ServiceComponentInfo/rm_metrics/cluster/rebootedNMcount," +
          "ServiceComponentInfo/rm_metrics/cluster/decommissionedNMcount"]
      },
      {
        title: 'HBASE service',
        services: [
          {
            ServiceInfo: {
              service_name: 'HBASE'
            }
          }
        ],
        result: ["host_components/metrics/hbase/master/IsActiveMaster," +
          "ServiceComponentInfo/MasterStartTime," +
          "ServiceComponentInfo/MasterActiveTime," +
          "ServiceComponentInfo/AverageLoad," +
          "ServiceComponentInfo/Revision," +
          "ServiceComponentInfo/RegionsInTransition"]
      },
      {
        title: 'MAPREDUCE service',
        services: [
          {
            ServiceInfo: {
              service_name: 'MAPREDUCE'
            }
          }
        ],
        result: ["ServiceComponentInfo/AliveNodes," +
          "ServiceComponentInfo/GrayListedNodes," +
          "ServiceComponentInfo/BlackListedNodes," +
          "ServiceComponentInfo/jobtracker/*,"]
      },
      {
        title: 'STORM service',
        services: [
          {
            ServiceInfo: {
              service_name: 'STORM'
            }
          }
        ],
        result: ["metrics/api/cluster/summary,"]
      }
    ];

    testCases.forEach(function(test){
      it(test.title, function () {
        App.cache['services'] = test.services;
        expect(controller.getConditionalFields()).to.eql(test.result);
      });
    });
  });
});
});

;require.register("test/controllers/installer_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('models/cluster');
require('controllers/wizard');
require('controllers/installer');

describe('App.InstallerController', function () {

  var installerController = App.InstallerController.create();

  describe('#loadStacksVersionsSuccessCallback', function() {
    var test_data = {
      "items" : [
        {
          "Versions" : {
            "active" : false,
            "min_upgrade_version" : null,
            "stack_name" : "HDP",
            "stack_version" : "1.2.0"
          }
        },
        {
          "Versions" : {
            "active" : true,
            "min_upgrade_version" : null,
            "stack_name" : "HDP",
            "stack_version" : "1.2.1"
          }
        },
        {
          "Versions" : {
            "active" : true,
            "min_upgrade_version" : "1.2.0",
            "stack_name" : "HDP",
            "stack_version" : "1.3.0"
          }
        },
        {
          "Versions" : {
            "active" : false,
            "min_upgrade_version" : null,
            "stack_name" : "HDP",
            "stack_version" : "2.0.1"
          }
        }
      ]
    };
    it ('Correct data', function() {
      installerController.loadStacksVersionsSuccessCallback(test_data);
      expect(installerController.get('stacks.length')).to.equal(2);
      expect(installerController.get('stacks').everyProperty('isSelected')).to.equal(false);
      expect(installerController.get('stacks').mapProperty('name')).to.eql(['HDP-1.3.0', 'HDP-1.2.1']);
    });
  });



});

});

;require.register("test/controllers/main/admin/cluster_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/cluster');


describe('App.MainAdminClusterController', function () {

  var data = {
    "items": [
      {
        "Versions": {
          "stack_version": "1.3.1",
          "min_upgrade_version": "1.2.0"
        }
      },
      {
        "Versions": {
          "stack_version": "1.3.0",
          "min_upgrade_version": "1.2.0"
        }
      },
      {
        "Versions": {
          "stack_version": "1.2.2",
          "min_upgrade_version": "1.2.0"
        }
      },
      {
        "Versions": {
          "stack_version": "1.2.0",
          "min_upgrade_version": "1.2.0"
        }
      }
    ]
  };

  describe('#updateUpgradeVersionSuccessCallback()', function () {
    it('upgrade version of stack should be "HDP-1.3.1"', function () {
      App.set('currentStackVersion', 'HDP-1.2.2');
      var controller = App.MainAdminClusterController.create({
        parseServicesInfo: function () {}
      });
      controller.updateUpgradeVersionSuccessCallback.call(controller, data);
      expect(controller.get('upgradeVersion')).to.equal('HDP-1.3.1');
    });
    it('if min upgrade version less then current then upgrade version equal current', function () {
      App.set('currentStackVersion', 'HDP-1.2.2');
      data.items[0].Versions.min_upgrade_version = "1.2.3";
      var controller = App.MainAdminClusterController.create({
        parseServicesInfo: function () {}
      });
      controller.updateUpgradeVersionSuccessCallback.call(controller, data);
      expect(controller.get('upgradeVersion')).to.equal('HDP-1.2.2');
    })
  })
});

});

;require.register("test/controllers/main/admin/highAvailability_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/highAvailability_controller');
require('models/host_component');
require('models/host');
require('utils/ajax/ajax');

describe('App.MainAdminHighAvailabilityController', function () {

  var controller = App.MainAdminHighAvailabilityController.create();

  describe('#enableHighAvailability()', function () {

    beforeEach(function () {
      sinon.spy(controller, "showErrorPopup");
    });
    afterEach(function () {
      controller.showErrorPopup.restore();
    });

    it('Security enabled', function () {
      controller.set('securityEnabled', true);
      expect(controller.enableHighAvailability()).to.be.false;
      expect(controller.showErrorPopup.calledOnce).to.be.true;
    });
    it('less than 3 ZooKeeper Servers', function () {
      controller.set('securityEnabled', false);
      App.store.load(App.HostComponent, {
        id: "NAMENODE_host1",
        component_name: 'NAMENODE',
        work_status: 'STARTED'
      });
      expect(controller.enableHighAvailability()).to.be.false;
      expect(controller.showErrorPopup.calledOnce).to.be.true;
      App.store.loadMany(App.HostComponent, [
        {
          id: "ZOOKEEPER_SERVER_host1",
          component_name: 'ZOOKEEPER_SERVER'
        },
        {
          id: "ZOOKEEPER_SERVER_host2",
          component_name: 'ZOOKEEPER_SERVER'
        },
        {
          id: "ZOOKEEPER_SERVER_host3",
          component_name: 'ZOOKEEPER_SERVER'
        }
      ]);
    });
    it('Security disabled and all checks passed', function () {
      App.router.set('transitionTo', function () {
      });
      expect(controller.enableHighAvailability()).to.be.true;
      expect(controller.showErrorPopup.called).to.be.false;
    });
    it('NameNode is started', function () {
      App.HostComponent.find('NAMENODE_host1').set('workStatus', 'INSTALLED');
      expect(controller.enableHighAvailability()).to.be.false;
      expect(controller.showErrorPopup.calledOnce).to.be.true;
      App.HostComponent.find('NAMENODE_host1').set('workStatus', 'STARTED');
    });
  });

  describe('#setSecurityStatus()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, "send", Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('testMode = true', function () {
      App.testEnableSecurity = false;
      App.testMode = true;
      controller.set('securityEnabled', false);
      controller.set('dataIsLoaded', false);
      controller.setSecurityStatus();
      expect(controller.get('securityEnabled')).to.be.true;
      expect(controller.get('dataIsLoaded')).to.be.true;
      expect(App.ajax.send.called).to.be.false;

    });
    it('testMode = false', function () {
      App.testMode = false;
      controller.set('securityEnabled', false);
      controller.set('dataIsLoaded', false);
      controller.setSecurityStatus();
      expect(controller.get('securityEnabled')).to.be.false;
      expect(controller.get('dataIsLoaded')).to.be.false;
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#getSecurityStatusFromServerSuccessCallback()', function () {

    beforeEach(function () {
      sinon.stub(controller, "getServiceConfigsFromServer", Em.K);
      sinon.stub(controller, "showErrorPopup", Em.K);
    });
    afterEach(function () {
      controller.getServiceConfigsFromServer.restore();
      controller.showErrorPopup.restore();
    });

    it('desired_configs is empty', function () {
      var data = {
        Clusters: {
          desired_configs: {}
        }
      };
      controller.getSecurityStatusFromServerSuccessCallback(data);
      expect(controller.showErrorPopup.calledOnce).to.be.true;
    });
    it('desired_configs does not have "global"', function () {
      var data = {
        Clusters: {
          desired_configs: {
            'hdfs-site': {}
          }
        }
      };
      controller.getSecurityStatusFromServerSuccessCallback(data);
      expect(controller.showErrorPopup.calledOnce).to.be.true;
    });
    it('desired_configs does not have "global"', function () {
      var data = {
        Clusters: {
          desired_configs: {
            'global': {
              tag: 1
            }
          }
        }
      };
      controller.getSecurityStatusFromServerSuccessCallback(data);
      expect(controller.get('tag')).to.equal(1);
      expect(controller.getServiceConfigsFromServer.calledOnce).to.be.true;
      expect(controller.showErrorPopup.called).to.be.false;
    });
  });

  describe('#getSecurityStatusFromServerSuccessCallback()', function () {

    beforeEach(function () {
      sinon.stub(controller, "getServiceConfigsFromServer", Em.K);
      sinon.stub(controller, "showErrorPopup", Em.K);
    });
    afterEach(function () {
      controller.getServiceConfigsFromServer.restore();
      controller.showErrorPopup.restore();
    });

    it('desired_configs is empty', function () {
      var data = {
        Clusters: {
          desired_configs: {}
        }
      };
      controller.getSecurityStatusFromServerSuccessCallback(data);
      expect(controller.showErrorPopup.calledOnce).to.be.true;
    });
    it('desired_configs does not have "global"', function () {
      var data = {
        Clusters: {
          desired_configs: {
            'hdfs-site': {}
          }
        }
      };
      controller.getSecurityStatusFromServerSuccessCallback(data);
      expect(controller.showErrorPopup.calledOnce).to.be.true;
    });
    it('desired_configs does not have "global"', function () {
      var data = {
        Clusters: {
          desired_configs: {
            'global': {
              tag: 1
            }
          }
        }
      };
      controller.getSecurityStatusFromServerSuccessCallback(data);
      expect(controller.get('tag')).to.equal(1);
      expect(controller.getServiceConfigsFromServer.calledOnce).to.be.true;
      expect(controller.showErrorPopup.called).to.be.false;
    });
  });

  describe('#joinMessage()', function () {
    it('message is empty', function () {
      var message = [];
      expect(controller.joinMessage(message)).to.be.empty;
    });
    it('message is array from two strings', function () {
      var message = ['yes', 'no'];
      expect(controller.joinMessage(message)).to.equal('yes<br/>no');
    });
    it('message is string', function () {
      var message = 'hello';
      expect(controller.joinMessage(message)).to.equal('<p>hello</p>');
    });
  });

  describe('#getServiceConfigsFromServer()', function () {

    it('properties is null', function () {
      App.router.set('configurationController', Em.Object.create({
        getConfigsByTags: function () {
          return this.get('data');
        },
        data: [
          {
            tag: 1,
            properties: null
          }
        ]
      }));
      controller.getServiceConfigsFromServer();
      expect(controller.get('dataIsLoaded')).to.be.true;
      expect(controller.get('securityEnabled')).to.be.false;
    });
    it('"security_enabled" config is absent', function () {
      App.router.set('configurationController.data', [
        {
          tag: 1,
          properties: {}
        }
      ]);
      controller.getServiceConfigsFromServer();
      expect(controller.get('dataIsLoaded')).to.be.true;
      expect(controller.get('securityEnabled')).to.be.false;
    });
    it('"security_enabled" is false', function () {
      App.router.set('configurationController.data', [
        {
          tag: 1,
          properties: {
            'security_enabled': false
          }
        }
      ]);
      controller.getServiceConfigsFromServer();
      expect(controller.get('dataIsLoaded')).to.be.true;
      expect(controller.get('securityEnabled')).to.be.false;
    });
    it('"security_enabled" is "false"', function () {
      App.router.set('configurationController.data', [
        {
          tag: 1,
          properties: {
            'security_enabled': "false"
          }
        }
      ]);
      controller.getServiceConfigsFromServer();
      expect(controller.get('dataIsLoaded')).to.be.true;
      expect(controller.get('securityEnabled')).to.be.false;
    });
    it('"security_enabled" is "true"', function () {
      App.router.set('configurationController.data', [
        {
          tag: 1,
          properties: {
            'security_enabled': "true"
          }
        }
      ]);
      controller.getServiceConfigsFromServer();
      expect(controller.get('dataIsLoaded')).to.be.true;
      expect(controller.get('securityEnabled')).to.be.true;
    });
    it('"security_enabled" is true', function () {
      App.router.set('configurationController.data', [
        {
          tag: 1,
          properties: {
            'security_enabled': true
          }
        }
      ]);
      controller.getServiceConfigsFromServer();
      expect(controller.get('dataIsLoaded')).to.be.true;
      expect(controller.get('securityEnabled')).to.be.true;
    });
  });
});

});

;require.register("test/controllers/main/admin/misc_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/misc_controller');


describe('App.MainAdminMiscController', function () {

  var controller = App.MainAdminMiscController.create();

  describe('#setContentProperty()', function () {
    var testCases = [
      {
        title: 'key is null',
        content: {
          key: null,
          configName: 'cc',
          miscConfigs: []
        },
        result: {
          output: false,
          configValue: 'test'
        }
      },
      {
        title: 'configName is null',
        content: {
          key: 'key',
          configName: null,
          miscConfigs: []
        },
        result: {
          output: false,
          configValue: 'test'
        }
      },
      {
        title: 'misc configs array doesn\'t contain such a config',
        content: {
          key: 'key',
          configName: 'config1',
          miscConfigs: []
        },
        result: {
          output: false,
          configValue: 'test'
        }
      },
      {
        title: 'content doesn\'t contain such a key',
        content: {
          key: 'key',
          configName: 'config1',
          miscConfigs: [
            Em.Object.create({
              name: 'test_key'
            })
          ]
        },
        result: {
          output: false,
          configValue: 'test'
        }
      },
      {
        title: 'content property match config',
        content: {
          key: 'testKey',
          configName: 'test_key',
          miscConfigs: [
            Em.Object.create({
              name: 'test_key',
              value: 'testValue'
            })
          ]
        },
        result: {
          output: true,
          configValue: 'testValue'
        }
      }
    ];
    controller.set('content', Em.Object.create({testKey: 'test'}));
    testCases.forEach(function (test) {
      it(test.title, function () {
        var content = controller.get('content');
        expect(controller.setContentProperty(test.content.key, test.content.configName, test.content.miscConfigs)).to.equal(test.result.output);
        expect(content.get('testKey')).to.equal(test.result.configValue);
      });
    });
  });

  describe('#sortByOrder()', function () {
    var testCases = [
      {
        title: 'sortOrder is null',
        content: {
          sortOrder: null,
          arrayToSort: [
            {
              name: 'one',
              displayName: 'one'
            }
          ]
        },
        result: ['one']
      },
      {
        title: 'sortOrder is empty',
        content: {
          sortOrder: [],
          arrayToSort: [
            {
              name: 'one',
              displayName: 'one'
            }
          ]
        },
        result: ['one']
      },
      {
        title: 'sortOrder items don\'t match items of array',
        content: {
          sortOrder: ['one'],
          arrayToSort: [
            {name: 'two'}
          ]
        },
        result: []
      },
      {
        title: 'sort items in reverse order',
        content: {
          sortOrder: ['two', 'one'],
          arrayToSort: [
            Em.Object.create({
              name: 'one',
              displayName: 'one'
            }),
            Em.Object.create({
              name: 'two',
              displayName: 'two'
            })
          ]
        },
        result: ['two', 'one']
      },
      {
        title: 'sort items in correct order',
        content: {
          sortOrder: ['one', 'two'],
          arrayToSort: [
            Em.Object.create({
              name: 'one',
              displayName: 'one'
            }),
            Em.Object.create({
              name: 'two',
              displayName: 'two'
            })
          ]
        },
        result: ['one', 'two']
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.sortByOrder(test.content.sortOrder, test.content.arrayToSort).mapProperty('displayName')).to.eql(test.result);
      });
    });
  });

  describe('#setProxyUserGroupLabel()', function () {

    it('proxyuser_group config is absent', function () {
      var misc_configs = [];
      controller.setProxyUserGroupLabel(misc_configs);
      expect(misc_configs.findProperty('name', 'proxyuser_group')).to.be.undefined;
    });
    it('if currentStackVersionNumber less than 2.1 then label should be omitting "FALCON" service', function () {
      var misc_configs = [Em.Object.create({
        name: 'proxyuser_group',
        displayName: 'test'
      })];
      App.set('currentStackVersion', "HDP-2.0");
      controller.setProxyUserGroupLabel(misc_configs);
      expect(misc_configs.findProperty('name', 'proxyuser_group').get('displayName')).to.equal('Proxy group for Hive, WebHCat and Oozie');
    });
    it('if currentStackVersionNumber equal 2.1 then label should stay the same', function () {
      var misc_configs = [Em.Object.create({
        name: 'proxyuser_group',
        displayName: 'test'
      })];
      App.set('currentStackVersion', "HDP-2.1");
      controller.setProxyUserGroupLabel(misc_configs);
      expect(misc_configs.findProperty('name', 'proxyuser_group').get('displayName')).to.equal('test');
    });
    it('if currentStackVersionNumber higher than 2.1 then label should stay the same', function () {
      var misc_configs = [Em.Object.create({
        name: 'proxyuser_group',
        displayName: 'test'
      })];
      App.set('currentStackVersion', "HDP-2.2");
      controller.setProxyUserGroupLabel(misc_configs);
      expect(misc_configs.findProperty('name', 'proxyuser_group').get('displayName')).to.equal('test');
    });
  })
});

});

;require.register("test/controllers/main/admin/security/add/addSecurity_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('mixins/common/localStorage');
require('controllers/wizard');
require('controllers/main/admin/security/add/addSecurity_controller');
require('models/cluster');
require('models/service');

describe('App.AddSecurityController', function () {

  var controller = App.AddSecurityController.create({
    currentStep: null
  });

  describe('#installedServices', function () {

    afterEach(function () {
      App.Service.find.restore();
    });

    it('No installed services', function () {
      sinon.stub(App.Service, 'find', function () {
        return [];
      });
      expect(controller.get('installedServices')).to.eql([]);
    });
    it('One service installed', function () {
      sinon.stub(App.Service, 'find', function () {
        return [Em.Object.create({serviceName: 'HDFS'})];
      });
      Em.propertyDidChange(controller, 'installedServices');
      expect(controller.get('installedServices')).to.eql(['HDFS']);
    });
  });

  describe('#secureServices', function () {

    afterEach(function () {
      App.get.restore();
    });

    it('App.isHadoop2Stack = false', function () {
      var result = [
        "GENERAL",
        "HDFS",
        "MAPREDUCE",
        "HIVE",
        "WEBHCAT",
        "HBASE",
        "ZOOKEEPER",
        "OOZIE",
        "NAGIOS"
      ];
      sinon.stub(App, 'get', function () {
        return false;
      });
      expect(controller.get('secureServices').mapProperty('serviceName')).to.eql(result);
    });
    it('App.isHadoop2Stack = true', function () {
      var result = [
        "GENERAL",
        "HDFS",
        "MAPREDUCE2",
        "YARN",
        "HIVE",
        "WEBHCAT",
        "HBASE",
        "ZOOKEEPER",
        "OOZIE",
        "NAGIOS",
        "STORM",
        "FALCON"
      ];
      sinon.stub(App, 'get', function () {
        return true;
      });
      Em.propertyDidChange(App, 'isHadoop2Stack');
      expect(controller.get('secureServices').mapProperty('serviceName')).to.eql(result);
    });
  });

  describe('#loadAllPriorSteps()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'loadServiceConfigs', Em.K);
      sinon.stub(controller, 'loadServices', Em.K);
      sinon.stub(controller, 'loadNnHaStatus', Em.K);
    });
    afterEach(function () {
      controller.loadServiceConfigs.restore();
      controller.loadServices.restore();
      controller.loadNnHaStatus.restore();
    });

    var commonSteps = ['4', '3', '2'];
    commonSteps.forEach(function (step) {
      it('Current step - ' + step, function () {
        controller.set('currentStep', step);
        controller.loadAllPriorSteps();
        expect(controller.loadServiceConfigs.calledOnce).to.be.true;
        expect(controller.loadServices.calledOnce).to.be.true;
        expect(controller.loadNnHaStatus.calledOnce).to.be.true;
      });
    });
    it('Current step - 1', function () {
      controller.set('currentStep', '1');
      controller.loadAllPriorSteps();
      expect(controller.loadServiceConfigs.called).to.be.false;
      expect(controller.loadServices.calledOnce).to.be.true;
      expect(controller.loadNnHaStatus.calledOnce).to.be.true;
    });
  });

  describe('#loadServices()', function () {
    it('No installed services', function () {
      controller.reopen({
        installedServices: [],
        secureServices: [
          {serviceName: 'GENERAL'}
        ]
      });
      controller.loadServices();
      expect(controller.get('content.services').mapProperty('serviceName')).to.eql(['GENERAL']);
    });
    it('Installed service does not match the secure one', function () {
      controller.set('installedServices', ["HDFS"]);
      controller.loadServices();
      expect(controller.get('content.services').mapProperty('serviceName')).to.eql(['GENERAL']);
    });
    it('Installed service matches the secure one', function () {
      controller.set('secureServices', [
        {serviceName: 'GENERAL'},
        {serviceName: 'HDFS'}
      ]);
      controller.loadServices();
      expect(controller.get('content.services').mapProperty('serviceName')).to.eql(['GENERAL', 'HDFS']);
    });
  });

  describe('#loadNnHaStatus()', function () {
    afterEach(function () {
      App.db.getIsNameNodeHa.restore();
    });
    it('NameNode HA is off', function () {
      sinon.stub(App.db, 'getIsNameNodeHa', function () {
        return false;
      });
      controller.loadNnHaStatus();
      expect(controller.get('content.isNnHa')).to.be.false;
    });
    it('NameNode HA is on', function () {
      sinon.stub(App.db, 'getIsNameNodeHa', function () {
        return true;
      });
      controller.loadNnHaStatus();
      expect(controller.get('content.isNnHa')).to.be.true;
    });
  });

  describe('#loadServiceConfigs()', function () {
    afterEach(function () {
      App.db.getSecureConfigProperties.restore();
    });
    it('SecureConfigProperties is empty', function () {
      sinon.stub(App.db, 'getSecureConfigProperties', function () {
        return [];
      });
      controller.loadServiceConfigs();
      expect(controller.get('content.serviceConfigProperties')).to.eql([]);
    });
    it('SecureConfigProperties has one config', function () {
      sinon.stub(App.db, 'getSecureConfigProperties', function () {
        return [{}];
      });
      controller.loadServiceConfigs();
      expect(controller.get('content.serviceConfigProperties')).to.eql([{}]);
    });
  });

  describe('#getConfigOverrides()', function () {
    var testCases = [
      {
        title: 'overrides is null',
        configProperty: Em.Object.create({overrides: null}),
        result: null
      },
      {
        title: 'overrides is empty',
        configProperty: Em.Object.create({overrides: []}),
        result: null
      },
      {
        title: 'overrides has one override',
        configProperty: Em.Object.create({
          overrides: [
            Em.Object.create({
              value: 'value1',
              selectedHostOptions: []
            })
          ]
        }),
        result: [{
          value: 'value1',
          hosts: []
        }]
      },
      {
        title: 'overrides has one override with hosts',
        configProperty: Em.Object.create({
          overrides: [
            Em.Object.create({
              value: 'value1',
              selectedHostOptions: ['host1']
            })
          ]
        }),
        result: [{
          value: 'value1',
          hosts: ['host1']
        }]
      }
    ];

    testCases.forEach(function(test){
      it(test.title, function () {
        expect(controller.getConfigOverrides(test.configProperty)).to.eql(test.result);
      });
    });
  });

  describe('#saveServiceConfigProperties()', function () {
    var testCases = [
      {
        title: 'stepConfigs is empty',
        stepController: Em.Object.create({
          stepConfigs: []
        }),
        result: []
      },
      {
        title: 'No configs in service',
        stepController: Em.Object.create({
          stepConfigs: [
            Em.Object.create({configs: []})
          ]
        }),
        result: []
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        sinon.stub(App.db, 'setSecureConfigProperties', Em.K);
        controller.saveServiceConfigProperties(test.stepController);
        expect(App.db.setSecureConfigProperties.calledWith(test.result)).to.be.true;
        expect(controller.get('content.serviceConfigProperties')).to.eql(test.result);
        App.db.setSecureConfigProperties.restore();
      });
    });
    it('Service has config', function () {
      var  stepController = Em.Object.create({
        stepConfigs: [
          Em.Object.create({configs: [
            Em.Object.create({
              name: 'config1',
              value: 'value1'
            })
          ]})
        ]
      });
      sinon.stub(App.db, 'setSecureConfigProperties', Em.K);
      controller.saveServiceConfigProperties(stepController);
      expect(App.db.setSecureConfigProperties.calledOnce).to.be.true;
      expect(controller.get('content.serviceConfigProperties').mapProperty('name')).to.eql(['config1']);
      App.db.setSecureConfigProperties.restore();
    });
  });
});

});

;require.register("test/controllers/main/admin/security/add/step1_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('controllers/main/admin/security/add/step1');
require('models/service');

describe('App.MainAdminSecurityAddStep1Controller', function () {

  var controller = App.MainAdminSecurityAddStep1Controller.create({
    content: {}
  });

  describe('#isATSInstalled()', function() {
    it('content.services is empty', function() {
      controller.set('content.services', []);
      expect(controller.isATSInstalled()).to.be.false;
    });
    it('content.services does not contain YARN', function() {
      controller.set('content.services', [{serviceName: 'HDFS'}]);
      expect(controller.isATSInstalled()).to.be.false;
    });
    it('YARN does not have ATS', function() {
      sinon.stub(App.Service, 'find', function(){
        return Em.Object.create({hostComponents: []})
      });
      controller.set('content.services', [{serviceName: 'YARN'}]);
      expect(controller.isATSInstalled()).to.be.false;
      App.Service.find.restore();
    });
    it('YARN has ATS', function() {
      sinon.stub(App.Service, 'find', function(){
        return Em.Object.create({hostComponents: [{
          componentName: 'APP_TIMELINE_SERVER'
        }]})
      });
      controller.set('content.services', [{serviceName: 'YARN'}]);
      expect(controller.isATSInstalled()).to.be.true;
      App.Service.find.restore();
    });
  });
});

});

;require.register("test/controllers/main/admin/security/add/step2_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('controllers/main/admin/security/add/step2');
require('models/service');

describe('App.MainAdminSecurityAddStep2Controller', function () {

  var controller = App.MainAdminSecurityAddStep2Controller.create({
    content: {}
  });

  describe('#clearStep()', function () {
    it('Info is empty', function () {
      controller.set('stepConfigs', []);
      controller.set('securityUsers', []);
      controller.clearStep();
      expect(controller.get('stepConfigs')).to.be.empty;
      expect(controller.get('securityUsers')).to.be.empty;
    });
    it('Info filled', function () {
      controller.set('stepConfigs', [1]);
      controller.set('securityUsers', [1]);
      controller.clearStep();
      expect(controller.get('stepConfigs')).to.be.empty;
      expect(controller.get('securityUsers')).to.be.empty;
    });
  });

  describe('#isSubmitDisabled', function () {
    var tests = [
      {
        config: [
          {
            showConfig: true,
            errorCount: 0
          }
        ],
        m: 'All show configs, nothing with errors',
        e: false
      },
      {
        config: [
          {
            showConfig: true,
            errorCount: 0
          },
          {
            showConfig: true,
            errorCount: 1
          }
        ],
        m: 'All show configs, 1 with errors',
        e: true
      },
      {
        config: [
          {
            showConfig: true,
            errorCount: 0
          },
          {
            showConfig: false,
            errorCount: 1
          }
        ],
        m: '1 has errors but not visible',
        e: false
      },
      {
        config: [
          {
            showConfig: false,
            errorCount: 0
          },
          {
            showConfig: false,
            errorCount: 1
          }
        ],
        m: '1 has errors, all not visible',
        e: false
      },
      {
        config: [
          {
            showConfig: true,
            errorCount: 1
          },
          {
            showConfig: true,
            errorCount: 1
          }
        ],
        m: 'All has errors, all not visible',
        e: true
      }
    ];
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('stepConfigs', test.config);
        expect(controller.get('isSubmitDisabled')).to.equal(test.e);
      });
    });
  });

  describe('#loadStep()', function () {
    it('load step', function () {
      controller.set('stepConfigs', [
        {}
      ]);
      controller.set('securityUsers', ['user1']);
      controller.set('content.services', ['service1']);
      controller.set('content.serviceConfigProperties', ['config1']);
      sinon.stub(controller, 'clearStep', Em.K);
      sinon.stub(controller, 'loadUsers', Em.K);
      sinon.stub(controller, 'addUserPrincipals', Em.K);
      sinon.stub(controller, 'addMasterHostToGlobals', Em.K);
      sinon.stub(controller, 'addSlaveHostToGlobals', Em.K);
      sinon.stub(controller, 'renderServiceConfigs', Em.K);
      sinon.stub(controller, 'changeCategoryOnHa', Em.K);
      sinon.stub(controller, 'setStoredConfigsValue', Em.K);
      sinon.stub(controller, 'addHostPrincipals', Em.K);
      sinon.stub(App.Service, 'find', function () {
        return [
          {serviceName: 'HDFS'}
        ];
      });

      controller.loadStep();
      expect(controller.get('installedServices')).to.eql(['HDFS']);
      expect(controller.clearStep.calledOnce).to.be.true;
      expect(controller.loadUsers.calledOnce).to.be.true;
      expect(controller.addUserPrincipals.calledWith(['service1'], ['user1'])).to.be.true;
      expect(controller.addMasterHostToGlobals.calledOnce).to.be.true;
      expect(controller.addSlaveHostToGlobals.calledOnce).to.be.true;
      expect(controller.addHostPrincipals.calledOnce).to.be.true;
      expect(controller.renderServiceConfigs.calledWith(['service1'])).to.be.true;
      expect(controller.changeCategoryOnHa.calledWith(['service1'], [{}])).to.be.true;
      expect(controller.setStoredConfigsValue.calledWith(['config1'])).to.be.true;

      controller.clearStep.restore();
      controller.loadUsers.restore();
      controller.addUserPrincipals.restore();
      controller.addMasterHostToGlobals.restore();
      controller.addSlaveHostToGlobals.restore();
      controller.renderServiceConfigs.restore();
      controller.changeCategoryOnHa.restore();
      controller.setStoredConfigsValue.restore();
      controller.addHostPrincipals.restore();
      App.Service.find.restore();
    });
  });

  describe('#setStoredConfigsValue()', function () {
    it('storedConfigProperties is null', function () {
      expect(controller.setStoredConfigsValue(null)).to.be.false;
    });
    it('stepConfigs is empty', function () {
      controller.set('stepConfigs', []);
      expect(controller.setStoredConfigsValue([])).to.be.true;
      expect(controller.get('stepConfigs')).to.be.empty;
    });
    it('stepConfig has no configs', function () {
      controller.set('stepConfigs', [Em.Object.create({
        configs: []
      })]);
      expect(controller.setStoredConfigsValue([])).to.be.true;
      expect(controller.get('stepConfigs')[0].get('configs')).to.be.empty;
    });
    it('stepConfig has no stored configs', function () {
      controller.set('stepConfigs', [Em.Object.create({
        configs: [Em.Object.create({
          name: 'config1',
          value: 'value1'
        })]
      })]);
      var storedConfigProperties = [
        {
          name: 'config2',
          value: "value2"
        }
      ];
      expect(controller.setStoredConfigsValue(storedConfigProperties)).to.be.true;
      expect(controller.get('stepConfigs')[0].get('configs').findProperty('name', 'config1').get('value')).to.equal('value1');
    });
    it('stepConfig has stored configs', function () {
      controller.set('stepConfigs', [Em.Object.create({
        configs: [Em.Object.create({
          name: 'config2',
          value: 'value1'
        })]
      })]);
      var storedConfigProperties = [
        {
          name: 'config2',
          value: "value2"
        }
      ];
      expect(controller.setStoredConfigsValue(storedConfigProperties)).to.be.true;
      expect(controller.get('stepConfigs')[0].get('configs').findProperty('name', 'config2').get('value')).to.equal('value2');
    });
  });

  describe('#renderServiceConfigs()', function () {
    it('serviceConfigs and stepConfigs are empty', function () {
      controller.set('stepConfigs', []);
      controller.renderServiceConfigs([]);
      expect(controller.get('selectedService')).to.be.undefined;
    });
    it('serviceConfigs is empty', function () {
      controller.set('stepConfigs', [
        {showConfig: true}
      ]);
      controller.renderServiceConfigs([]);
      expect(controller.get('selectedService')).to.eql({showConfig: true});
    });
    it('serviceConfigs has service', function () {
      var serviceConfigs = [
        {
          serviceName: 'HDFS',
          configs: []
        }
      ];
      sinon.stub(controller, 'wrapConfigProperties', function () {
        return [];
      });
      controller.set('stepConfigs', []);
      controller.renderServiceConfigs(serviceConfigs);
      expect(controller.get('selectedService').get('serviceName')).to.equal('HDFS');
      expect(controller.get('selectedService').get('showConfig')).to.be.true;
      expect(controller.get('selectedService').get('configs')).to.be.empty;
      expect(controller.wrapConfigProperties.calledWith({
        serviceName: 'HDFS',
        configs: []
      })).to.be.true;
      controller.wrapConfigProperties.restore();
    });
  });

  describe('#wrapConfigProperties()', function () {
    it('_componentConfig is empty', function () {
      expect(controller.wrapConfigProperties({configs: []})).to.be.empty;
    });
    it('serviceConfigs has service', function () {
      var mock = Em.Object.create({
        validate: Em.K,
        isReconfigurable: true,
        isEditable: false
      });
      var _componentConfig = {configs: [
        {name: 'config1'}
      ]};
      sinon.stub(App.ServiceConfigProperty, 'create', function () {
        return mock;
      });
      sinon.spy(mock, 'validate');
      expect(controller.wrapConfigProperties(_componentConfig)[0].get('isEditable')).to.be.true;
      expect(App.ServiceConfigProperty.create.calledWith({name: 'config1'})).to.be.true;
      expect(mock.validate.calledOnce).to.be.true;
      mock.validate.restore();
      App.ServiceConfigProperty.create.restore();
    });
  });

  describe('#setHostsToConfig()', function () {
    it('service is null', function () {
      expect(controller.setHostsToConfig(null)).to.be.false;
    });
    it('service.configs is empty', function () {
      controller.set('content.services', [
        {
          serviceName: 'HDFS',
          configs: []
        }
      ]);
      expect(controller.setHostsToConfig('HDFS')).to.be.false;
    });
    it('No such config name in service.configs', function () {
      controller.set('content.services', [
        {
          serviceName: 'HDFS',
          configs: [
            {
              name: 'config1'
            }
          ]
        }
      ]);
      expect(controller.setHostsToConfig('HDFS', 'config2')).to.be.false;
    });
    it('Correct config in service.configs', function () {
      sinon.stub(App.Service, 'find', function () {
        return Em.Object.create({
          hostComponents: [
            Em.Object.create({
              componentName: 'comp1',
              host: {hostName: 'host1'}
            })
          ]
        });
      });
      expect(controller.setHostsToConfig('HDFS', 'config1', ['comp1'])).to.be.true;
      expect(controller.get('content.services')[0].configs[0].defaultValue).to.eql(['host1']);
      App.Service.find.restore();
    });
  });

  describe('#setHostToPrincipal()', function () {
    it('service is null', function () {
      expect(controller.setHostToPrincipal(null)).to.be.false;
    });
    it('service.configs is empty', function () {
      controller.set('content.services', [
        {
          serviceName: 'HDFS',
          configs: []
        }
      ]);
      expect(controller.setHostToPrincipal('HDFS')).to.be.false;
    });
    it('No such hostConfigName name in service.configs', function () {
      controller.set('content.services', [
        {
          serviceName: 'HDFS',
          configs: [
            {
              name: 'config1'
            }
          ]
        }
      ]);
      expect(controller.setHostToPrincipal('HDFS', 'config2', 'config1')).to.be.false;
    });
    it('No such principalConfigName name in service.configs', function () {
      expect(controller.setHostToPrincipal('HDFS', 'config1', 'config2')).to.be.false;
    });
    it('Correct config in service.configs', function () {
      controller.set('content.services', [
        {
          serviceName: 'HDFS',
          configs: [
            {
              name: 'config1',
              defaultValue: 'value1'
            },
            {
              name: 'principal1'
            }
          ]
        }
      ]);
      expect(controller.setHostToPrincipal('HDFS', 'config1', 'principal1', 'name1')).to.be.true;
      expect(controller.get('content.services')[0].configs[0].defaultValue).to.equal('value1');
      expect(controller.get('content.services')[0].configs[1].defaultValue).to.equal('name1value1');
    });
    it('Correct config in service.configs, defaultValue is array', function () {
      controller.set('content.services', [
        {
          serviceName: 'HDFS',
          configs: [
            {
              name: 'config1',
              defaultValue: ['Value1']
            },
            {
              name: 'principal1'
            }
          ]
        }
      ]);
      expect(controller.setHostToPrincipal('HDFS', 'config1', 'principal1', 'name1')).to.be.true;
      expect(controller.get('content.services')[0].configs[0].defaultValue).to.equal('Value1');
      expect(controller.get('content.services')[0].configs[1].defaultValue).to.equal('name1value1');
    });
  });

  describe('#loadUsers()', function () {

    afterEach(function () {
      App.router.get.restore();
    });

    it('serviceUsers is correct', function () {
      sinon.stub(App.router, 'get', function () {
        return Em.Object.create({serviceUsers: [
          {}
        ]})
      });
      controller.loadUsers();
      expect(controller.get('securityUsers')).to.eql([
        {}
      ]);
    });
    it('serviceUsers is null, testMode = true', function () {
      sinon.stub(App.router, 'get', function () {
        return Em.Object.create({serviceUsers: null})
      });
      App.testMode = true;
      controller.loadUsers();
      expect(controller.get('securityUsers').mapProperty('name')).to.eql(["hdfs_user",
        "mapred_user",
        "hbase_user",
        "hive_user",
        "smokeuser"
      ]);
    });
    it('serviceUsers is empty, testMode = true', function () {
      sinon.stub(App.router, 'get', function () {
        return Em.Object.create({serviceUsers: []})
      });
      App.testMode = true;
      controller.loadUsers();
      expect(controller.get('securityUsers').mapProperty('name')).to.eql(["hdfs_user",
        "mapred_user",
        "hbase_user",
        "hive_user",
        "smokeuser"
      ]);
    });
    it('serviceUsers is null, testMode = false', function () {
      sinon.stub(App.router, 'get', function () {
        return Em.Object.create({serviceUsers: null})
      });
      sinon.stub(App.db, 'getSecureUserInfo', function () {
        return [
          {}
        ];
      });
      App.testMode = false;
      controller.loadUsers();
      expect(controller.get('securityUsers')).to.eql([
        {}
      ]);
      expect(App.db.getSecureUserInfo.calledOnce).to.be.true;
      App.db.getSecureUserInfo.restore();
    });
    it('serviceUsers is empty, testMode = false', function () {
      sinon.stub(App.router, 'get', function () {
        return Em.Object.create({serviceUsers: []})
      });
      sinon.stub(App.db, 'getSecureUserInfo', function () {
        return [
          {}
        ];
      });
      App.testMode = false;
      controller.loadUsers();
      expect(controller.get('securityUsers')).to.eql([
        {}
      ]);
      expect(App.db.getSecureUserInfo.calledOnce).to.be.true;
      App.db.getSecureUserInfo.restore();
    });
  });

  describe('#addUserPrincipals()', function () {

    afterEach(function () {
      controller.setUserPrincipalValue.restore();
    });

    var serviceConfigs = [
      {
        serviceName: 'GENERAL',
        configs: [
          {name: 'hbase_principal_name'},
          {name: 'hbase_user_keytab'}
        ]
      }
    ];
    var securityUsers = [];

    it('HBASE service is not installed', function () {
      sinon.stub(controller, 'setUserPrincipalValue', Em.K);
      controller.addUserPrincipals(serviceConfigs, securityUsers);
      expect(controller.setUserPrincipalValue.calledTwice).to.be.true;
    });
    it('HBASE service is installed, setUserPrincipalValue return false', function () {
      sinon.stub(controller, 'setUserPrincipalValue', function () {
        return false;
      });
      serviceConfigs.push({serviceName: 'HBASE'});
      controller.addUserPrincipals(serviceConfigs, securityUsers);
      expect(controller.setUserPrincipalValue.calledThrice).to.be.true;
    });
    it('HBASE service is installed, setUserPrincipalValue return true', function () {
      sinon.stub(controller, 'setUserPrincipalValue', function () {
        return true;
      });
      controller.addUserPrincipals(serviceConfigs, securityUsers);
      expect(controller.setUserPrincipalValue.calledThrice).to.be.true;
      expect(serviceConfigs[0].configs.findProperty('name', 'hbase_principal_name').isVisible).to.be.true;
      expect(serviceConfigs[0].configs.findProperty('name', 'hbase_user_keytab').isVisible).to.be.true;
    });
  });

  describe('#setUserPrincipalValue()', function () {
    it('user and userPrincipal are null', function () {
      expect(controller.setUserPrincipalValue(null, null)).to.be.false;
    });
    it('user is null', function () {
      expect(controller.setUserPrincipalValue(null, {})).to.be.false;
    });
    it('userPrincipal is null', function () {
      expect(controller.setUserPrincipalValue({}, null)).to.be.false;
    });
    it('user and userPrincipal are correct', function () {
      var user = {value: 'value1'};
      var userPrincipal = {};
      expect(controller.setUserPrincipalValue(user, userPrincipal)).to.be.true;
      expect(userPrincipal.defaultValue).to.equal('value1');
    });
  });

  describe('#addSlaveHostToGlobals()', function () {
    it('slaveComponentMap is empty', function () {
      sinon.stub(controller, 'setHostsToConfig', Em.K);
      controller.set('slaveComponentMap', []);
      controller.addSlaveHostToGlobals();
      expect(controller.setHostsToConfig.called).to.be.false;
      controller.setHostsToConfig.restore();
    });
    it('Correct data', function () {
      sinon.stub(controller, 'setHostsToConfig', Em.K);
      controller.set('slaveComponentMap', [
        {
          serviceName: 'HDFS',
          configName: 'datanode_hosts',
          component: 'DATANODE'
        }
      ]);
      controller.addSlaveHostToGlobals();
      expect(controller.setHostsToConfig.calledWith('HDFS', 'datanode_hosts', ['DATANODE'])).to.be.true;
      controller.setHostsToConfig.restore();
    });
  });

  describe('#addMasterHostToGlobals()', function () {
    it('masterComponentMap is empty', function () {
      sinon.stub(controller, 'setHostsToConfig', Em.K);
      controller.set('masterComponentMap', []);
      controller.addMasterHostToGlobals();
      expect(controller.setHostsToConfig.called).to.be.false;
      controller.setHostsToConfig.restore();
    });
    it('Correct data', function () {
      sinon.stub(controller, 'setHostsToConfig', Em.K);
      controller.set('masterComponentMap', [
        {
          serviceName: 'HDFS',
          configName: 'datanode_hosts',
          components: ['DATANODE']
        }
      ]);
      controller.addMasterHostToGlobals();
      expect(controller.setHostsToConfig.calledWith('HDFS', 'datanode_hosts', ['DATANODE'])).to.be.true;
      controller.setHostsToConfig.restore();
    });
  });

  describe('#addHostPrincipals()', function () {
    it('hostToPrincipalMap is empty', function () {
      sinon.stub(controller, 'setHostToPrincipal', Em.K);
      controller.set('hostToPrincipalMap', []);
      controller.addHostPrincipals();
      expect(controller.setHostToPrincipal.called).to.be.false;
      controller.setHostToPrincipal.restore();
    });
    it('Correct data', function () {
      sinon.stub(controller, 'setHostToPrincipal', Em.K);
      controller.set('hostToPrincipalMap', [
        {
          serviceName: 'HDFS',
          configName: 'datanode_hosts',
          principalName: 'principal1',
          primaryName: 'name1'
        }
      ]);
      controller.addHostPrincipals();
      expect(controller.setHostToPrincipal.calledWith('HDFS', 'datanode_hosts', 'principal1', 'name1')).to.be.true;
      controller.setHostToPrincipal.restore();
    });
  });

  describe('#changeCategoryOnHa()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'removeConfigCategory', Em.K);
    });
    afterEach(function () {
      controller.removeConfigCategory.restore();
    });

    var serviceConfigs = [{
      serviceName: 'HDFS',
      configCategories: []
    }];
    var stepConfigs = [Em.Object.create({
      serviceName: 'HDFS',
      configs: []
    })];

    it('HDFS service is absent', function () {
      expect(controller.changeCategoryOnHa([], [])).to.be.false;
    });
    it('HDFS service installed, App.testMode and App.testNameNodeHA - true', function () {
      App.testMode = true;
      App.testNameNodeHA = true;
      expect(controller.changeCategoryOnHa(serviceConfigs, stepConfigs)).to.be.true;
      expect(controller.removeConfigCategory.calledWith([], [], 'SNameNode')).to.be.true;
      App.testMode = false;
      App.testNameNodeHA = false;
    });
    it('HDFS service installed, content.isNnHa = true', function () {
      controller.set('content.isNnHa', 'true');
      expect(controller.changeCategoryOnHa(serviceConfigs, stepConfigs)).to.be.true;
      expect(controller.removeConfigCategory.calledWith([], [], 'SNameNode')).to.be.true;
    });
    it('HDFS service installed, HA disabled', function () {
      controller.set('content.isNnHa', 'false');
      expect(controller.changeCategoryOnHa(serviceConfigs, stepConfigs)).to.be.true;
      expect(controller.removeConfigCategory.calledWith([], [], 'JournalNode')).to.be.true;
    });
  });

  describe('#removeConfigCategory()', function () {
    it('properties should be hidden', function () {
      var properties = [
        Em.Object.create({
          category: 'comp1',
          isVisible: true
        })
      ];
      controller.removeConfigCategory(properties, [], 'comp1');
      expect(properties[0].isVisible).to.be.false;
    });
    it('category should be removed', function () {
      var configCategories = [
        Em.Object.create({
          name: 'comp1'
        })
      ];
      controller.removeConfigCategory([], configCategories, 'comp1');
      expect(configCategories).to.be.empty;
    });
  });
});

});

;require.register("test/controllers/main/admin/security/add/step3_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('controllers/main/admin/security/add/step3');
var stringUtils = require('utils/string_utils');

describe('App.MainAdminSecurityAddStep3Controller', function () {

  var controller = App.MainAdminSecurityAddStep3Controller.create({
    content: {}
  });

  describe('#openInfoInNewTab()', function() {
    it('Correct data', function() {
      var mock = {
        document: {
          write: function(){}
        },
        focus: function(){}
      };
      sinon.stub(window, 'open', function () {
        return mock;
      });
      sinon.stub(stringUtils, 'arrayToCSV', function () {
        return 'CSV_CONTENT';
      });
      sinon.spy(mock.document, 'write');
      sinon.spy(mock, 'focus');
      controller.set('hostComponents', ['comp1']);

      controller.openInfoInNewTab();
      expect(window.open.calledWith('')).to.be.true;
      expect(stringUtils.arrayToCSV.calledWith(['comp1'])).to.be.true;
      expect(mock.document.write.calledWith('CSV_CONTENT')).to.be.true;
      expect(mock.focus.calledOnce).to.be.true;
      window.open.restore();
      stringUtils.arrayToCSV.restore();
    });
  });

  describe('#loadStep()', function() {

    beforeEach(function(){
      sinon.stub(controller, 'getSecurityUsers', function () {
        return [{
          name: 'user_group',
          value: 'value1'
        }];
      });
    });
    afterEach(function(){
      App.Host.find.restore();
      controller.getSecurityUsers.restore();
    });

    it('No hosts installed', function() {
      sinon.stub(App.Host, 'find', function(){
        return [];
      });
      controller.loadStep();
      expect(controller.get('hostComponents')).to.be.empty;
    });
    it('One host installed', function () {
      sinon.stub(App.Host, 'find', function () {
        return [Em.Object.create({hostName: 'host1'})];
      });
      sinon.stub(controller, 'setMandatoryConfigs', function (result) {
        return result.push('setMandatoryConfigs');
      });
      sinon.stub(controller, 'setComponentsConfig', function (result) {
        return result.push('setComponentsConfig');
      });
      sinon.stub(controller, 'setHostComponentsSecureValue', function (result) {
        return result.push('setHostComponentsSecureValue');
      });

      controller.loadStep();
      expect(controller.setMandatoryConfigs.calledOnce).to.be.true;
      expect(controller.setComponentsConfig.calledOnce).to.be.true;
      expect(controller.setHostComponentsSecureValue.calledOnce).to.be.true;
      expect(controller.get('hostComponents')).to.eql(["setMandatoryConfigs", "setComponentsConfig", "setHostComponentsSecureValue"]);

      controller.setMandatoryConfigs.restore();
      controller.setComponentsConfig.restore();
      controller.setHostComponentsSecureValue.restore();
    });
  });

  describe('#buildComponentToOwnerMap()', function() {
    it('componentToUserMap is empty', function() {
      controller.set('componentToUserMap', {});
      expect(controller.buildComponentToOwnerMap([])).to.eql({});
    });
    it('componentToUserMap has properties', function() {
      controller.set('componentToUserMap', {'COMP1': 'config1'});
      var securityUsers = [{
        name: 'config1',
        value: 'value1'
      }];
      expect(controller.buildComponentToOwnerMap(securityUsers)).to.eql({'COMP1': 'value1'});
    });
  });

  describe('#setComponentsConfig()', function() {

    beforeEach(function(){
      controller.set('content.serviceConfigProperties', [
        {
          serviceName: 'HDFS',
          name: 'principal1',
          value: '_HOST'
        },
        {
          serviceName: 'HDFS',
          name: 'keytab1',
          value: 'value1'
        }
      ]);
    });

    it('componentToConfigMap is empty', function() {
      controller.set('componentToConfigMap', []);
      var result = [];
      controller.setComponentsConfig(result, Em.Object.create(), 'hadoopGroupId');
      expect(result).to.be.empty;
    });
    it('isHadoop2Stack = false, when component from stack2', function() {
      sinon.stub(App, 'get', function () {
        return false;
      });
      controller.set('componentToConfigMap', [{
        componentName: 'DATANODE',
        principal: 'principal1',
        keytab: 'keytab1',
        displayName: 'displayName1',
        isHadoop2Stack: true
      }]);
      var host = Em.Object.create({
        hostComponents: [{componentName: 'DATANODE'}],
        hostName: 'host1'
      });
      var result = [];
      controller.setComponentsConfig(result, host, 'hadoopGroupId');
      expect(result).to.be.empty;
      App.get.restore();
    });
    it('isHadoop2Stack = true, when component from stack2', function() {
      sinon.stub(App, 'get', function () {
        return true;
      });
      controller.set('componentToConfigMap', [{
        componentName: 'DATANODE',
        principal: 'principal1',
        keytab: 'keytab1',
        displayName: 'displayName1',
        isHadoop2Stack: true
      }]);
      var host = Em.Object.create({
        hostComponents: [{componentName: 'DATANODE'}],
        hostName: 'host1'
      });
      var result = [];
      controller.setComponentsConfig(result, host, 'hadoopGroupId');
      expect(result.length).to.equal(1);
      App.get.restore();
    });
    it('Component does not match host-component', function() {
      controller.set('componentToConfigMap', [{
        componentName: 'DATANODE',
        principal: 'principal1',
        keytab: 'keytab1',
        displayName: 'displayName1'
      }]);
      var host = Em.Object.create({
        hostComponents: [{componentName: 'DATANODE1'}],
        hostName: 'host1'
      });
      var result = [];
      controller.setComponentsConfig(result, host, 'hadoopGroupId');
      expect(result).to.be.empty;
    });
    it('Component matches host-component', function() {
      controller.set('componentToConfigMap', [{
        componentName: 'DATANODE',
        principal: 'principal1',
        keytab: 'keytab1',
        displayName: 'displayName1'
      }]);
      var host = Em.Object.create({
        hostComponents: [{componentName: 'DATANODE'}],
        hostName: 'host1'
      });
      var result = [];
      controller.setComponentsConfig(result, host, 'hadoopGroupId');
      expect(result.length).to.equal(1);
    });
  });

  describe('#setMandatoryConfigs()', function() {

    beforeEach(function () {
      sinon.stub(App.Service, 'find', function () {
        return [
          {serviceName: 'SERVICE1'}
        ];
      });
      controller.set('content.serviceConfigProperties', [
        {
          serviceName: 'GENERAL',
          name: 'kerberos_domain',
          value: 'realm1'
        }
      ]);
    });
    afterEach(function () {
      App.Service.find.restore();
    });

    it('mandatoryConfigs is empty', function() {
      var result = [];
      controller.set('mandatoryConfigs', []);

      controller.setMandatoryConfigs(result, [], '', '');
      expect(result).to.be.empty;
    });
    it('config has unknown service to check', function() {
      var result = [];
      controller.set('mandatoryConfigs', [{
        userConfig: 'kerberos_domain',
        keytab: 'kerberos_domain',
        displayName: '',
        checkService: 'HBASE'
      }]);

      controller.setMandatoryConfigs(result, [], '', '');
      expect(result).to.be.empty;
    });
    it('config should be added', function() {
      var result = [];
      controller.set('mandatoryConfigs', [{
        userConfig: 'userConfig1',
        keytab: 'kerberos_domain',
        displayName: ''
      }]);
      var securityUsers = [{
        name: 'userConfig1',
        value: 'value1'
      }];

      controller.setMandatoryConfigs(result, securityUsers, '', '');
      expect(result.length).to.equal(1);
    });
  });

  describe('#setHostComponentsSecureValue()', function() {

    beforeEach(function () {
      sinon.stub(controller, 'buildComponentToOwnerMap', Em.K);
      sinon.stub(controller, 'changeDisplayName', Em.K);
      sinon.stub(controller, 'getSecureProperties', function(){
        return {principal: '', keytab: ''};
      });
    });
    afterEach(function () {
      controller.buildComponentToOwnerMap.restore();
      controller.changeDisplayName.restore();
      controller.getSecureProperties.restore();
    });

    it('host.hostComponents is empty', function() {
      var result = [];
      var host = Em.Object.create({
        hostComponents: []
      });

      controller.setHostComponentsSecureValue(result, host);
      expect(result).to.be.empty;
    });
    it('host-component does not match component to display', function() {
      var result = [];
      var host = Em.Object.create({
        hostComponents: [Em.Object.create({
          componentName: 'UNKNOWN'
        })]
      });

      controller.setHostComponentsSecureValue(result, host);
      expect(result).to.be.empty;
    });
    it('host-component matches component to display', function() {
      var result = [];
      var host = Em.Object.create({
        hostComponents: [Em.Object.create({
          componentName: 'DATANODE'
        })]
      });

      controller.setHostComponentsSecureValue(result, host, {}, [], '');
      expect(result.length).to.equal(1);
    });
    it('addedPrincipalsHost already contain such config', function() {
      var result = [];
      var host = Em.Object.create({
        hostName: 'host1',
        hostComponents: [Em.Object.create({
          componentName: 'DATANODE'
        })]
      });

      controller.setHostComponentsSecureValue(result, host, {'host1--': true}, [], '');
      expect(result.length).to.be.empty;
    });
  });

  describe('#getSecureProperties()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'getPrincipal', function () {
        return 'principal';
      });
    });
    afterEach(function () {
      controller.getPrincipal.restore();
    });

    var testCases = [
      {
        title: 'serviceConfigs is empty',
        content: {
          serviceConfigs: [],
          componentName: ''
        },
        result: {}
      },
      {
        title: 'Config has component that does not match component name',
        content: {
          serviceConfigs: [{
            component: 'comp1'
          }],
          componentName: 'comp2'
        },
        result: {}
      },
      {
        title: 'Config has components that does not match component name',
        content: {
          serviceConfigs: [{
            components: ['comp1']
          }],
          componentName: 'comp2'
        },
        result: {}
      },
      {
        title: 'Config has component that matches component name',
        content: {
          serviceConfigs: [{
            name: 'C_principal_name',
            component: 'comp1',
            value: 'value1'
          }],
          componentName: 'comp1'
        },
        result: {
          principal: 'principal'
        }
      },
      {
        title: 'Config has components that matches component name',
        content: {
          serviceConfigs: [{
            name: 'C_principal_name',
            components: ['comp1'],
            value: 'value1'
          }],
          componentName: 'comp1'
        },
        result: {
          principal: 'principal'
        }
      },
      {
        title: 'Config name without correct postfix',
        content: {
          serviceConfigs: [{
            name: 'config1',
            component: 'comp1',
            value: 'value1'
          }],
          componentName: 'comp1'
        },
        result: {}
      },
      {
        title: 'Config name with "_keytab" postfix',
        content: {
          serviceConfigs: [{
            name: 'c_keytab',
            component: 'comp1',
            value: 'value1'
          }],
          componentName: 'comp1'
        },
        result: {
          keytab: 'value1'
        }
      },
      {
        title: 'Config name with "_keytab_path" postfix',
        content: {
          serviceConfigs: [{
            name: 'c_keytab_path',
            component: 'comp1',
            value: 'value1'
          }],
          componentName: 'comp1'
        },
        result: {
          keytab: 'value1'
        }
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.getSecureProperties(test.content.serviceConfigs, test.content.componentName, '')).to.eql(test.result);
      });
    });
  });

  describe('#getPrincipal()', function () {

    var testCases = [
      {
        title: 'Config value missing "_HOST" string, unit is empty',
        content: {
          config: {
            value: 'value1',
            unit: ''
          },
          hostName: ''
        },
        result: 'value1'
      },
      {
        title: 'Config value missing "_HOST" string, unit is correct',
        content: {
          config: {
            value: 'value1',
            unit: 'unit1'
          },
          hostName: ''
        },
        result: 'value1unit1'
      },
      {
        title: 'Config value contains "_HOST" string, host name in lowercase',
        content: {
          config: {
            value: '_HOST',
            unit: 'unit1'
          },
          hostName: 'host1'
        },
        result: 'host1unit1'
      },
      {
        title: 'Config value contains "_HOST" string, host name in uppercase',
        content: {
          config: {
            value: '_HOST',
            unit: 'unit1'
          },
          hostName: 'HOST1'
        },
        result: 'host1unit1'
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.getPrincipal(test.content.config, test.content.hostName)).to.equal(test.result);
      });
    });
  });

  describe('#changeDisplayName()', function() {
    it('name is HiveServer2', function() {
      expect(controller.changeDisplayName('HiveServer2')).to.equal('Hive Metastore and HiveServer2');
    });
    it('name is not HiveServer2', function() {
      expect(controller.changeDisplayName('something')).to.equal('something');
    });
  });

  describe('#getSecurityUsers()', function () {
    it('testMode is true, testModeUsers is empty', function () {
      controller.set('testModeUsers', []);
      App.testMode = true;
      expect(controller.getSecurityUsers()).to.eql([]);
    });
    it('testMode is true, testModeUsers is correct', function () {
      controller.set('testModeUsers', [
        {
          name: 'user1',
          value: 'value1'
        }
      ]);
      App.testMode = true;
      expect(controller.getSecurityUsers()).to.eql([
        {
          id: 'puppet var',
          name: 'user1',
          value: 'value1'
        }
      ]);
    });
    it('testMode is false', function () {
      sinon.stub(App.db, 'getSecureUserInfo', function () {
        return [{}];
      });
      App.testMode = false;
      expect(controller.getSecurityUsers()).to.eql([{}]);
      expect(App.db.getSecureUserInfo.calledOnce).to.be.true;
      App.db.getSecureUserInfo.restore();
    });
  });
});

});

;require.register("test/controllers/main/admin/security/add/step4_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/security/security_progress_controller');
require('controllers/main/admin/security/add/step4');
require('utils/polling');
require('models/cluster_states');
require('models/service');

describe('App.MainAdminSecurityAddStep4Controller', function () {

  var controller = App.MainAdminSecurityAddStep4Controller.create({
    content: {},
    enableSubmit: function () {
      this._super()
    },
    secureMapping: [],
    secureProperties: []
  });

  describe('#secureServices', function() {
    it('content.services is correct', function() {
      controller.set('content.services', [{}]);
      expect(controller.get('secureServices')).to.eql([{}]);
      controller.reopen({
        secureServices: []
      })
    });
  });

  describe('#isBackBtnDisabled', function() {
    it('commands have error', function() {
      controller.set('commands', [Em.Object.create({
        isError: true
      })]);
      expect(controller.get('isBackBtnDisabled')).to.be.false;
    });
    it('commands do not have error', function() {
      controller.set('commands', [Em.Object.create({
        isError: false
      })]);
      expect(controller.get('isBackBtnDisabled')).to.be.true;
    });
  });

  describe('#isSecurityApplied', function() {
    var testCases = [
      {
        title: 'No START_SERVICES command',
        commands: [],
        result: false
      },
      {
        title: 'START_SERVICES is not success',
        commands: [Em.Object.create({
          name: 'START_SERVICES',
          isSuccess: false
        })],
        result: false
      },
      {
        title: 'START_SERVICES is success',
        commands: [Em.Object.create({
          name: 'START_SERVICES',
          isSuccess: true
        })],
        result: true
      }
    ];

    testCases.forEach(function(test){
      it(test.title, function() {
        controller.set('commands', test.commands);
        expect(controller.get('isSecurityApplied')).to.equal(test.result);
      });
    });
  });

  describe('#enableSubmit()', function() {
    var mock = {
      setStepsEnable: Em.K,
      setLowerStepsDisable: Em.K
    };

    beforeEach(function () {
      sinon.stub(App.router, 'get', function () {
        return mock;
      });
      sinon.spy(mock, 'setStepsEnable');
      sinon.spy(mock, 'setLowerStepsDisable');
    });
    afterEach(function () {
      App.router.get.restore();
      mock.setStepsEnable.restore();
      mock.setLowerStepsDisable.restore();
    });

    it('Command has error', function() {
      controller.set('commands', [Em.Object.create({
        isError: true
      })]);
      controller.enableSubmit();
      expect(controller.get('isSubmitDisabled')).to.be.false;
      expect(mock.setStepsEnable.calledOnce).to.be.true;
    });
    it('Command is successful', function() {
      controller.set('commands', [Em.Object.create({
        isSuccess: true
      })]);
      controller.enableSubmit();
      expect(controller.get('isSubmitDisabled')).to.be.false;
    });
    it('Command is in progress', function() {
      controller.set('commands', [Em.Object.create()]);
      controller.enableSubmit();
      expect(controller.get('isSubmitDisabled')).to.be.true;
      expect(mock.setLowerStepsDisable.calledWith(4)).to.be.true;
    });
  });

  describe('#clearStep()', function() {
    it('Clear step info', function() {
      controller.set('commands', [Em.Object.create()]);
      controller.set('isSubmitDisabled', false);
      controller.set('serviceConfigTags', [{}]);
      controller.clearStep();
      expect(controller.get('isSubmitDisabled')).to.be.true;
      expect(controller.get('commands')).to.be.empty;
      expect(controller.get('serviceConfigTags')).to.be.empty;
    });
  });

  describe('#loadCommands()', function() {

    beforeEach(function () {
      controller.get('commands').clear();
    });

    it('No YARN in secureServices', function() {
      controller.set('secureServices', []);
      controller.loadCommands();
      expect(controller.get('commands.length')).to.equal(3);
      expect(controller.get('commands').someProperty('name', 'DELETE_ATS')).to.be.false;
    });
    it('YARN does not have APP_TIMELINE_SERVER', function() {
      sinon.stub(App.Service, 'find', function () {
        return Em.Object.create({
          hostComponents: []
        })
      });
      controller.set('secureServices', [{
        serviceName: 'YARN'
      }]);
      controller.loadCommands();
      expect(controller.get('commands.length')).to.equal(3);
      expect(controller.get('commands').someProperty('name', 'DELETE_ATS')).to.be.false;
      App.Service.find.restore();
    });
    it('YARN has APP_TIMELINE_SERVER', function() {
      sinon.stub(App.Service, 'find', function () {
        return Em.Object.create({
          hostComponents: [Em.Object.create({
            componentName: 'APP_TIMELINE_SERVER'
          })]
        })
      });
      controller.set('secureServices', [{
        serviceName: 'YARN'
      }]);
      controller.loadCommands();
      expect(controller.get('commands.length')).to.equal(4);
      expect(controller.get('commands').someProperty('name', 'DELETE_ATS')).to.be.true;
      App.Service.find.restore();
    });
  });

  describe('#loadStep()', function() {

    beforeEach(function () {
      sinon.stub(controller, 'clearStep', Em.K);
      sinon.stub(controller, 'prepareSecureConfigs', Em.K);
    });
    afterEach(function () {
      controller.clearStep.restore();
      controller.prepareSecureConfigs.restore();
      controller.resumeSavedCommands.restore();
    });

    it('Resume saved commands', function() {
      sinon.stub(controller, 'resumeSavedCommands', function(){
        return true;
      });

      controller.loadStep();
      expect(controller.clearStep.calledOnce).to.be.true;
      expect(controller.prepareSecureConfigs.calledOnce).to.be.true;
      expect(controller.resumeSavedCommands.calledOnce).to.be.true;
    });
    it('No saved commands', function() {
      sinon.stub(controller, 'resumeSavedCommands', function(){
        return false;
      });
      sinon.stub(controller, 'loadCommands', Em.K);
      sinon.stub(controller, 'addInfoToCommands', Em.K);
      sinon.stub(controller, 'syncStopServicesOperation', Em.K);
      sinon.stub(controller, 'addObserverToCommands', Em.K);
      sinon.stub(controller, 'moveToNextCommand', Em.K);

      controller.loadStep();
      expect(controller.clearStep.calledOnce).to.be.true;
      expect(controller.prepareSecureConfigs.calledOnce).to.be.true;
      expect(controller.resumeSavedCommands.calledOnce).to.be.true;

      controller.loadCommands.restore();
      controller.addInfoToCommands.restore();
      controller.syncStopServicesOperation.restore();
      controller.addObserverToCommands.restore();
      controller.moveToNextCommand.restore();
    });
  });

  describe('#syncStopServicesOperation()', function() {

    afterEach(function () {
      App.router.get.restore();
    });

    it('No running operations', function() {
      sinon.stub(App.router, 'get', function(){
        return [];
      });

      expect(controller.syncStopServicesOperation()).to.be.false;
    });
    it('Running operation is not Stop All Services', function() {
      sinon.stub(App.router, 'get', function(){
        return [Em.Object.create({isRunning: true})];
      });

      expect(controller.syncStopServicesOperation()).to.be.false;
    });
    it('No STOP_SERVICES in commands', function() {
      sinon.stub(App.router, 'get', function(){
        return [Em.Object.create({
          isRunning: true,
          name: 'Stop All Services'
        })];
      });
      controller.set('commands', []);

      expect(controller.syncStopServicesOperation()).to.be.false;
    });
    it('Sync stop services commands', function() {
      sinon.stub(App.router, 'get', function(){
        return [Em.Object.create({
          isRunning: true,
          name: 'Stop All Services',
          id: 1
        })];
      });
      controller.set('commands', [Em.Object.create({
        name: 'STOP_SERVICES'
      })]);

      expect(controller.syncStopServicesOperation()).to.be.true;
      expect(controller.get('commands').findProperty('name', 'STOP_SERVICES').get('requestId')).to.equal(1);
    });
  });

  describe('#resumeSavedCommands()', function() {

    beforeEach(function(){
      sinon.stub(controller, 'addObserverToCommands', Em.K);
      sinon.stub(controller, 'moveToNextCommand', Em.K);
      controller.set('commands', []);
    });
    afterEach(function(){
      controller.moveToNextCommand.restore();
      controller.addObserverToCommands.restore();
      App.db.getSecurityDeployCommands.restore();
    });


    it('Commands is null', function() {
      sinon.stub(App.db, 'getSecurityDeployCommands', function(){
        return null;
      });
      expect(controller.resumeSavedCommands()).to.be.false;
    });
    it('Commands is empty', function() {
      sinon.stub(App.db, 'getSecurityDeployCommands', function(){
        return [];
      });
      expect(controller.resumeSavedCommands()).to.be.false;
    });
    it('Command has error', function() {
      sinon.stub(App.db, 'getSecurityDeployCommands', function(){
        return [{
          isError: true,
          name: 'command1'
        }];
      });
      expect(controller.resumeSavedCommands()).to.be.true;
      expect(controller.get('commands').mapProperty('name')).to.eql(['command1']);
      expect(controller.addObserverToCommands.calledOnce).to.be.true;
    });
    it('Command in progress', function() {
      sinon.stub(App.db, 'getSecurityDeployCommands', function(){
        return [{
          isStarted: true,
          isCompleted: false,
          name: 'command1'
        }];
      });
      expect(controller.resumeSavedCommands()).to.be.true;
      expect(controller.get('commands').mapProperty('name')).to.eql(['command1']);
      expect(controller.get('commands').findProperty('name', 'command1').get('isStarted')).to.be.false;
      expect(controller.addObserverToCommands.calledOnce).to.be.true;
      expect(controller.moveToNextCommand.calledOnce).to.be.true;
    });
    it('Command completed', function() {
      sinon.stub(App.db, 'getSecurityDeployCommands', function(){
        return [{
          isCompleted: true,
          name: 'command1'
        }];
      });
      expect(controller.resumeSavedCommands()).to.be.true;
      expect(controller.get('commands').mapProperty('name')).to.eql(['command1']);
      expect(controller.addObserverToCommands.calledOnce).to.be.true;
      expect(controller.moveToNextCommand.calledOnce).to.be.true;
    });
  });

  describe('#loadUiSideConfigs()', function() {

    beforeEach(function(){
      sinon.stub(controller, 'getGlobConfigValue', function(arg1, arg2){
        return arg2;
      });
      sinon.stub(controller, 'checkServiceForConfigValue', function() {
        return 'value2';
      });
      sinon.stub(controller, 'setConfigValue', Em.K);
      sinon.stub(controller, 'formatConfigName', Em.K);
    });
    afterEach(function(){
      controller.getGlobConfigValue.restore();
      controller.checkServiceForConfigValue.restore();
      controller.setConfigValue.restore();
      controller.formatConfigName.restore();
    });

    it('secureMapping is empty', function() {
      controller.set('secureMapping', []);

      expect(controller.loadUiSideConfigs()).to.be.empty;
    });
    it('Config does not have dependedServiceName', function() {
      controller.set('secureMapping', [{
        name: 'config1',
        value: 'value1',
        filename: 'file1',
        foreignKey: null
      }]);

      expect(controller.loadUiSideConfigs()).to.eql([{
        "id": "site property",
        "name": 'config1',
        "value": 'value1',
        "filename": 'file1'
      }]);
    });
    it('Config has dependedServiceName', function() {
      controller.set('secureMapping', [{
        name: 'config1',
        value: 'value1',
        filename: 'file1',
        foreignKey: null,
        dependedServiceName: 'service'
      }]);

      expect(controller.loadUiSideConfigs()).to.eql([{
        "id": "site property",
        "name": 'config1',
        "value": 'value2',
        "filename": 'file1'
      }]);
    });
    it('Config has non-existent serviceName', function() {
      controller.set('secureMapping', [{
        name: 'config1',
        value: 'value1',
        filename: 'file1',
        foreignKey: true,
        serviceName: 'service'
      }]);
      sinon.stub(App.Service, 'find', function(){
        return [];
      });

      expect(controller.loadUiSideConfigs()).to.be.empty;
      App.Service.find.restore();
    });
    it('Config has correct serviceName', function() {
      controller.set('secureMapping', [{
        name: 'config1',
        value: 'value1',
        filename: 'file1',
        foreignKey: true,
        serviceName: 'HDFS'
      }]);
      sinon.stub(App.Service, 'find', function(){
        return [{serviceName: 'HDFS'}];
      });

      expect(controller.loadUiSideConfigs()).to.eql([{
        "id": "site property",
        "name": 'config1',
        "value": 'value1',
        "filename": 'file1'
      }]);
      expect(controller.setConfigValue.calledOnce).to.be.true;
      expect(controller.formatConfigName.calledOnce).to.be.true;
      App.Service.find.restore();
    });
  });

  describe('#checkServiceForConfigValue()', function() {
    it('services is empty', function() {
      var services = [];

      expect(controller.checkServiceForConfigValue('value1', services)).to.equal('value1');
    });
    it('Service is loaded', function() {
      var services = [{}];
      sinon.stub(App.Service, 'find', function () {
        return Em.Object.create({isLoaded: false});
      });

      expect(controller.checkServiceForConfigValue('value1', services)).to.equal('value1');

      App.Service.find.restore();
    });
    it('Service is not loaded', function() {
      var services = [{
        replace: 'val'
      }];
      sinon.stub(App.Service, 'find', function () {
        return Em.Object.create({isLoaded: false});
      });

      expect(controller.checkServiceForConfigValue('value1', services)).to.equal('ue1');

      App.Service.find.restore();
    });
  });

  describe('#getGlobConfigValue()', function() {
    var testCases = [
      {
        title: 'Incorrect expression',
        arguments: {
          templateName: [],
          expression: 'expression'
        },
        result: 'expression'
      },
      {
        title: 'No such property in global configs',
        arguments: {
          templateName: ['config2'],
          expression: '<[0]>'
        },
        result: null
      },
      {
        title: 'Property in global configs',
        arguments: {
          templateName: ['config1'],
          expression: '<[0]>'
        },
        result: 'value1'
      },
      {
        title: 'First property not in global configs',
        arguments: {
          templateName: ['config2','config1'],
          expression: '<[0]>@<[1]>'
        },
        result: null
      }
    ];

    testCases.forEach(function(test){
      it(test.title, function() {
        controller.set('globalProperties', [{
          name: 'config1',
          value: 'value1'
        }]);
        expect(controller.getGlobConfigValue(test.arguments.templateName, test.arguments.expression)).to.equal(test.result);
      });
    });
  });

  describe('#formatConfigName()', function() {
    it('config.value is null', function() {
      var config = {
        value: null
      };

      expect(controller.formatConfigName([], config)).to.be.false;
    });
    it('config.name does not contain foreignKey', function() {
      var config = {
        value: 'value1',
        name: 'config1'
      };

      expect(controller.formatConfigName([], config)).to.be.false;
    });
    it('globalProperties is empty, use uiConfig', function() {
      var config = {
        value: 'value1',
        name: '<foreignKey[0]>',
        foreignKey: ['key1']
      };
      controller.set('globalProperties', []);
      var uiConfig = [{
        name: 'key1',
        value: 'globalValue1'
      }];

      expect(controller.formatConfigName(uiConfig, config)).to.be.true;
      expect(config._name).to.equal('globalValue1');
    });
    it('uiConfig is empty, use globalProperties', function() {
      var config = {
        value: 'value1',
        name: '<foreignKey[0]>',
        foreignKey: ['key1']
      };
      controller.set('globalProperties', [{
        name: 'key1',
        value: 'globalValue1'
      }]);
      var uiConfig = [];

      expect(controller.formatConfigName(uiConfig, config)).to.be.true;
      expect(config._name).to.equal('globalValue1');
    });
  });

  describe('#setConfigValue()', function() {
    it('config.value is null', function() {
      var config = {
        value: null
      };

      expect(controller.setConfigValue(config)).to.be.false;
    });
    it('config.value does not match "templateName"', function() {
      var config = {
        value: ''
      };

      expect(controller.setConfigValue(config)).to.be.false;
    });
    it('No such property in global configs', function() {
      var config = {
        value: '<templateName[0]>',
        templateName: ['config1']
      };
      controller.set('globalProperties', []);

      expect(controller.setConfigValue(config)).to.be.true;
      expect(config.value).to.be.null;
    });
    it('Property in global configs', function() {
      var config = {
        value: '<templateName[0]>',
        templateName: ['config1']
      };
      controller.set('globalProperties', [{
        name: 'config1',
        value: 'value1'
      }]);

      expect(controller.setConfigValue(config)).to.be.true;
      expect(config.value).to.equal('value1');
    });
  });

  describe('#prepareSecureConfigs()', function() {

    beforeEach(function(){
      sinon.stub(controller, 'loadGlobals', Em.K);
      sinon.stub(controller, 'loadUiSideConfigs', function(){
        return [{name: 'config1'}];
      });
    });
    afterEach(function(){
      controller.loadGlobals.restore();
      controller.loadUiSideConfigs.restore();
    });

    it('content.serviceConfigProperties is empty', function() {
      controller.set('content.serviceConfigProperties', []);

      controller.prepareSecureConfigs();
      expect(controller.loadGlobals.calledOnce).to.be.true;
      expect(controller.loadUiSideConfigs.calledOnce).to.be.true;
      expect(controller.get('configs')).to.eql([{name: 'config1'}]);
    });
    it('content.serviceConfigProperties is empty', function() {
      controller.set('content.serviceConfigProperties', [{
        id: 'site property',
        name: 'config2'
      }]);

      controller.prepareSecureConfigs();
      expect(controller.loadGlobals.calledOnce).to.be.true;
      expect(controller.loadUiSideConfigs.calledOnce).to.be.true;
      expect(controller.get('configs')).to.eql([
        {
          id: 'site property',
          name: 'config2'
        },
        {name: 'config1'}
      ]);
    });
  });

  describe('#loadGlobals()', function() {

    beforeEach(function(){
      sinon.stub(controller, 'loadStaticGlobal', Em.K);
      sinon.stub(controller, 'loadUsersToGlobal', Em.K);
      sinon.stub(controller, 'loadHostNamesToGlobal', Em.K);
      sinon.stub(controller, 'loadPrimaryNamesToGlobals', Em.K);
    });
    afterEach(function(){
      controller.loadStaticGlobal.restore();
      controller.loadUsersToGlobal.restore();
      controller.loadHostNamesToGlobal.restore();
      controller.loadPrimaryNamesToGlobals.restore();
    });

    it('content.serviceConfigProperties is empty', function() {
      controller.set('content.serviceConfigProperties', []);

      controller.loadGlobals();
      expect(controller.loadStaticGlobal.calledOnce).to.be.true;
      expect(controller.loadUsersToGlobal.calledOnce).to.be.true;
      expect(controller.loadHostNamesToGlobal.calledOnce).to.be.true;
      expect(controller.loadPrimaryNamesToGlobals.calledOnce).to.be.true;
      expect(controller.get('globalProperties')).to.be.empty;
    });
    it('content.serviceConfigProperties is correct', function() {
      controller.set('content.serviceConfigProperties', [{
        id: 'puppet var',
        name: 'config1'
      }]);

      controller.loadGlobals();
      expect(controller.loadStaticGlobal.calledOnce).to.be.true;
      expect(controller.loadUsersToGlobal.calledOnce).to.be.true;
      expect(controller.loadHostNamesToGlobal.calledOnce).to.be.true;
      expect(controller.loadPrimaryNamesToGlobals.calledOnce).to.be.true;
      expect(controller.get('globalProperties')).to.eql([{
        id: 'puppet var',
        name: 'config1'
      }]);
    });
  });

  describe('#loadUsersToGlobal()', function() {

    beforeEach(function(){
      sinon.stub(controller, 'loadUsersFromServer', Em.K);
    });
    afterEach(function(){
      controller.loadUsersFromServer.restore();
      App.router.get.restore();
    });

    it('serviceUsers is empty', function() {
      sinon.stub(App.router, 'get', function(){
        return [];
      });
      controller.set('serviceUsers', []);
      controller.set('globalProperties', []);

      controller.loadUsersToGlobal();
      expect(controller.loadUsersFromServer.calledOnce).to.be.true;
      expect(controller.get('globalProperties')).to.be.empty;
    });
    it('serviceUsers is correct', function() {
      sinon.stub(App.router, 'get', function(){
        return [{name: 'user1'}];
      });
      controller.set('serviceUsers', [{}]);
      controller.set('globalProperties', []);

      controller.loadUsersToGlobal();
      expect(controller.loadUsersFromServer.called).to.be.false;
      expect(controller.get('globalProperties').mapProperty('name')).to.eql(['user1']);
    });
  });

  describe('#addHostConfig()', function() {

    afterEach(function () {
      App.Service.find.restore();
    });

    it('No such service loaded', function() {
      sinon.stub(App.Service, 'find', function(){
        return Em.Object.create({isLoaded: false});
      });

      expect(controller.addHostConfig('service1', 'comp1', 'config1')).to.be.false;
    });
    it('No such service in secureServices', function() {
      sinon.stub(App.Service, 'find', function(){
        return Em.Object.create({isLoaded: true});
      });
      controller.set('secureServices', []);

      expect(controller.addHostConfig('service1', 'comp1', 'config1')).to.be.false;
    });
    it('Service does not have such host-component', function() {
      sinon.stub(App.Service, 'find', function(){
        return Em.Object.create({
          isLoaded: true,
          hostComponents: []
        });
      });
      controller.set('secureServices', [{
        serviceName: 'service1'
      }]);

      expect(controller.addHostConfig('service1', 'comp1', 'config1')).to.be.false;
    });
    it('Push config to globalProperties', function() {
      sinon.stub(App.Service, 'find', function(){
        return Em.Object.create({
          isLoaded: true,
          hostComponents: [Em.Object.create({
            componentName: 'comp1',
            host: {hostName: 'host1'}
          })]
        });
      });
      controller.set('secureServices', [{
        serviceName: 'service1'
      }]);

      controller.set('globalProperties', []);

      expect(controller.addHostConfig('service1', 'comp1', 'config1')).to.be.true;
      expect(controller.get('globalProperties')).to.eql([{
        id: 'puppet var',
        name: 'config1',
        value: 'host1'
      }]);
    });
  });

  describe('#loadHostNamesToGlobal()', function() {

    beforeEach(function () {
      sinon.stub(controller, 'addHostConfig', Em.K);
    });
    afterEach(function () {
      controller.addHostConfig.restore();
    });

    it('componentsConfig is empty', function() {
      controller.set('componentsConfig', []);

      controller.loadHostNamesToGlobal();
      expect(controller.addHostConfig.called).to.be.false;
    });
    it('componentsConfig is correct', function() {
      controller.set('componentsConfig', [{
        serviceName: 'service1',
        componentName: 'comp1',
        configName: 'config1'
      }]);

      controller.loadHostNamesToGlobal();
      expect(controller.addHostConfig.calledWith('service1', 'comp1', 'config1')).to.be.true;
    });
  });

  describe('#loadStaticGlobal()', function() {
    it('globalProperties contains "security_enabled" property', function() {
      controller.set('globalProperties', [{
        name: 'security_enabled'
      }]);

      controller.loadStaticGlobal();
      expect(controller.get('globalProperties').findProperty('name', 'security_enabled').value).to.equal('true');
    });
  });

  describe('#loadPrimaryNamesToGlobals()', function() {

    beforeEach(function(){
      controller.set('globalProperties', []);
    });
    afterEach(function () {
      controller.getPrincipalNames.restore();
    });

    it('No principal names', function() {
      sinon.stub(controller, 'getPrincipalNames', function(){
        return [];
      });

      controller.loadPrimaryNamesToGlobals();
      expect(controller.get('globalProperties')).to.be.empty;
    });
    it('Principal name does not contain "principal"', function() {
      sinon.stub(controller, 'getPrincipalNames', function(){
        return [{
          name: 'config1',
          value: 'value2/value1'
        }];
      });

      controller.loadPrimaryNamesToGlobals();
      expect(controller.get('globalProperties')).to.eql([{name: 'config1', value: 'value2'}]);
    });
    it('Principal name contains "principal"', function() {
      sinon.stub(controller, 'getPrincipalNames', function(){
        return [{
          name: 'principal1',
          value: 'value1'
        }];
      });

      controller.loadPrimaryNamesToGlobals();
      expect(controller.get('globalProperties')).to.eql([{name: 'primary1', value: 'value1'}]);
    });
  });

  describe('#getPrincipalNames()', function() {

    beforeEach(function () {
      controller.set('globalProperties', []);
      controller.set('secureProperties', []);
    });

    it('globalProperties and secureProperties are empty', function() {
      expect(controller.getPrincipalNames()).to.be.empty;
    });
    it('global property name does not match "principal_name"', function() {
      controller.set('globalProperties', [{
        name: 'config1'
      }]);
      expect(controller.getPrincipalNames()).to.be.empty;
    });
    it('secure property name does not match "principal_name"', function() {
      controller.set('secureProperties', [{
        name: 'config1'
      }]);
      expect(controller.getPrincipalNames()).to.be.empty;
    });
    it('global property name matches "principal_name"', function() {
      controller.set('globalProperties', [{
        name: 'principal_name'
      }]);
      expect(controller.getPrincipalNames()).to.eql([{
        name: 'principal_name'
      }]);
    });
    it('property with such name already exists', function() {
      controller.set('globalProperties', [{
        name: 'principal_name'
      }]);
      controller.set('secureProperties', [{
        name: 'principal_name'
      }]);
      expect(controller.getPrincipalNames().mapProperty('name')).to.eql(['principal_name']);
    });
    it('global and secure property name matches "principal_name"', function() {
      controller.set('globalProperties', [{
        name: 'global_principal_name'
      }]);
      controller.set('secureProperties', [{
        name: 'secure_principal_name',
        defaultValue: 'value1'
      }]);
      expect(controller.getPrincipalNames().mapProperty('name')).to.eql(['global_principal_name', 'secure_principal_name']);
      expect(controller.getPrincipalNames().findProperty('name', 'secure_principal_name').value).to.equal('value1');
    });
  });

  describe('#loadUsersFromServer()', function() {
    it('testMode = true', function() {
      controller.set('testModeUsers', [{
        name: 'user1',
        value: 'value1'
      }]);
      controller.set('serviceUsers', []);
      App.testMode = true;

      controller.loadUsersFromServer();
      expect(controller.get('serviceUsers')).to.eql([{
        name: 'user1',
        value: 'value1',
        id: 'puppet var'
      }]);
    });
    it('testMode = false', function() {
      sinon.stub(App.router, 'set', Em.K);
      sinon.stub(App.db, 'getSecureUserInfo', function(){
        return [];
      });
      App.testMode = false;

      controller.loadUsersFromServer();
      expect(App.db.getSecureUserInfo.calledOnce).to.be.true;
      expect(App.router.set.calledWith('mainAdminSecurityController.serviceUsers', [])).to.be.true;

      App.router.set.restore();
      App.db.getSecureUserInfo.restore();
    });
  });

  describe('#manageSecureConfigs()', function() {

    beforeEach(function () {
      sinon.stub(controller, 'setPrincipalValue', Em.K);
    });
    afterEach(function () {
      controller.setPrincipalValue.restore();
    });

    it('serviceConfigTags is null', function() {
      sinon.stub(controller, 'onJsError', Em.K);
      controller.set('serviceConfigTags', null);
      controller.set('configs', [{id: 'site property'}]);
      controller.set('commands', [Em.Object.create({
        name: 'APPLY_CONFIGURATIONS'
      })]);

      expect(controller.manageSecureConfigs()).to.be.false;
      expect(controller.onJsError.calledOnce).to.be.true;
      expect(controller.get('commands').findProperty('name', 'APPLY_CONFIGURATIONS').get('isSuccess')).to.be.false;
      expect(controller.get('commands').findProperty('name', 'APPLY_CONFIGURATIONS').get('isError')).to.be.true;

      controller.onJsError.restore();
    });
    it('Add configs from site-*.xml', function() {
      controller.set('serviceConfigTags', [{
        siteName: 'site1',
        configs: {}
      }]);
      controller.set('configs', [{
        id: 'site property',
        name: 'config1',
        value: "value1",
        filename: 'site1.xml'
      }]);

      expect(controller.manageSecureConfigs()).to.be.true;
      expect(controller.get('serviceConfigTags')[0].configs).to.eql({'config1': 'value1'});
    });
    it('Add configs from global.xml, config matches "_hosts"', function() {
      controller.set('serviceConfigTags', [{
        siteName: 'global',
        configs: {}
      }]);
      controller.set('globalProperties', [{
        id: 'site property',
        name: 'config1_hosts',
        value: "value1",
        filename: 'site1.xml'
      }]);
      controller.set('secureConfigs', [{
        serviceName: 'service1',
        name: 'config1'
      }]);

      expect(controller.manageSecureConfigs()).to.be.true;
      expect(controller.get('serviceConfigTags')[0].configs).to.eql({});
      expect(controller.setPrincipalValue.calledWith('service1', 'config1')).to.be.true;
    });
    it('Add configs from global.xml, config does not match "_hosts"', function() {
      controller.set('serviceConfigTags', [{
        siteName: 'global',
        configs: {}
      }]);
      controller.set('globalProperties', [{
        id: 'site property',
        name: 'config1',
        value: "value1",
        filename: 'site1.xml'
      }]);
      controller.set('secureConfigs', [{
        serviceName: 'service1',
        name: 'config1'
      }]);

      expect(controller.manageSecureConfigs()).to.be.true;
      expect(controller.get('serviceConfigTags')[0].configs).to.eql({'config1': 'value1'});
      expect(controller.setPrincipalValue.calledWith('service1', 'config1')).to.be.true;
    });
  });

  describe('#setPrincipalValue()', function() {
    it('secureServices does not contain such service', function() {
      controller.set('secureServices', []);

      expect(controller.setPrincipalValue('service1', 'principal1')).to.be.false;
    });
    it('secureServices contains such service', function() {
      controller.set('secureServices', [{
        serviceName: 'service1'
      }]);
      controller.set('globalProperties', [
        {
          name: 'kerberos_domain',
          value: 'value1'
        },
        {
          name: 'principal1',
          value: 'value2'
        }
      ]);

      expect(controller.setPrincipalValue('service1', 'principal1')).to.be.true;
      expect(controller.get('globalProperties').findProperty('name', 'principal1').value).to.equal('value2@value1');
    });
  });

  describe('#deleteComponents()', function() {
    it('Send ajax', function() {
      sinon.stub(App.ajax, 'send', Em.K);

      controller.deleteComponents('comp1', 'host1');
      expect(App.ajax.send.calledOnce).to.be.true;

      App.ajax.send.restore();
    });
  });

  describe('#onDeleteComplete()', function() {
    it('', function() {
      controller.set('commands', [Em.Object.create({
        name: 'DELETE_ATS'
      })]);

      controller.onDeleteComplete();
      expect(controller.get('commands').findProperty('name', 'DELETE_ATS').get('isError')).to.be.false;
      expect(controller.get('commands').findProperty('name', 'DELETE_ATS').get('isSuccess')).to.be.true;
    });
  });

  describe('#onJsError()', function() {
    it('Show popup', function() {
      sinon.stub(App.ModalPopup, 'show', Em.K);

      controller.onJsError();
      expect(App.ModalPopup.show.calledOnce).to.be.true;

      App.ModalPopup.show.restore();
    });
  });
});

});

;require.register("test/controllers/main/admin/security/disable_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/security/disable');


describe('App.MainAdminSecurityDisableController', function () {

  var controller = App.MainAdminSecurityDisableController.create({
    serviceConfigTags: null,
    secureProperties: null,
    secureMapping: null
  });


  describe('#resumeCommands()', function () {
    var context = {
      getSecurityDeployCommands: function () {
        return this.testData;
      }
    };

    var mock = {
      setStepsEnable: Em.K,
      setLowerStepsDisable: Em.K
    };

    beforeEach(function () {
      sinon.stub(App.db, "getSecurityDeployCommands", context.getSecurityDeployCommands);
      sinon.stub(App.router, 'get', function () {
        return mock;
      });
    });
    afterEach(function () {
      App.db.getSecurityDeployCommands.restore();
      App.router.get.restore();
    });

    it('commands are absent in local storage', function () {
      App.db.testData = null;
      expect(controller.resumeCommands()).to.be.false;
    });
    it('zero commands in local storage', function () {
      App.db.testData = [];
      expect(controller.resumeCommands()).to.be.false;
    });
    it('one command is present', function () {
      App.db.testData = [
        {
          name: 'command1'
        }
      ];
      controller.get('commands').clear();
      expect(controller.resumeCommands()).to.be.true;
      expect(controller.get('commands').mapProperty('name')).to.eql(['command1']);
    });
    it('command is started and completed', function () {
      App.db.testData = [
        {
          name: 'command1',
          isStarted: true,
          isCompleted: true
        }
      ];
      controller.get('commands').clear();
      expect(controller.resumeCommands()).to.be.true;
      expect(controller.get('commands').mapProperty('name')).to.eql(['command1']);
      expect(controller.get('commands').findProperty('name', 'command1').get('isStarted')).to.be.true;
    });
    it('command is started but not completed', function () {
      App.db.testData = [
        {
          name: 'command1',
          isStarted: true,
          isCompleted: false
        }
      ];
      controller.get('commands').clear();
      expect(controller.resumeCommands()).to.be.true;
      expect(controller.get('commands').mapProperty('name')).to.eql(['command1']);
      expect(controller.get('commands').findProperty('name', 'command1').get('isStarted')).to.be.false;
    });
  });

  describe('#isSubmitDisabled', function () {
    var testCases = [
      {
        title: 'commands is empty',
        commands: [],
        result: false
      },
      {
        title: 'one started command',
        commands: [Em.Object.create({
          isStarted: true
        })],
        result: true
      },
      {
        title: 'one failed command',
        commands: [Em.Object.create({
          isError: true
        })],
        result: false
      },
      {
        title: 'one success command',
        commands: [Em.Object.create({
          isSuccess: true
        })],
        result: false
      },
      {
        title: 'not all commands are success',
        commands: [
          Em.Object.create({
            isSuccess: true
          }),
          Em.Object.create({
            isSuccess: false
          })
        ],
        result: true
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('commands', test.commands);
        expect(controller.get('isSubmitDisabled')).to.equal(test.result);
      });
    });
  });

  describe('#syncStopServicesCommand()', function () {
    App.router = Em.Object.create({
      backgroundOperationsController: Em.Object.create({
        services: []
      })
    });

    it('No background operations', function () {
      controller.set('commands', [Em.Object.create({
        name: 'STOP_SERVICES',
        requestId: 1
      })]);
      controller.syncStopServicesCommand.apply(controller);
      expect(controller.get('commands').findProperty('name', 'STOP_SERVICES').get('requestId')).to.equal(1);
    });
    it('background operation is not running', function () {
      App.router.set('backgroundOperationsController.services', [
        Em.Object.create({
          isRunning: false
        })
      ]);
      controller.syncStopServicesCommand.apply(controller);
      expect(controller.get('commands').findProperty('name', 'STOP_SERVICES').get('requestId')).to.equal(1);
    });
    it('background operation is running but not "Stop All Services"', function () {
      App.router.set('backgroundOperationsController.services', [
        Em.Object.create({
          isRunning: true
        })
      ]);
      controller.syncStopServicesCommand.apply(controller);
      expect(controller.get('commands').findProperty('name', 'STOP_SERVICES').get('requestId')).to.equal(1);
    });
    it('"Stop All Services" operation is running', function () {
      App.router.set('backgroundOperationsController.services', [
        Em.Object.create({
          name: 'Stop All Services',
          isRunning: true,
          id: 2
        })
      ]);
      controller.syncStopServicesCommand.apply(controller);
      expect(controller.get('commands').findProperty('name', 'STOP_SERVICES').get('requestId')).to.equal(2);
    });
  });

  describe('#manageSecureConfigs()', function () {

    beforeEach(function () {
      sinon.spy(controller, "deleteDisabledGlobalConfigs");
      sinon.stub(controller, "modifySiteConfigs", Em.K);
    });
    afterEach(function () {
      controller.deleteDisabledGlobalConfigs.restore();
      controller.modifySiteConfigs.restore();
    });

    var testCases = [
      {
        title: 'serviceConfigTags, secureProperties, secureMapping are null',
        content: {
          serviceConfigTags: null,
          secureProperties: null,
          secureMapping: null
        }
      },
      {
        title: 'serviceConfigTags is null',
        content: {
          serviceConfigTags: null,
          secureProperties: [],
          secureMapping: []
        }
      },
      {
        title: 'secureProperties is null',
        content: {
          serviceConfigTags: [],
          secureProperties: null,
          secureMapping: []
        }
      },
      {
        title: 'secureMapping is null',
        content: {
          serviceConfigTags: [],
          secureProperties: [],
          secureMapping: null
        }
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('commands', [Em.Object.create({
          name: 'APPLY_CONFIGURATIONS'
        })]);
        controller.set('serviceConfigTags', test.content.serviceConfigTags);
        controller.set('secureProperties', test.content.secureProperties);
        controller.set('secureMapping', test.content.secureMapping);

        expect(controller.manageSecureConfigs()).to.be.false;
        expect(controller.get('commands').findProperty('name', 'APPLY_CONFIGURATIONS').get('isSuccess')).to.be.false;
        expect(controller.get('commands').findProperty('name', 'APPLY_CONFIGURATIONS').get('isError')).to.be.true;
      });
    });
    it('serviceConfigTags is empty', function () {
      controller.set('serviceConfigTags', []);
      controller.set('secureProperties', []);
      controller.set('secureMapping', []);

      expect(controller.manageSecureConfigs()).to.be.true;
    });
    it('serviceConfigTags has global site', function () {
      controller.set('serviceConfigTags', [
        {
          siteName: 'global',
          configs: {}
        }
      ]);

      expect(controller.manageSecureConfigs()).to.be.true;
      expect(controller.deleteDisabledGlobalConfigs.calledOnce).to.be.true;
      expect(controller.get('serviceConfigTags').findProperty('siteName', 'global').configs.security_enabled).to.equal('false');
    });
    it('serviceConfigTags has site.xml', function () {
      controller.set('serviceConfigTags', [
        {
          siteName: 'site'
        }
      ]);
      expect(controller.manageSecureConfigs()).to.be.true;
      expect(controller.modifySiteConfigs.calledOnce).to.be.true;
    });
  });

  describe('#deleteDisabledGlobalConfigs()', function () {
    var testCases = [
      {
        title: '_serviceConfigTags and secureProperties are null',
        content: {
          secureProperties: null,
          _serviceConfigTags: null
        },
        result: false
      },
      {
        title: '_serviceConfigTags is null',
        content: {
          secureProperties: [],
          _serviceConfigTags: null
        },
        result: false
      },
      {
        title: 'secureProperties is null',
        content: {
          secureProperties: null,
          _serviceConfigTags: {}
        },
        result: false
      },
      {
        title: 'secureProperties and _serviceConfigTags are empty',
        content: {
          secureProperties: [],
          _serviceConfigTags: {}
        },
        result: true
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.deleteDisabledGlobalConfigs(test.content.secureProperties, test.content._serviceConfigTags)).to.equal(test.result);
      });
    });
    it('_serviceConfigTags doesn\'t contain secureProperties', function () {
      var secureProperties = [
        {name: 'config1'}
      ];
      var _serviceConfigTags = {
        configs: {
          'config2': true
        }
      };
      expect(controller.deleteDisabledGlobalConfigs(secureProperties, _serviceConfigTags)).to.be.true;
      expect(_serviceConfigTags.configs.config2).to.be.true;
    });
    it('_serviceConfigTags contains secureProperties', function () {
      var secureProperties = [
        {name: 'config1'}
      ];
      var _serviceConfigTags = {
        configs: {
          'config1': true
        }
      };
      expect(controller.deleteDisabledGlobalConfigs(secureProperties, _serviceConfigTags)).to.be.true;
      expect(_serviceConfigTags.configs.config1).to.be.undefined;
    });
  });

  describe('#modifySiteConfigs()', function () {
    var testCases = [
      {
        title: '_serviceConfigTags and secureMapping are null',
        content: {
          secureMapping: null,
          _serviceConfigTags: null
        },
        result: false
      },
      {
        title: '_serviceConfigTags is null',
        content: {
          secureMapping: [],
          _serviceConfigTags: null
        },
        result: false
      },
      {
        title: 'secureMapping is null',
        content: {
          secureMapping: null,
          _serviceConfigTags: {}
        },
        result: false
      },
      {
        title: 'secureMapping and _serviceConfigTags are empty',
        content: {
          secureMapping: [],
          _serviceConfigTags: {
            configs: {}
          }
        },
        result: true
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.modifySiteConfigs(test.content.secureMapping, test.content._serviceConfigTags)).to.equal(test.result);
      });
    });
    it('secureMapping doesn\'t contain passed siteName', function () {
      var secureMapping = [];
      var _serviceConfigTags = {
        configs: {
          'config2': true
        },
        siteName: 'site1'
      };
      expect(controller.modifySiteConfigs(secureMapping, _serviceConfigTags)).to.be.true;
      expect(_serviceConfigTags.configs.config2).to.be.true;
    });
    it('secureMapping contain passed siteName but doesn\'t match config name', function () {
      var secureMapping = [
        {
          filename: 'site1.xml'
        }
      ];
      var _serviceConfigTags = {
        configs: {
          'config2': true
        },
        siteName: 'site1'
      };
      expect(controller.modifySiteConfigs(secureMapping, _serviceConfigTags)).to.be.true;
      expect(_serviceConfigTags.configs.config2).to.be.true;
    });
    it('secureMapping contain passed siteName and match config name', function () {
      var secureMapping = [
        {
          filename: 'site1.xml',
          name: 'config2'
        }
      ];
      var _serviceConfigTags = {
        configs: {
          'config2': true
        },
        siteName: 'site1'
      };
      expect(controller.modifySiteConfigs(secureMapping, _serviceConfigTags)).to.be.true;
      expect(_serviceConfigTags.configs.config2).to.be.undefined;
    });
    it('secureMapping contain passed siteName and included in secureConfigValuesMap', function () {
      var secureMapping = [
        {
          filename: 'site1.xml',
          name: 'config2',
          nonSecureValue: 'nonSecureValue'
        }
      ];
      var _serviceConfigTags = {
        configs: {
          'config2': true
        },
        siteName: 'site1'
      };
      controller.set('secureConfigValuesMap', {
        'config2': 'value'
      });
      expect(controller.modifySiteConfigs(secureMapping, _serviceConfigTags)).to.be.true;
      expect(_serviceConfigTags.configs.config2).to.equal('nonSecureValue');
    });
  });
});

});

;require.register("test/controllers/main/admin/security/security_progress_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/security/security_progress_controller');
require('models/host_component');
require('models/host');

describe('App.MainAdminSecurityProgressController', function () {

  var controller = App.MainAdminSecurityProgressController.create({
    loadClusterConfigs: function () {},
    deleteComponents: function () {}
  });

  describe('#retry()', function () {

    beforeEach(function () {
      sinon.spy(controller, "startCommand");
    });
    afterEach(function () {
      controller.startCommand.restore();
    });

    it('commands are empty', function () {
      controller.set('commands', []);
      controller.retry();
      expect(controller.startCommand.called).to.be.false;
    });

    it('command is successful', function () {
      controller.set('commands', [
        Em.Object.create({
          name: 'test',
          isSuccess: true,
          isError: false,
          isStarted: true
        })
      ]);
      controller.retry();
      expect(controller.startCommand.calledOnce).to.be.false;
      expect(controller.get('commands').findProperty('name', 'test').get('isError')).to.be.false;
      expect(controller.get('commands').findProperty('name', 'test').get('isStarted')).to.be.true;
    });

    it('command is failed', function () {
      controller.set('commands', [
        Em.Object.create({
          name: 'test',
          isSuccess: true,
          isError: true,
          isStarted: true
        })
      ]);
      controller.retry();
      expect(controller.startCommand.calledOnce).to.be.true;
      expect(controller.get('commands').findProperty('name', 'test').get('isError')).to.be.false;
      expect(controller.get('commands').findProperty('name', 'test').get('isStarted')).to.be.false;
    });
  });

  describe('#updateServices()', function () {

    it('commands are empty', function () {
      controller.set('services', [
        {}
      ]);
      controller.set('commands', []);
      controller.updateServices();
      expect(controller.get('services')).to.be.empty;
    });

    it('command doesn\'t have polledData', function () {
      controller.set('services', [
        {}
      ]);
      controller.set('commands', [Em.Object.create({
        label: 'label'
      })]);
      controller.updateServices();
      expect(controller.get('services')).to.be.empty;
    });

    it('command has polledData', function () {
      controller.set('services', [
        {}
      ]);
      controller.set('commands', [Em.Object.create({
        label: 'service1',
        polledData: [
          {
            Tasks: {
              host_name: 'host1'
            }
          }
        ]
      })]);
      controller.updateServices();
      expect(controller.get('services').findProperty('name', 'service1').get('hosts')).to.eql([
        {
          name: 'host1',
          publicName: 'host1',
          logTasks: [
            {
              Tasks: {host_name: 'host1'}
            }
          ]
        }
      ]);
    });
  });

  describe('#setIndex()', function () {
    it('commandArray is empty', function () {
      var commandArray = [];
      controller.setIndex(commandArray);
      expect(commandArray).to.be.empty;
      expect(controller.get('totalSteps')).to.equal(0);
    });
    it('one command in commandArray', function () {
      var commandArray = [
        Em.Object.create({name: 'command1'})
      ];
      controller.setIndex(commandArray);
      expect(commandArray[0].get('index')).to.equal(1);
      expect(controller.get('totalSteps')).to.equal(1);
    });
    it('commands with random indexes', function () {
      var commandArray = [];
      commandArray[3] = Em.Object.create({name: 'command3'});
      commandArray[11] = Em.Object.create({name: 'command11'});
      controller.setIndex(commandArray);
      expect(commandArray[3].get('index')).to.equal(4);
      expect(commandArray[11].get('index')).to.equal(12);
      expect(controller.get('totalSteps')).to.equal(12);
    });
  });

  describe('#startCommand()', function () {

    var command = Em.Object.create({
      start: function () {
      }
    });
    beforeEach(function () {
      sinon.spy(command, "start");
      sinon.spy(controller, "loadClusterConfigs");
      sinon.spy(controller, "deleteComponents");
    });
    afterEach(function () {
      command.start.restore();
      controller.loadClusterConfigs.restore();
      controller.deleteComponents.restore();
    });

    it('number of commands doesn\'t match totalSteps', function () {
      controller.set('commands', []);
      controller.set('totalSteps', 1);
      expect(controller.startCommand()).to.be.false;
    });
    it('commands is empty', function () {
      controller.set('commands', []);
      controller.set('totalSteps', 0);
      expect(controller.startCommand()).to.be.false;
    });
    it('command is started and completed', function () {
      controller.set('commands', [Em.Object.create({
        isStarted: true,
        isCompleted: true
      })]);
      controller.set('totalSteps', 1);
      expect(controller.startCommand()).to.be.false;
    });
    it('command is started and incompleted', function () {
      controller.set('commands', [Em.Object.create({
        isStarted: true,
        isCompleted: false
      })]);
      controller.set('totalSteps', 1);
      expect(controller.startCommand()).to.be.true;
    });
    it('command parameter passed, isPolling is true', function () {
      controller.set('commands', []);
      controller.set('totalSteps', 0);
      command.set('isPolling', true);
      expect(controller.startCommand(command)).to.be.true;
      expect(command.get('isStarted')).to.be.true;
      expect(command.start.calledOnce).to.be.true;
      command.set('isPolling', false);
    });
    it('command parameter passed, name is "APPLY_CONFIGURATIONS"', function () {
      command.set('name', 'APPLY_CONFIGURATIONS');
      expect(controller.startCommand(command)).to.be.true;
      expect(command.get('isStarted')).to.be.true;
      expect(controller.loadClusterConfigs.calledOnce).to.be.true;
    });
    it('command parameter passed, name is "APPLY_CONFIGURATIONS", testMode = true', function () {
      App.testMode = true;
      expect(controller.startCommand(command)).to.be.true;
      expect(command.get('isStarted')).to.be.true;
      expect(command.get('isError')).to.be.false;
      expect(command.get('isSuccess')).to.be.true;
      expect(controller.loadClusterConfigs.called).to.be.false;
      App.testMode = false;
    });
    it('command parameter passed, name is "DELETE_ATS"', function () {
      command.set('name', 'DELETE_ATS');
      App.store.load(App.HostComponent, {
        id: 'APP_TIMELINE_SERVER_ats_host',
        component_name: 'APP_TIMELINE_SERVER',
        host_id: 'ats_host'
      });
      App.store.load(App.Host, {
        id: 'ats_host',
        host_name: 'ats_host',
        host_components: ['APP_TIMELINE_SERVER_ats_host']
      });
      expect(controller.startCommand(command)).to.be.true;
      expect(command.get('isStarted')).to.be.true;
      expect(controller.deleteComponents.calledWith('APP_TIMELINE_SERVER', 'ats_host')).to.be.true;
    });
    it('command parameter passed, name is "DELETE_ATS", testMode = true', function () {
      App.testMode = true;
      expect(controller.startCommand(command)).to.be.true;
      expect(command.get('isStarted')).to.be.true;
      expect(command.get('isError')).to.be.false;
      expect(command.get('isSuccess')).to.be.true;
      expect(controller.deleteComponents.called).to.be.false;
      App.testMode = false;
    });
  });

  describe('#onCompleteCommand()', function () {

    beforeEach(function () {
      sinon.spy(controller, "moveToNextCommand");
    });
    afterEach(function () {
      controller.moveToNextCommand.restore();
    });

    it('number of commands doesn\'t match totalSteps', function () {
      controller.set('commands', []);
      controller.set('totalSteps', 1);
      expect(controller.onCompleteCommand()).to.be.false;
    });
    it('No successful commands', function () {
      controller.set('commands', [Em.Object.create({
        isSuccess: false
      })]);
      controller.set('totalSteps', 1);
      expect(controller.onCompleteCommand()).to.be.false;
    });
    it('No successful commands', function () {
      controller.set('commands', [Em.Object.create({
        isSuccess: false
      })]);
      controller.set('totalSteps', 1);
      expect(controller.onCompleteCommand()).to.be.false;
    });
    it('Last command is successful', function () {
      controller.set('commands', [
        Em.Object.create({
          isSuccess: false
        }),
        Em.Object.create({
          isSuccess: true
        })
      ]);
      controller.set('totalSteps', 2);
      expect(controller.onCompleteCommand()).to.be.false;
    });
    it('all commands are successful', function () {
      controller.set('commands', [
        Em.Object.create({
          isSuccess: true,
          name: 'command1'
        }),
        Em.Object.create({
          isSuccess: false,
          name: 'command2'
        })
      ]);
      controller.set('totalSteps', 2);
      expect(controller.onCompleteCommand()).to.be.true;
      expect(controller.moveToNextCommand.calledWith(Em.Object.create({
        isSuccess: false,
        name: 'command2'
      }))).to.be.true;
    });
  });

  describe('#moveToNextCommand()', function () {

    beforeEach(function () {
      sinon.spy(controller, "startCommand");
    });
    afterEach(function () {
      controller.startCommand.restore();
    });

    it('No commands present', function () {
      controller.set('commands', []);
      expect(controller.moveToNextCommand()).to.be.false;
    });
    it('Only started command present', function () {
      controller.set('commands', [
        Em.Object.create({
          isStarted: true
        })
      ]);
      expect(controller.moveToNextCommand()).to.be.false;
    });
    it('Command is not started', function () {
      controller.set('commands', [
        Em.Object.create({
          isStarted: false,
          name: 'command1'
        })
      ]);
      expect(controller.moveToNextCommand()).to.be.true;
      expect(controller.startCommand.calledWith(Em.Object.create({
        isStarted: false,
        name: 'command1'
      }))).to.be.true;
    });
    it('Next command provide as argument', function () {
      var nextCommand = Em.Object.create({
        isStarted: false,
        name: 'command2'
      });
      expect(controller.moveToNextCommand(nextCommand)).to.be.true;
      expect(controller.startCommand.calledWith(Em.Object.create({
        isStarted: false,
        name: 'command2'
      }))).to.be.true;
    });
  });

  describe('#setServiceTagNames()', function () {
    var testCases = [
      {
        title: 'configs is empty object',
        content: {
          secureService: {},
          configs: {}
        },
        result: undefined
      },
      {
        title: 'secureService.sites is null',
        content: {
          secureService: {
            sites: null
          },
          configs: {
            site1: {}
          }
        },
        result: undefined
      },
      {
        title: 'secureService.sites doesn\'t contain required config tag',
        content: {
          secureService: {
            sites: []
          },
          configs: {
            site1: {}
          }
        },
        result: undefined
      },
      {
        title: 'secureService.sites contains required config tag',
        content: {
          secureService: {
            sites: ['site1']
          },
          configs: {
            site1: {
              tag: 'tag1'
            }
          }
        },
        result: {
          siteName: 'site1',
          tagName: 'tag1',
          newTagName: null,
          configs: {}
        }
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.setServiceTagNames(test.content.secureService, test.content.configs)).to.eql(test.result);
      });
    });
  });

  describe('#setServerConfigValue()', function () {

    beforeEach(function () {
      sinon.spy(App.config, "escapeXMLCharacters");
    });
    afterEach(function () {
      App.config.escapeXMLCharacters.restore();
    });

    it('Empty config', function () {
      expect(controller.setServerConfigValue('', '')).to.equal('');
      expect(App.config.escapeXMLCharacters.calledWith('')).to.be.true;
    });
    it('Config1, value = "value1"', function () {
      expect(controller.setServerConfigValue('config1', 'value1')).to.equal('value1');
      expect(App.config.escapeXMLCharacters.calledWith('value1')).to.be.true;
    });
    it('config = "storm.zookeeper.servers", value = "value1"', function () {
      expect(controller.setServerConfigValue('storm.zookeeper.servers', 'value1')).to.equal('value1');
      expect(App.config.escapeXMLCharacters.called).to.be.false;
    });
  });

  describe('#escapeXMLCharacters()', function () {

    beforeEach(function () {
      sinon.spy(controller, "setServerConfigValue");
    });
    afterEach(function () {
      controller.setServerConfigValue.restore();
    });

    it('serviceConfigTags is empty', function () {
      var serviceConfigTags = [];
      controller.escapeXMLCharacters(serviceConfigTags);
      expect(controller.setServerConfigValue.called).to.be.false;
    });
    it('configs is empty', function () {
      var serviceConfigTags = [
        {
          configs: {}
        }
      ];
      controller.escapeXMLCharacters(serviceConfigTags);
      expect(controller.setServerConfigValue.called).to.be.false;
    });
    it('serviceConfigTags has property', function () {
      var serviceConfigTags = [
        {
          configs: {
            'p1': 'value1'
          }
        }
      ];
      controller.escapeXMLCharacters(serviceConfigTags);
      expect(controller.setServerConfigValue.withArgs('p1', 'value1').calledOnce).to.be.true;
    });
    it('serviceConfigTags has multiple properties', function () {
      var serviceConfigTags = [
        {
          configs: {
            'p1': 'value1',
            'p2': 'value2'
          }
        }
      ];
      controller.escapeXMLCharacters(serviceConfigTags);
      expect(controller.setServerConfigValue.callCount).to.equal(2);
    });
  });
});

});

;require.register("test/controllers/main/admin/security_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/security');


describe('App.MainAdminSecurityController', function () {

  var controller = App.MainAdminSecurityController.create({
    getServiceConfigsFromServer: function () {
    }
  });

  describe('#setServiceTagNames()', function () {
    var testCases = [
      {
        title: 'configs is empty object',
        content: {
          secureService: {},
          configs: {}
        },
        result: undefined
      },
      {
        title: 'secureService.sites is null',
        content: {
          secureService: {
            sites: null
          },
          configs: {
            site1: {}
          }
        },
        result: undefined
      },
      {
        title: 'secureService.sites doesn\'t contain required config tag',
        content: {
          secureService: {
            sites: []
          },
          configs: {
            site1: {}
          }
        },
        result: undefined
      },
      {
        title: 'secureService.sites contains required config tag',
        content: {
          secureService: {
            sites: ['site1']
          },
          configs: {
            site1: {
              tag: 'tag1'
            }
          }
        },
        result: {
          siteName: 'site1',
          tagName: 'tag1',
          newTagName: null,
          configs: {}
        }
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.setServiceTagNames(test.content.secureService, test.content.configs)).to.eql(test.result);
      });
    });
  });

  describe('#getSecurityStatusFromServerSuccessCallback()', function () {

    beforeEach(function () {
      sinon.spy(controller, 'showSecurityErrorPopup');
      sinon.spy(controller, 'getServiceConfigsFromServer');
    });
    afterEach(function () {
      controller.showSecurityErrorPopup.restore();
      controller.getServiceConfigsFromServer.restore();
    });

    it('desired_configs is empty', function () {
      var data = {Clusters: {
        desired_configs: {}
      }};
      controller.getSecurityStatusFromServerSuccessCallback(data);
      expect(controller.showSecurityErrorPopup.called).to.equal(true);
    });

    it('hdfs-site is missing', function () {
      var data = {Clusters: {
        desired_configs: {
          'global': {}
        }
      }};
      controller.getSecurityStatusFromServerSuccessCallback(data);
      expect(controller.showSecurityErrorPopup.called).to.equal(true);
    });

    it('global is missing', function () {
      var data = {Clusters: {
        desired_configs: {
          'hdfs-site': {}
        }
      }};
      controller.getSecurityStatusFromServerSuccessCallback(data);
      expect(controller.showSecurityErrorPopup.called).to.equal(true);
    });

    it('global and hdfs-site are correct', function () {
      var data = {Clusters: {
        desired_configs: {
          'hdfs-site': {
            tag: 1
          },
          'global': {
            tag: 2
          }
        }
      }};
      controller.getSecurityStatusFromServerSuccessCallback(data);
      expect(controller.get('tag.global')).to.equal(2);
      expect(controller.get('tag.hdfs-site')).to.equal(1);
      expect(controller.getServiceConfigsFromServer.called).to.equal(true);
    });
  });


  describe('#setNnHaStatus()', function () {

    beforeEach(function () {
      sinon.stub(App.db, "setIsNameNodeHa", Em.K);
    });
    afterEach(function () {
      App.db.setIsNameNodeHa.restore();
    });


    it('hdfsConfigs is null', function () {
      var hdfsConfigs = null;
      controller.setNnHaStatus(hdfsConfigs);
      expect(App.db.setIsNameNodeHa.withArgs('false').called).to.equal(true);
    });

    it('"dfs.nameservices" is absent in hdfsConfigs', function () {
      var hdfsConfigs = {};
      controller.setNnHaStatus(hdfsConfigs);
      expect(App.db.setIsNameNodeHa.withArgs('false').called).to.equal(true);
    });

    it('namenodesKey is absent in hdfsConfigs', function () {
      var hdfsConfigs = {
        'dfs.nameservices': 'key'
      };
      controller.setNnHaStatus(hdfsConfigs);
      expect(App.db.setIsNameNodeHa.withArgs('false').called).to.equal(true);
    });

    it('namenodesKey is present in hdfsConfigs', function () {
      var hdfsConfigs = {
        'dfs.nameservices': 'key',
        'dfs.ha.namenodes.key': 'true'
      };
      controller.setNnHaStatus(hdfsConfigs);
      expect(App.db.setIsNameNodeHa.withArgs('true').called).to.equal(true);
    });
  });

  describe('#loadUsers()', function () {

    beforeEach(function () {
      sinon.stub(App.db, "setSecureUserInfo", Em.K);
    });
    afterEach(function () {
      App.db.setSecureUserInfo.restore();
    });

    it('if defaultUserNameMap is empty then serviceUsers stays the same', function () {
      var configs = {};
      controller.set('serviceUsers', []);
      controller.set('defaultUserNameMap', {});
      controller.loadUsers(configs);
      expect(controller.get('serviceUsers')).to.be.empty;
    });

    it('if user config value is missing then use default', function () {
      var configs = {};
      controller.set('serviceUsers', []);
      controller.set('defaultUserNameMap', {
        'test_user': 'test'
      });
      controller.loadUsers(configs);
      expect(controller.get('serviceUsers')).to.eql([
        {
          "id": "puppet var",
          "name": "test_user",
          "value": "test"
        }
      ]);
    });

    it('user config value has value', function () {
      var configs = {
        'test_user': 'config-value'
      };
      controller.set('serviceUsers', []);
      controller.set('defaultUserNameMap', {
        'test_user': 'test'
      });
      controller.loadUsers(configs);
      expect(controller.get('serviceUsers')).to.eql([
        {
          "id": "puppet var",
          "name": "test_user",
          "value": "config-value"
        }
      ]);
    });
  });
});
});

;require.register("test/controllers/main/admin_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('models/service');
require('models/host_component');
require('controllers/main/admin');

describe('MainAdminController', function () {

  var controller = App.MainAdminController.create();

  describe('#isAccessAvailable()', function () {

    beforeEach(function () {
      Em.propertyDidChange(controller, 'isAccessAvailable');
    });

    it('Services do not match dependencies', function () {
      App.Service.find().clear();
      App.store.load(App.Service, {
        id: 'HDFS',
        service_name: 'HDFS'
      });
      expect(controller.get("isAccessAvailable")).to.be.false;
    });
    it('APP_TIMELINE_SERVER is absent', function () {
      App.Service.find().clear();
      App.HostComponent.find().clear();
      expect(controller.get("isAccessAvailable")).to.be.false;
    });
    it('Only one YARN service installed', function () {
      App.store.load(App.Service, {
        id: 'YARN',
        service_name: 'YARN'
      });
      expect(controller.get("isAccessAvailable")).to.be.false;
    });
    it('TEZ and YARN services installed', function () {
      App.store.load(App.Service, {
        id: 'TEZ',
        service_name: 'TEZ'
      });
      expect(controller.get("isAccessAvailable")).to.be.false;
    });
    it('TEZ and YARN services, APP_TIMELINE_SERVER component installed', function () {
      App.store.load(App.HostComponent, {
        id: 'APP_TIMELINE_SERVER_host1',
        component_name: 'APP_TIMELINE_SERVER'
      });
      expect(controller.get("isAccessAvailable")).to.be.true;
    });
  });
});

});

;require.register("test/controllers/main/alerts_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('controllers/main/alerts_controller');
require('models/alert');

describe('MainAlertsController', function () {

  var controller = App.MainAlertsController.create();

  describe('#loadAlerts()', function () {

    before(function () {
      sinon.stub(controller, 'getFromServer', Em.K);
    });
    after(function () {
      controller.getFromServer.restore();
    });

    it('getFromServer should be called', function () {
      controller.set('resourceName', null);
      controller.set('isLoaded', true);
      controller.set('resourceType', null);
      controller.loadAlerts('name1', 'type1');
      expect(controller.get("isLoaded")).to.be.false;
      expect(controller.get("resourceName")).to.equal('name1');
      expect(controller.get("resourceType")).to.equal('type1');
      expect(controller.getFromServer.calledOnce).to.be.true;
    });
  });

  describe('#update()', function () {

    var clock;

    beforeEach(function () {
      clock = sinon.useFakeTimers();
      sinon.stub(controller, 'getFromServer', Em.K);
      sinon.spy(controller, 'update');
    });
    afterEach(function () {
      clock.restore();
      controller.getFromServer.restore();
      controller.update.restore();
    });

    it('isUpdating = true', function () {
      controller.set('isUpdating', true);
      expect(controller.get("updateTimer")).not.to.be.null;
      clock.tick(App.componentsUpdateInterval);
      expect(controller.getFromServer.calledOnce).to.be.true;
      expect(controller.update.calledTwice).to.be.true;
    });
    it('isUpdating = false', function () {
      controller.set('isUpdating', false);
      expect(controller.update.calledOnce).to.be.true;
    });
  });

  describe('#getFromServer()', function () {
    var obj = Em.Object.create({isNagiosInstalled: false});

    beforeEach(function () {
      sinon.stub(controller, 'getAlertsByService', Em.K);
      sinon.stub(controller, 'getAlertsByHost', Em.K);
      sinon.stub(App.router, 'get', function() {return obj.get('isNagiosInstalled')});
    });
    afterEach(function () {
      controller.getAlertsByService.restore();
      controller.getAlertsByHost.restore();
      App.router.get.restore();
    });

    it('Nagios is not installed', function () {
      obj.set('isNagiosInstalled', false);
      controller.set('isLoaded', false);
      controller.getFromServer();
      expect(controller.get('isLoaded')).to.be.true;
      controller.set('isLoaded', false);
    });
    it('Nagios installed, SERVICE resource type', function () {
      obj.set('isNagiosInstalled', true);
      controller.set('resourceType', 'SERVICE');
      controller.getFromServer();
      expect(controller.get('isLoaded')).to.be.false;
      expect(controller.getAlertsByService.calledOnce).to.be.true;
    });
    it('Nagios installed, HOST resource type', function () {
      obj.set('isNagiosInstalled', true);
      controller.set('resourceType', 'HOST');
      controller.getFromServer();
      expect(controller.get('isLoaded')).to.be.false;
      expect(controller.getAlertsByHost.calledOnce).to.be.true;
    });
    it('Nagios installed, unknown resource type', function () {
      obj.set('isNagiosInstalled', true);
      controller.set('resourceType', 'RS1');
      controller.getFromServer();
      expect(controller.get('isLoaded')).to.be.false;
      expect(controller.getAlertsByService.called).to.be.false;
      expect(controller.getAlertsByHost.called).to.be.false;
    });
  });

  describe('#getAlertsByHost()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('resourceName is null', function () {
      controller.set('resourceName', null);
      expect(controller.getAlertsByHost()).to.be.false;
      expect(App.ajax.send.called).to.be.false;
    });
    it('resourceName is correct', function () {
      controller.set('resourceName', 'host1');
      expect(controller.getAlertsByHost()).to.be.true;
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#getAlertsByService()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('resourceName is null', function () {
      controller.set('resourceName', null);
      expect(controller.getAlertsByService()).to.be.false;
      expect(App.ajax.send.called).to.be.false;
    });
    it('resourceName is correct', function () {
      controller.set('resourceName', 'service1');
      expect(controller.getAlertsByService()).to.be.true;
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#getAlertsSuccessCallback()', function () {

    var testCases = [
      {
        title: 'data is null',
        data: null,
        result: []
      },
      {
        title: 'data.alerts is null',
        data: {alerts: null},
        result: []
      },
      {
        title: 'data.alerts.detail is null',
        data: {alerts: {detail: null}},
        result: []
      },
      {
        title: 'data.alerts.detail is empty',
        data: {alerts: {detail: []}},
        result: []
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('isLoaded', false);
        controller.getAlertsSuccessCallback(test.data);
        expect(controller.get('alerts')).to.eql(test.result);
        expect(controller.get('isLoaded')).to.be.true;
      });
    });

    var data = {alerts: {detail: [
      {
        description: 't1',
        service_name: "s1",
        status_time: 1,
        status: 'OK',
        output: 'o1',
        host_name: 'h1',
        last_status_time: 1
      }
    ]}};
    var testCasesOfStatus = [
      {
        title: 'data.alerts.detail is correct, OK status',
        status: 'OK',
        result: '0'
      },
      {
        title: 'data.alerts.detail is correct, WARNING status',
        status: 'WARNING',
        result: '1'
      },
      {
        title: 'data.alerts.detail is correct, CRITICAL status',
        status: 'CRITICAL',
        result: '2'
      },
      {
        title: 'data.alerts.detail is correct, PASSIVE status',
        status: 'PASSIVE',
        result: '3'
      },
      {
        title: 'data.alerts.detail is correct, unknown status',
        status: '',
        result: '4'
      }
    ];
    testCasesOfStatus.forEach(function (test) {
      it(test.title, function () {
        controller.set('isLoaded', false);
        data.alerts.detail[0].status = test.status;
        controller.getAlertsSuccessCallback(data);
        expect(controller.get('alerts.length')).to.equal(1);
        expect(controller.get('alerts').objectAt(0).get('status')).to.equal(test.result);
        expect(controller.get('isLoaded')).to.be.true;
      });
    });
  });

  describe('#getAlertsErrorCallback()', function () {
    it('isLoaded was false', function () {
      controller.set('isLoaded', false);
      controller.getAlertsErrorCallback();
      expect(controller.get('isLoaded')).to.be.true;
    });
    it('isLoaded was true', function () {
      controller.set('isLoaded', true);
      controller.getAlertsErrorCallback();
      expect(controller.get('isLoaded')).to.be.true;
    });
  });
});
});

;require.register("test/controllers/main/app_contoller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('utils/helper');
require('controllers/main/apps_controller');

describe('MainAppsController', function () {


   describe('#iTotalDisplayRecordsObserver()', function () {
     it('should set number of filtered jobs when switching to all jobs', function () {
       var mainAppsController = App.MainAppsController.create();
       mainAppsController.set("paginationObject.iTotalDisplayRecords", 5);
       expect(mainAppsController.get('filterObject.filteredDisplayRecords')).to.equal(5);
     })
   });


   describe('#filterObject.onRunTypeChange()', function () {
     it('should set sSearch_2 of filterObject when changing value of filterObject.runType', function () {
       var mainAppsController = App.MainAppsController.create();
       mainAppsController.set("filterObject.runType", "MapReduce");
       expect(mainAppsController.get('filterObject.sSearch_2')).to.equal("mr");
       mainAppsController.set("filterObject.runType", "Hive");
       expect(mainAppsController.get('filterObject.sSearch_2')).to.equal("hive");
       mainAppsController.set("filterObject.runType", "Pig");
       expect(mainAppsController.get('filterObject.sSearch_2')).to.equal("pig");
     })
   });

   describe('#filterObject.onJobsChange()', function () {
     it('should set minJobs,maxJobs of filterObject when changing value of filterObject.jobs', function () {
       var mainAppsController = App.MainAppsController.create();
       mainAppsController.set("filterObject.jobs", ">3");
       expect(mainAppsController.get('filterObject.minJobs')).to.equal("3");
       expect(mainAppsController.get('filterObject.maxJobs')).to.equal("");
       mainAppsController.set("filterObject.jobs", "<3");
       expect(mainAppsController.get('filterObject.minJobs')).to.equal("");
       expect(mainAppsController.get('filterObject.maxJobs')).to.equal("3");
       mainAppsController.set("filterObject.jobs", "3");
       expect(mainAppsController.get('filterObject.minJobs')).to.equal("3");
       expect(mainAppsController.get('filterObject.maxJobs')).to.equal("3");
       mainAppsController.set("filterObject.jobs", "=3");
       expect(mainAppsController.get('filterObject.minJobs')).to.equal("3");
       expect(mainAppsController.get('filterObject.maxJobs')).to.equal("3");
     })
   });

   describe('#filterObject.onDurationChange()', function () {
     it('should set minDuration,maxDuration of filterObject when changing value of filterObject.duration', function () {
       var mainAppsController = App.MainAppsController.create();
       mainAppsController.set("filterObject.duration", ">3h");
       expect(mainAppsController.get('filterObject.minDuration')).to.equal(10799640);
       expect(mainAppsController.get('filterObject.maxDuration')).to.equal("");
       mainAppsController.set("filterObject.duration", "<6m");
       expect(mainAppsController.get('filterObject.minDuration')).to.equal("");
       expect(mainAppsController.get('filterObject.maxDuration')).to.equal(360060);
       mainAppsController.set("filterObject.duration", "10s");
       expect(mainAppsController.get('filterObject.minDuration')).to.equal(9990);
       expect(mainAppsController.get('filterObject.maxDuration')).to.equal(10010);
       mainAppsController.set("filterObject.duration", "1");
       expect(mainAppsController.get('filterObject.minDuration')).to.equal(990);
       expect(mainAppsController.get('filterObject.maxDuration')).to.equal(1010);
     })
   });

   describe('#filterObject.onRunDateChange()', function () {
     it('should set minStartTime,maxStartTime of filterObject when changing value of filterObject.runDate', function () {
       var mainAppsController = App.MainAppsController.create();
       mainAppsController.set("filterObject.runDate", "Any");
       expect(mainAppsController.get('filterObject.minStartTime')).to.equal("");
       mainAppsController.set("filterObject.runDate", "Past 1 Day");
       expect(mainAppsController.get('filterObject.minStartTime')).to.be.within(((new Date().getTime())-86400000)-1000,((new Date().getTime())-86400000)+1000);
       mainAppsController.set("filterObject.runDate", "Past 2 Days");
       expect(mainAppsController.get('filterObject.minStartTime')).to.be.within(((new Date().getTime())-172800000)-1000,((new Date().getTime())-172800000)+1000);
       mainAppsController.set("filterObject.runDate", "Past 7 Days");
       expect(mainAppsController.get('filterObject.minStartTime')).to.be.within(((new Date().getTime())-604800000)-1000,((new Date().getTime())-604800000)+1000);
       mainAppsController.set("filterObject.runDate", "Past 14 Days");
       expect(mainAppsController.get('filterObject.minStartTime')).to.be.within(((new Date().getTime())-1209600000)-1000,((new Date().getTime())-1209600000)+1000);
       mainAppsController.set("filterObject.runDate", "Past 30 Days");
       expect(mainAppsController.get('filterObject.minStartTime')).to.be.within(((new Date().getTime())-2592000000)-1000,((new Date().getTime())-2592000000)+1000);
     })
   });

   describe('#filterObject.createAppLink(), #filterObject.valueObserver()', function () {
     var mainAppsController = App.MainAppsController.create();
     mainAppsController.set('content.length', 20);
     it('should set runUrl of filterObject when changing value for any filter', function () {
       mainAppsController.set("filterObject.sSearch_0", "0");
       mainAppsController.set("filterObject.sSearch_1", "workflowName");
       mainAppsController.set("filterObject.sSearch_2", "pig");
       mainAppsController.set("filterObject.sSearch_3", "admin");
       mainAppsController.set("filterObject.minJobs", "1");
       mainAppsController.set("filterObject.maxJobs", "2");
       mainAppsController.set("filterObject.minDuration", "1000");
       mainAppsController.set("filterObject.maxDuration", "2000");
       mainAppsController.set("filterObject.minStartTime", "999");
       mainAppsController.set("filterObject.maxStartTime", "1000");
       mainAppsController.set("filterObject.sSearch", "searchTerm");
       mainAppsController.set("filterObject.iDisplayLength", "10");
       mainAppsController.set("filterObject.iDisplayStart", "10");
       mainAppsController.set("filterObject.iSortCol_0", "1");
       mainAppsController.set("filterObject.sSortDir_0", "ASC");
       expect(mainAppsController.get('runUrl')).to.equal("/jobhistory/datatable?" +
           "sSearch_0=0" +
           "&sSearch_1=workflowName" +
           "&sSearch_2=pig" +
           "&sSearch_3=admin" +
           "&minJobs=1" +
           "&maxJobs=2" +
           "&minDuration=1000" +
           "&maxDuration=2000" +
           "&minStartTime=999" +
           "&maxStartTime=1000" +
           "&sSearch=searchTerm" +
           "&iDisplayLength=10" +
           "&iDisplayStart=10" +
           "&iSortCol_0=1" +
           "&sSortDir_0=ASC");
       expect(mainAppsController.get('filterObject.viewType')).to.equal('filtered');
     });

     it('should set viewType to "all" when set iDisplayLength, iDisplayStart, iSortCol_0, sSortDir_0', function () {
       mainAppsController.set("filterObject.sSearch_0", "");
       mainAppsController.set("filterObject.sSearch_1", "");
       mainAppsController.set("filterObject.sSearch_2", "");
       mainAppsController.set("filterObject.sSearch_3", "");
       mainAppsController.set("filterObject.minJobs", "");
       mainAppsController.set("filterObject.maxJobs", "");
       mainAppsController.set("filterObject.minDuration", "");
       mainAppsController.set("filterObject.maxDuration", "");
       mainAppsController.set("filterObject.minStartTime", "");
       mainAppsController.set("filterObject.maxStartTime", "");
       mainAppsController.set("filterObject.sSearch", "");
       mainAppsController.set("filterObject.iDisplayLength", "10");
       mainAppsController.set("filterObject.iDisplayStart", "10");
       mainAppsController.set("filterObject.iSortCol_0", "1");
       mainAppsController.set("filterObject.sSortDir_0", "ASC");
       expect(mainAppsController.get('filterObject.viewType')).to.equal('all');
     });
   });




 });


});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_cpuWaitIO_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('messages');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_cpuWaitIO');

describe('App.MainChartHeatmapCpuWaitIOMetric', function () {

  var tests = [
    {
      json: {
        "items" : [
          {
            "Hosts" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "cpu" : {
                "cpu_wio" : 0.4
              }
            }
          }
        ]
      },
      m: 'One host',
      e: {'dev01.hortonworks.com': '40.0'}
    },
    {
      json: {
        "items" : [
          {
            "Hosts" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "cpu" : {
                "cpu_wio" : 0.4
              }
            }
          },
          {
            "Hosts" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "cpu" : {
                "cpu_wio" : 0.34566
              }
            }
          }
        ]
      },
      m: 'Two hosts',
      e: {'dev01.hortonworks.com': '40.0', 'dev02.hortonworks.com': '34.6'}
    },
    {
      json: {
        "items" : [
          {
            "Hosts" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "cpu" : {
                "cpu_wio" : 0.4
              }
            }
          },
          {
            "Hosts" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "cpu" : {
              }
            }
          }
        ]
      },
      m: 'Two hosts, One without metric',
      e: {'dev01.hortonworks.com': '40.0'}
    }
  ];

  describe('#metricMapper()', function() {
    var mainChartHeatmapCpuWaitIOMetric = App.MainChartHeatmapCpuWaitIOMetric.create();

    tests.forEach(function(test) {
      it(test.m, function() {
        var r = mainChartHeatmapCpuWaitIOMetric.metricMapper(test.json);
        expect(r).to.eql(test.e);
      });
    });

  });

});

});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_dfs_bytesread_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('messages');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_dfs');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_dfs_bytesread');

describe('App.MainChartHeatmapDFSBytesReadMetric', function () {

  var tests = [
    {i: 0, e: 0},
    {i: 0.5 * 1024* 1024, e: 0.5},
    {i: 1024* 1024, e: 1},
    {i: 10.5 * 1024 * 1024,e: 10.5}
  ];

  describe('#transformValue()', function() {
    var mainChartHeatmapDFSBytesReadMetric = App.MainChartHeatmapDFSBytesReadMetric.create();

    tests.forEach(function(test) {
      it(test.i + ' bytes to ' + test.e + ' MB', function() {
        var r = mainChartHeatmapDFSBytesReadMetric.transformValue(test.i);
        expect(r).to.eql(test.e);
      });
    });

  });

});

});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_dfs_byteswritten_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('messages');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_dfs');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_dfs_byteswritten');

describe('App.MainChartHeatmapDFSBytesWrittenMetric', function () {

  var tests = [
    {i: 0, e: 0},
    {i: 0.5 * 1024* 1024, e: 0.5},
    {i: 1024* 1024, e: 1},
    {i: 10.5 * 1024 * 1024,e: 10.5}
  ];

  describe('#transformValue()', function() {
    var mainChartHeatmapDFSBytesWrittenMetric = App.MainChartHeatmapDFSBytesWrittenMetric.create();

    tests.forEach(function(test) {
      it(test.i + ' bytes to ' + test.e + ' MB', function() {
        var r = mainChartHeatmapDFSBytesWrittenMetric.transformValue(test.i);
        expect(r).to.eql(test.e);
      });
    });

  });

});

});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_dfs_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('messages');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_dfs');

describe('App.MainChartHeatmapDFSMetrics', function () {

  var tests = [
    {
      json: {
        "host_components" : [
          {
            "HostRoles" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {
                "gcTimeMillis" : 285
              }
            }
          }
        ]
      },
      result: {'dev01.hortonworks.com': 285},
      m: 'One host_component'
    },
    {
      json: {
        "host_components" : [
          {
            "HostRoles" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {
                "gcTimeMillis" : 285
              }
            }
          },
          {
            "HostRoles" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {
                "gcTimeMillis" : 124
              }
            }
          }
        ]
      },
      result: {'dev01.hortonworks.com': 285, 'dev02.hortonworks.com': 124},
      m: 'Two host_components'
    },
    {
      json: {
        "host_components" : [
          {
            "HostRoles" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {
                "gcTimeMillis" : 285
              }
            }
          },
          {
            "HostRoles" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {

              }
            }
          }
        ]
      },
      result: {'dev01.hortonworks.com': 285},
      m: 'Two host_components, one without metric'
    }
  ];

  describe('#metricMapper()', function() {
    var mainChartHeatmapDFSMetrics = App.MainChartHeatmapDFSMetrics.create();
    mainChartHeatmapDFSMetrics.set('defaultMetric', 'metrics.jvm.gcTimeMillis');

    tests.forEach(function(test) {
      it(test.m, function() {
        var r = mainChartHeatmapDFSMetrics.metricMapper(test.json);
        expect(r).to.eql(test.result);
      });
    });

  });

});

});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_diskspaceused_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('messages');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_diskspaceused');

describe('App.MainChartHeatmapDiskSpaceUsedMetric', function () {

  var tests = Em.A([
    {
      json:{
        "items" : [
          {
            "Hosts" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "disk" : {
                "disk_free" : 89.973,
                "disk_total" : 101.515
              }
            }
          }
        ]
      },
      m: 'One host',
      e: {'dev01.hortonworks.com': 11.37}
    },
    {
      json:{
        "items" : [
          {
            "Hosts" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "disk" : {
                "disk_free" : 89.973,
                "disk_total" : 101.515
              }
            }
          },
          {
            "Hosts" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "disk" : {
                "disk_free" : 89.973,
                "disk_total" : 101.515
              }
            }
          }
        ]
      },
      m: 'Two hosts',
      e: {'dev01.hortonworks.com': 11.37, 'dev02.hortonworks.com': 11.37}
    },
    {
      json:{
        "items" : [
          {
            "Hosts" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "disk" : {
                "disk_free" : 89.973,
                "disk_total" : 101.515
              }
            }
          },
          {
            "Hosts" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {

            }
          }
        ]
      },
      m: 'Two hosts, One without metric',
      e: {'dev01.hortonworks.com': 11.37}
    }
  ]);

  describe('#metricMapper()', function() {
    var mainChartHeatmapDiskSpaceUsedMetric = App.MainChartHeatmapDiskSpaceUsedMetric.create();

    tests.forEach(function(test) {
      it(test.m, function() {
        var r = mainChartHeatmapDiskSpaceUsedMetric.metricMapper(test.json);
        expect(r).to.eql(test.e);
      });
    });

  });

});

});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_hbase_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('messages');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_hbase');

describe('App.MainChartHeatmapHbaseMetrics', function () {

  var tests = [
    {
      json: {
        "host_components" : [
          {
            "HostRoles" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "hbase" : {
                "regionserver" : {
                  "readRequestsCount" : 0.0
                }
              }
            }
          }
        ]
      },
      result: {'dev01.hortonworks.com': 0},
      m: 'One host_component'
    },
    {
      json: {
        "host_components" : [
          {
            "HostRoles" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "hbase" : {
                "regionserver" : {
                  "readRequestsCount" : 0.0
                }
              }
            }
          },
          {
            "HostRoles" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "hbase" : {
                "regionserver" : {
                  "readRequestsCount" : 1.0
                }
              }
            }
          }
        ]
      },
      result: {'dev01.hortonworks.com': 0, 'dev02.hortonworks.com': 1},
      m: 'Two host_components'
    },
    {
      json: {
        "host_components" : [
          {
            "HostRoles" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "hbase" : {
                "regionserver" : {
                  "readRequestsCount" : 0.0
                }
              }
            }
          },
          {
            "HostRoles" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "hbase" : {
                "regionserver" : {

                }
              }
            }
          }
        ]
      },
      result: {'dev01.hortonworks.com': 0},
      m: 'Two host_components, one without metric'
    }
  ];

  describe('#metricMapper()', function() {
    var mainChartHeatmapHbaseMetrics = App.MainChartHeatmapHbaseMetrics.create();
    mainChartHeatmapHbaseMetrics.set('defaultMetric', 'metrics.hbase.regionserver.readRequestsCount');

    tests.forEach(function(test) {
      it(test.m, function() {
        var r = mainChartHeatmapHbaseMetrics.metricMapper(test.json);
        expect(r).to.eql(test.result);
      });
    });

  });

});

});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_memoryused_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('messages');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_memoryused');

describe('App.MainChartHeatmapMemoryUsedMetric', function () {

  var tests = [
    {
      json:{
        "items" : [
          {
            "Hosts" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "memory" : {
                "mem_buffers" : 109888.0,
                "mem_cached" : 1965624.0,
                "mem_free" : 261632.0,
                "mem_shared" : 0.0,
                "mem_total" : 6123776.0,
                "swap_free" : 4126820.0,
                "swap_total" : 4128760.0
              }
            }
          }
        ]
      },
      m: 'One host',
      e: {'dev01.hortonworks.com': '63.6'}
    },
    {
      json:{
        "items" : [
          {
            "Hosts" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "memory" : {
                "mem_buffers" : 109888.0,
                "mem_cached" : 1965624.0,
                "mem_free" : 261632.0,
                "mem_shared" : 0.0,
                "mem_total" : 6123776.0,
                "swap_free" : 4126820.0,
                "swap_total" : 4128760.0
              }
            }
          },
          {
            "Hosts" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "memory" : {
                "mem_buffers" : 109888.0,
                "mem_cached" : 1965624.0,
                "mem_free" : 261632.0,
                "mem_shared" : 0.0,
                "mem_total" : 6123776.0,
                "swap_free" : 4126820.0,
                "swap_total" : 4128760.0
              }
            }
          }
        ]
      },
      m: 'Two hosts',
      e: {'dev01.hortonworks.com': '63.6', 'dev02.hortonworks.com': '63.6'}
    },
    {
      json:{
        "items" : [
          {
            "Hosts" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "memory" : {
                "mem_buffers" : 109888.0,
                "mem_cached" : 1965624.0,
                "mem_free" : 261632.0,
                "mem_shared" : 0.0,
                "mem_total" : 6123776.0,
                "swap_free" : 4126820.0,
                "swap_total" : 4128760.0
              }
            }
          },
          {
            "Hosts" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {

            }
          }
        ]
      },
      m: 'Two hosts, One without metric',
      e: {'dev01.hortonworks.com': '63.6'}
    }
  ];

  describe('#metricMapper()', function() {
    var mainChartHeatmapMemoryUsedMetric = App.MainChartHeatmapMemoryUsedMetric.create();

    tests.forEach(function(test) {
      it(test.m, function() {
        var r = mainChartHeatmapMemoryUsedMetric.metricMapper(test.json);
        expect(r).to.eql(test.e);
      });
    });

  });

});

});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');

describe('MainChartHeatmapMetric', function () {

  var mainChartHeatmapMetric = App.MainChartHeatmapMetric.create({});

  describe('#formatLegendNumber', function () {
    var tests = [
      {m:'undefined to undefined',i:undefined,e:undefined},
      {m:'0 to 0',i:0,e:0},
      {m:'1 to 1',i:1,e:1},
      {m:'1.23 to 1.2',i:1.23,e:1.2}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(mainChartHeatmapMetric.formatLegendNumber(test.i)).to.equal(test.e);
      });
    });
    it('NaN to NaN' + ' ', function () {
      expect(isNaN(mainChartHeatmapMetric.formatLegendNumber(NaN))).to.equal(true);
    });
  });

  describe('#refreshHostSlots', function() {
    beforeEach(function() {
      App.set('apiPrefix', '/api/v1');
      App.set('clusterName', 'tdk');
      App.testMode = false;
      sinon.spy($, 'ajax');
    });

    afterEach(function() {
      $.ajax.restore();
      App.testMode = true;
    });

    mainChartHeatmapMetric  = App.MainChartHeatmapMetric.create({});
    mainChartHeatmapMetric.set('ajaxIndex', 'hosts.metrics.host_component');
    mainChartHeatmapMetric.set('ajaxData', {
      serviceName: 'SERVICE',
      componentName: 'COMPONENT'
    });
    mainChartHeatmapMetric.set('defaultMetric', 'default.metric');

    it('Should load proper URL', function() {
      mainChartHeatmapMetric.refreshHostSlots();
      expect($.ajax.args[0][0].url.endsWith('/api/v1/clusters/tdk/services/SERVICE/components/COMPONENT?fields=host_components/default/metric')).to.equal(true);
    });

  });

});

});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_yarn_ResourceUsed_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('messages');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_yarn');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_yarn_ResourceUsed');

describe('App.MainChartHeatmapYarnResourceUsedMetric', function () {

  var mainChartHeatmapYarnResourceUsedMetric = App.MainChartHeatmapYarnResourceUsedMetric.create({});

  describe('#metricMapper', function () {
    var tests = [
      {
        m: 'Correct JSON #1',
        i: {
          "ServiceComponentInfo" : {
            "rm_metrics" : {
              "cluster" : {
                "nodeManagers" : "[{\"HostName\":\"dev01.hortonworks.com\",\"Rack\":\"/default-rack\",\"State\":\"RUNNING\",\"NodeId\":\"dev01.hortonworks.com:45454\",\"NodeHTTPAddress\":\"dev01.hortonworks.com:8042\",\"LastHealthUpdate\":1375869232870,\"HealthReport\":\"\",\"NumContainers\":0,\"UsedMemoryMB\":10,\"AvailableMemoryMB\":100}]"
              }
            }
          }
        },
        e: {
          length: 1,
          val: '10.0',
          host: 'dev01.hortonworks.com'
        }
      },
      {
        m: 'Correct JSON #2',
        i: {
          "ServiceComponentInfo" : {
            "rm_metrics" : {
              "cluster" : {
                "nodeManagers" : "[{\"HostName\":\"dev01.hortonworks.com\",\"Rack\":\"/default-rack\",\"State\":\"RUNNING\",\"NodeId\":\"dev01.hortonworks.com:45454\",\"NodeHTTPAddress\":\"dev01.hortonworks.com:8042\",\"LastHealthUpdate\":1375869232870,\"HealthReport\":\"\",\"NumContainers\":0,\"UsedMemoryMB\":0,\"AvailableMemoryMB\":100}]"
              }
            }
          }
        },
        e: {
          length: 1,
          val: '0.0',
          host: 'dev01.hortonworks.com'
        }
      },
      {
        m: 'JSON without "cluster"',
        i: {
          "ServiceComponentInfo" : {
            "rm_metrics" : {
            }
          }
        },
        e: {
          length: 0,
          val: null,
          host: null
        }
      },
      {
        m: 'JSON without "nodeManagers"',
        i: {
          "ServiceComponentInfo" : {
            "rm_metrics" : {
              "cluster" : {
              }
            }
          }
        },
        e: {
          length: 0,
          val: null,
          host: null
        }
      },
      {
        m: 'Correct JSON #3 (with two nodeManagers)',
        i: {
          "ServiceComponentInfo" : {
            "rm_metrics" : {
              "cluster" : {
                "nodeManagers" : "[{\"HostName\":\"dev01.hortonworks.com\",\"Rack\":\"/default-rack\",\"State\":\"RUNNING\",\"NodeId\":\"dev01.hortonworks.com:45454\",\"NodeHTTPAddress\":\"dev01.hortonworks.com:8042\",\"LastHealthUpdate\":1375869232870,\"HealthReport\":\"\",\"NumContainers\":0,\"UsedMemoryMB\":0,\"AvailableMemoryMB\":100}, {\"HostName\":\"dev02.hortonworks.com\",\"Rack\":\"/default-rack\",\"State\":\"RUNNING\",\"NodeId\":\"dev02.hortonworks.com:45454\",\"NodeHTTPAddress\":\"dev01.hortonworks.com:8042\",\"LastHealthUpdate\":1375869232870,\"HealthReport\":\"\",\"NumContainers\":0,\"UsedMemoryMB\":100,\"AvailableMemoryMB\":100}]"
              }
            }
          }
        },
        e: {
          length: 2,
          val: '100.0',
          host: 'dev02.hortonworks.com'
        }
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function () {
        var result = mainChartHeatmapYarnResourceUsedMetric.metricMapper(test.i);
        var length = 0;
        for(var p in result) {
          if (result.hasOwnProperty(p)) {
            length++;
          }
        }
        expect(length).to.equal(test.e.length);
        if (test.e.host) {
          expect(result.hasOwnProperty(test.e.host)).to.equal(true);
          expect(result[test.e.host]).to.equal(test.e.val);
        }
      });
    });
  });

});

});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_yarn_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('messages');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
require('controllers/main/charts/heatmap_metrics/heatmap_metric_yarn');

describe('App.MainChartHeatmapYarnMetrics', function () {

  var tests = [
    {
      json: {
        "host_components" : [
          {
            "HostRoles" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {
                "memHeapUsedM" : 10
              }
            }
          }
        ]
      },
      result: {'dev01.hortonworks.com': 10},
      m: 'One host_component'
    },
    {
      json: {
        "host_components" : [
          {
            "HostRoles" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {
                "memHeapUsedM" : 10
              }
            }
          },
          {
            "HostRoles" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {
                "memHeapUsedM" : 20
              }
            }
          }
        ]
      },
      result: {'dev01.hortonworks.com': 10, 'dev02.hortonworks.com': 20},
      m: 'Two host_components'
    },
    {
      json: {
        "host_components" : [
          {
            "HostRoles" : {
              "host_name" : "dev01.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {
                "memHeapUsedM" : 10
              }
            }
          },
          {
            "HostRoles" : {
              "host_name" : "dev02.hortonworks.com"
            },
            "metrics" : {
              "jvm" : {

              }
            }
          }
        ]
      },
      result: {'dev01.hortonworks.com': 10},
      m: 'Two host_components, one without metric'
    }
  ];

  describe('#metricMapper()', function() {
    var mainChartHeatmapYarnMetrics = App.MainChartHeatmapYarnMetrics.create();
    mainChartHeatmapYarnMetrics.set('defaultMetric', 'metrics.jvm.memHeapUsedM');

    tests.forEach(function(test) {
      it(test.m, function() {
        var r = mainChartHeatmapYarnMetrics.metricMapper(test.json);
        expect(r).to.eql(test.result);
      });
    });

  });

});

});

;require.register("test/controllers/main/charts/heatmap_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('models/rack');
require('controllers/main/charts/heatmap');

describe('MainChartsHeatmapController', function () {

  describe('#validation()', function () {
    var controller = App.MainChartsHeatmapController.create({
      allMetrics: [],
      selectedMetric: Ember.Object.create({maximumValue: 100})
    });
    it('should set maximumValue if inputMaximum consists only of digits', function () {
      controller.set("inputMaximum", 5);
      expect(controller.get('selectedMetric.maximumValue')).to.equal(5);
    });
    it('should not set maximumValue if inputMaximum consists not only of digits', function () {
      controller.set("inputMaximum", 'qwerty');
      expect(controller.get('selectedMetric.maximumValue')).to.equal(5);
    });
    it('should not set maximumValue if inputMaximum consists not only of digits', function () {
      controller.set("inputMaximum", '100%');
      expect(controller.get('selectedMetric.maximumValue')).to.equal(5);
    });
    it('should set maximumValue if inputMaximum consists only of digits', function () {
      controller.set("inputMaximum", 1000);
      expect(controller.get('selectedMetric.maximumValue')).to.equal(1000);
    })
  });

  describe('#showHeatMapMetric()', function () {
    var controller = App.MainChartsHeatmapController.create({
      allMetrics: [],
      selectedMetric: Ember.Object.create({maximumValue: 100}),
      loadMetrics: function () {
      }
    });
    controller.set("selectedMetric", 100);
    it('should not set selectedMetric event.context if it is not defined', function () {
      controller.showHeatMapMetric({});
      expect(controller.get('selectedMetric')).to.equal(100);
    });
    it('should set selectedMetric event.context if it is defined', function () {
      controller.showHeatMapMetric({context: 5});
      expect(controller.get('selectedMetric')).to.equal(5);
    });
  });

  describe('#loadMetrics()', function () {
    var controller = App.MainChartsHeatmapController.create({
      testPassed: false,
      allMetrics: [],
      inputMaximum: 10
    });
    controller.set('selectedMetric', Ember.Object.create({
      maximumValue: 100,
      refreshHostSlots: function () {
        controller.set('testPassed', true);
      }
    }));
    controller.loadMetrics();
    it('should set inputMaximum as selectedMetric.maximumValue', function () {
      expect(controller.get('inputMaximum')).to.equal(100);
    });
    it('should call refreshHostSlots from selectedMetric', function () {
      expect(controller.get('testPassed')).to.equal(true);
    });
  });

  describe('#rackClass', function () {
    var controller = App.MainChartsHeatmapController.create({
      allMetrics: [],
      racks: [1]
    });
    it('should return "span12" for 1 cluster rack', function () {
      expect(controller.get('rackClass')).to.equal('span12');
    });
    it('should return "span6" for 2 cluster racks', function () {
      controller.set('racks', [1, 2]);
      expect(controller.get('rackClass')).to.equal('span6');
    });
    it('should return "span4" for 3 cluster racks', function () {
      controller.set('racks', [1, 2, 3]);
      expect(controller.get('rackClass')).to.equal('span4');
    });
  });
});


});

;require.register("test/controllers/main/dashboard_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
var App = require('app');

require('models/alert'); 
App.Alert.FIXTURES = [{ status: 'ok' }, { status: 'corrupt' }, { status: 'corrupt',}];
require('controllers/main/dashboard');
 
describe('MainDashboard', function () {
 
  var controller = App.MainDashboardController.create();
  
  describe('#alertsCount', function () {
    it('should return 2 if 2 alerts has status corrupt', function () {
        expect(controller.get('alertsCount')).to.equal(2);
    })
  })
})
*/
});

;require.register("test/controllers/main/host/add_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/wizard');
require('controllers/main/host/add_controller');
require('models/host_component');
require('models/service');
require('mappers/server_data_mapper');

describe('App.AddHostController', function () {

  var controller = App.AddHostController.create({
    testDBHosts: null,
    getDBProperty: function () {
      return this.get('testDBHosts');
    },
    setDBProperty: function () {
    },
    loadClients: function () {
    }
  });

  beforeEach(function () {
    sinon.spy(controller, "setDBProperty");
  });
  afterEach(function () {
    controller.setDBProperty.restore();
  });

  describe('#removeHosts()', function () {
    var testCases = [
      {
        title: 'No hosts, db is empty',
        content: {
          hosts: [],
          dbHosts: {}
        },
        result: {}
      },
      {
        title: 'Host is passed, db is empty',
        content: {
          hosts: [
            {hostName: 'host1'}
          ],
          dbHosts: {}
        },
        result: {}
      },
      {
        title: 'Passed host different from hosts in db',
        content: {
          hosts: [
            {hostName: 'host1'}
          ],
          dbHosts: {
            'host2': {}
          }
        },
        result: {
          'host2': {}
        }
      },
      {
        title: 'Passed host match host in db',
        content: {
          hosts: [
            {hostName: 'host1'}
          ],
          dbHosts: {
            'host1': {}
          }
        },
        result: {}
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('testDBHosts', test.content.dbHosts);
        controller.removeHosts(test.content.hosts);
        expect(controller.setDBProperty.calledWith('hosts', test.result)).to.be.true;
      });
    });
  });

  describe('#saveClients()', function () {

    var modelSetup = require('test/init_model_test');
    var testCases = [
      {
        title: 'No services',
        services: [],
        result: []
      },
      {
        title: 'No selected services',
        services: [
          {isSelected: false}
        ],
        result: []
      },
      {
        title: 'Service is not in stack',
        services: [
          {
            serviceName: 'TEST',
            isSelected: true
          }
        ],
        result: []
      },
      {
        title: 'Service does not have any clients',
        services: [
          {
            serviceName: 'GANGLIA',
            isSelected: true
          }
        ],
        result: []
      },
      {
        title: 'StackServiceComponent is empty',
        services: [
          {
            serviceName: 'HDFS',
            isSelected: true
          }
        ],
        result: []
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('content.services', test.services);
        controller.saveClients();
        expect(controller.setDBProperty.calledWith('clientInfo', test.result)).to.be.true;
        expect(controller.get('content.clients')).to.be.empty;
      });
    });

    it('HDFS has uninstalled client', function () {
      modelSetup.setupStackServiceComponent();
      var services = [
        {
          serviceName: 'HDFS',
          isSelected: true
        }
      ];
      controller.set('content.services', services);
      controller.saveClients();
      expect(controller.get('content.clients')).to.eql([
        {
          component_name: 'HDFS_CLIENT',
          display_name: 'HDFS Client',
          isInstalled: false
        }
      ]);
      expect(controller.setDBProperty.calledWith('clientInfo', [
        {
          component_name: 'HDFS_CLIENT',
          display_name: 'HDFS Client',
          isInstalled: false
        }
      ])).to.be.true;
      modelSetup.cleanStackServiceComponent();
    });
    it('HDFS has installed client', function () {
      modelSetup.setupStackServiceComponent();
      var services = [
        {
          serviceName: 'HDFS',
          isSelected: true
        }
      ];
      App.store.load(App.HostComponent, {
        id: 'HDFS_CLIENT_host1',
        component_name: "HDFS_CLIENT"
      });
      controller.set('content.services', services);
      controller.saveClients();
      expect(controller.get('content.clients')).to.eql([
        {
          component_name: 'HDFS_CLIENT',
          display_name: 'HDFS Client',
          isInstalled: true
        }
      ]);
      expect(controller.setDBProperty.calledWith('clientInfo', [
        {
          component_name: 'HDFS_CLIENT',
          display_name: 'HDFS Client',
          isInstalled: true
        }
      ])).to.be.true;
      modelSetup.cleanStackServiceComponent();
    });
  });

  describe('#applyConfigGroup()', function () {

    beforeEach(function () {
      sinon.spy(App.ajax, "send");
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('No config groups', function () {
      controller.set('content.serviceConfigGroups', []);
      controller.applyConfigGroup();
      expect(App.ajax.send.called).to.be.false;
    });
    it('Selected group has no groups', function () {
      var serviceConfigGroups = [
        {
          configGroups: [],
          selectedConfigGroup: ''
        }
      ];
      controller.set('content.serviceConfigGroups', serviceConfigGroups);
      controller.applyConfigGroup();
      expect(App.ajax.send.called).to.be.false;
    });
    it('Selected group does not match groups', function () {
      var serviceConfigGroups = [
        {
          configGroups: [
            {
              ConfigGroup: {
                group_name: 'group1'
              }
            }
          ],
          selectedConfigGroup: 'group2'
        }
      ];
      controller.set('content.serviceConfigGroups', serviceConfigGroups);
      controller.applyConfigGroup();
      expect(App.ajax.send.called).to.be.false;
    });
    it('Selected group has zero hosts', function () {
      var serviceConfigGroups = [
        {
          configGroups: [
            {
              ConfigGroup: {
                group_name: 'group1',
                hosts: []
              },
              href: 'href'
            }
          ],
          hosts: [],
          selectedConfigGroup: 'group1'
        }
      ];
      controller.set('content.serviceConfigGroups', serviceConfigGroups);
      controller.applyConfigGroup();
      expect(serviceConfigGroups[0].configGroups[0].ConfigGroup.hosts).to.be.empty;
      expect(serviceConfigGroups[0].configGroups[0].href).to.be.undefined;
      expect(App.ajax.send.calledOnce).to.be.true;
    });
    it('Selected group has host', function () {
      var serviceConfigGroups = [
        {
          configGroups: [
            {
              ConfigGroup: {
                group_name: 'group1',
                hosts: []
              },
              href: 'href'
            }
          ],
          hosts: ['host1'],
          selectedConfigGroup: 'group1'
        }
      ];
      controller.set('content.serviceConfigGroups', serviceConfigGroups);
      controller.applyConfigGroup();
      expect(serviceConfigGroups[0].configGroups[0].ConfigGroup.hosts).to.eql([
        {host_name: 'host1'}
      ]);
      expect(serviceConfigGroups[0].configGroups[0].href).to.be.undefined;
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#sortServiceConfigGroups()', function () {
    var testCases = [
      {
        title: 'No selected services',
        selectedServices: [
          {configGroups: []}
        ],
        result: [
          {configGroups: []}
        ]
      },
      {
        title: 'Only one group is present',
        selectedServices: [
          {configGroups: [
            {configGroups: {group_name: 'b'}}
          ]}
        ],
        result: [
          {configGroups: [
            {configGroups: {group_name: 'b'}}
          ]}
        ]
      },
      {
        title: 'Reverse order of groups',
        selectedServices: [
          {configGroups: [
            {ConfigGroup: {group_name: 'b2'}},
            {ConfigGroup: {group_name: 'a1'}}
          ]}
        ],
        result: [
          {configGroups: [
            {ConfigGroup: {group_name: 'a1'}},
            {ConfigGroup: {group_name: 'b2'}}
          ]}
        ]
      },
      {
        title: 'Correct order of groups',
        selectedServices: [
          {configGroups: [
            {ConfigGroup: {group_name: 'a1'}},
            {ConfigGroup: {group_name: 'b2'}}
          ]}
        ],
        result: [
          {configGroups: [
            {ConfigGroup: {group_name: 'a1'}},
            {ConfigGroup: {group_name: 'b2'}}
          ]}
        ]
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.sortServiceConfigGroups(test.selectedServices);
        expect(test.selectedServices).to.eql(test.result);
      });
    });
  });

  describe('#loadServiceConfigGroupsBySlaves()', function () {
    var testCases = [
      {
        title: 'slaveComponentHosts is null',
        slaveComponentHosts: null,
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'slaveComponentHosts is empty',
        slaveComponentHosts: [],
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'Component does not have hosts',
        slaveComponentHosts: [
          {hosts: []}
        ],
        result: {
          output: true,
          selectedServices: []
        }
      },
      {
        title: 'Only client component is present',
        slaveComponentHosts: [
          {
            hosts: [
              {hostName: 'host1'}
            ],
            componentName: 'CLIENT'
          }
        ],
        result: {
          output: true,
          selectedServices: []
        }
      },
      {
        title: 'Slave component is present',
        slaveComponentHosts: [
          {
            hosts: [
              {hostName: 'host1'}
            ],
            componentName: 'DATANODE'
          }
        ],
        result: {
          output: true,
          selectedServices: [
            {
              serviceId: 'HDFS',
              displayName: 'HDFS',
              hosts: ['host1'],
              configGroupsNames: ['HDFS Default', 'HDFS test'],
              configGroups: [
                {
                  ConfigGroup: {
                    tag: 'HDFS',
                    group_name: 'HDFS test'
                  }
                }
              ],
              selectedConfigGroup: 'HDFS Default'
            }
          ]
        }
      }
    ];

    controller.set('content.configGroups', [
      {
        ConfigGroup: {
          tag: 'HDFS',
          group_name: 'HDFS test'
        }
      }
    ]);
    testCases.forEach(function (test) {
      it(test.title, function () {
        var selectedServices = [];
        controller.set('content.slaveComponentHosts', test.slaveComponentHosts);
        expect(controller.loadServiceConfigGroupsBySlaves(selectedServices)).to.equal(test.result.output);
        expect(selectedServices).to.eql(test.result.selectedServices);
      });
    });
  });

  describe('#loadServiceConfigGroupsByClients()', function () {
    var testCases = [
      {
        title: 'slaveComponentHosts is null',
        content: {
          slaveComponentHosts: null,
          clients: [],
          selectedServices: []
        },
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'slaveComponentHosts is empty',
        content: {
          slaveComponentHosts: [],
          clients: [],
          selectedServices: []
        },
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'Client does not have hosts',
        content: {
          slaveComponentHosts: [
            {
              componentName: 'CLIENT',
              hosts: []
            }
          ],
          clients: [],
          selectedServices: []
        },
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'Client has hosts, but clients is empty',
        content: {
          slaveComponentHosts: [
            {
              componentName: 'CLIENT',
              hosts: [
                {hostName: 'host1'}
              ]
            }
          ],
          clients: [],
          selectedServices: []
        },
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'Client is present',
        content: {
          slaveComponentHosts: [
            {
              componentName: 'CLIENT',
              hosts: [
                {hostName: 'host1'}
              ]
            }
          ],
          clients: [
            {
              component_name: 'HDFS_CLIENT'
            }
          ],
          selectedServices: []
        },
        result: {
          output: true,
          selectedServices: [
            {
              serviceId: 'HDFS',
              displayName: 'HDFS',
              hosts: ['host1'],
              configGroupsNames: ['HDFS Default', 'HDFS test'],
              configGroups: [
                {
                  ConfigGroup: {
                    tag: 'HDFS',
                    group_name: 'HDFS test'
                  }
                }
              ],
              selectedConfigGroup: 'HDFS Default'
            }
          ]
        }
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('content.slaveComponentHosts', test.content.slaveComponentHosts);
        controller.set('content.clients', test.content.clients);
        expect(controller.loadServiceConfigGroupsByClients(test.content.selectedServices)).to.equal(test.result.output);
        expect(test.content.selectedServices).to.eql(test.result.selectedServices);
      });
    });
  });

  describe('#installServices()', function () {

    beforeEach(function () {
      sinon.spy(App.ajax, "send");
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('No hosts', function () {
      controller.set('content.cluster', {name: 'cl'});
      controller.set('testDBHosts', {});
      expect(controller.installServices()).to.be.false;
      expect(App.ajax.send.called).to.be.false;
    });
    it('Cluster name is empty', function () {
      controller.set('content.cluster', {name: ''});
      controller.set('testDBHosts', {'host1': {}});
      expect(controller.installServices()).to.be.false;
      expect(App.ajax.send.called).to.be.false;
    });
    it('Cluster name is correct and hosts are present', function () {
      controller.set('content.cluster', {name: 'cl'});
      controller.set('testDBHosts', {'host1': {}});
      expect(controller.installServices()).to.be.true;
      expect(App.ajax.send.called).to.be.true;
    });
    it('Cluster name is correct and hosts are present, isRetry = true', function () {
      controller.set('content.cluster', {name: 'cl'});
      controller.set('testDBHosts', {'host1': {}});
      expect(controller.installServices(true)).to.be.true;
      expect(App.ajax.send.called).to.be.true;
    });
  });
});

});

;require.register("test/controllers/main/host/configs_service_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/host/configs_service');


describe('App.MainHostServiceConfigsController', function () {

  var controller = App.MainHostServiceConfigsController.create({
    host: Em.Object.create()
  });


  describe('#filterServiceConfigs()', function () {
    var testCases = [
      {
        title: 'configCategories is empty',
        content: {
          configCategories: [],
          hostComponents: []
        },
        result: []
      },
      {
        title: 'Category hostComponentNames is null',
        content: {
          configCategories: [
            Em.Object.create({hostComponentNames: null})
          ],
          hostComponents: []
        },
        result: [
          Em.Object.create({hostComponentNames: null})
        ]
      },
      {
        title: 'Components of host are empty',
        content: {
          configCategories: [
            Em.Object.create({hostComponentNames: ['comp1']})
          ],
          hostComponents: []
        },
        result: []
      },
      {
        title: 'Host components do not match component of categories',
        content: {
          configCategories: [
            Em.Object.create({hostComponentNames: ['comp1']})
          ],
          hostComponents: [
            {
              componentName: 'comp2'
            }
          ]
        },
        result: []
      },
      {
        title: 'Host components match component of categories',
        content: {
          configCategories: [
            Em.Object.create({hostComponentNames: ['comp1']})
          ],
          hostComponents: [
            {
              componentName: 'comp1'
            }
          ]
        },
        result: [
          Em.Object.create({hostComponentNames: ['comp1']})
        ]
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('host.hostComponents', test.content.hostComponents);
        expect(controller.filterServiceConfigs(test.content.configCategories)).to.eql(test.result);
      });
    });
  });

  describe('#constructUrlParams()', function () {
    it('loadedGroupToOverrideSiteToTagMap is empty', function () {
      var loadedGroupToOverrideSiteToTagMap = {};
      var configGroups = [];
      expect(controller.constructUrlParams(loadedGroupToOverrideSiteToTagMap, configGroups)).to.eql([]);
      expect(controller.get('typeTagToGroupMap')).to.eql({});
    });
    it('Group does not have hosts', function () {
      var loadedGroupToOverrideSiteToTagMap = {'group1': {}};
      var configGroups = [
        Em.Object.create({
          name: 'group1',
          hosts: []
        })
      ];
      expect(controller.constructUrlParams(loadedGroupToOverrideSiteToTagMap, configGroups)).to.eql([]);
      expect(controller.get('typeTagToGroupMap')).to.eql({});
    });
    it('Group does not contain current host', function () {
      controller.set('host.hostName', 'host2');
      var loadedGroupToOverrideSiteToTagMap = {'group1': {}};
      var configGroups = [
        Em.Object.create({
          name: 'group1',
          hosts: ['host1']
        })
      ];
      expect(controller.constructUrlParams(loadedGroupToOverrideSiteToTagMap, configGroups)).to.eql([]);
      expect(controller.get('typeTagToGroupMap')).to.eql({});
    });
    it('No type to tags relations in group', function () {
      var loadedGroupToOverrideSiteToTagMap = {'group1': {}};
      var configGroups = [
        Em.Object.create({
          name: 'group1',
          hosts: ['host2']
        })
      ];
      expect(controller.constructUrlParams(loadedGroupToOverrideSiteToTagMap, configGroups)).to.eql([]);
      expect(controller.get('typeTagToGroupMap')).to.eql({});
    });
    it('Input params are correct', function () {
      var loadedGroupToOverrideSiteToTagMap = {
        'group1': {
          'type1': 'tag1'
        }
      };
      var configGroups = [
        Em.Object.create({
          name: 'group1',
          hosts: ['host2']
        })
      ];
      expect(controller.constructUrlParams(loadedGroupToOverrideSiteToTagMap, configGroups)).to.eql(['(type=type1&tag=tag1)']);
      expect(controller.get('typeTagToGroupMap')['type1///tag1'].get('name')).to.equal('group1');
    });
  });

  describe('#loadServiceConfigHostsOverrides()', function () {

    beforeEach(function () {
      sinon.stub(controller, "constructUrlParams", function(){
        return controller.get('testUrlParams');
      });
      sinon.spy(App.ajax, "send");
    });
    afterEach(function () {
      controller.constructUrlParams.restore();
      App.ajax.send.restore();
    });

    it('configKeyToConfigMap and urlParams are empty', function () {
      var serviceConfigs = [];
      controller.set('testUrlParams', []);
      controller.loadServiceConfigHostsOverrides(serviceConfigs);
      expect(controller.get('configKeyToConfigMap')).to.eql({});
      expect(App.ajax.send.called).to.be.false;
    });

    it('configKeyToConfigMap and urlParams are correct', function () {
      var serviceConfigs = [{
        name: 'config1'
      }];
      controller.set('testUrlParams', ['params']);
      controller.loadServiceConfigHostsOverrides(serviceConfigs);
      expect(controller.get('configKeyToConfigMap')).to.eql({'config1': {
        name: 'config1'
      }});
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#loadServiceConfigHostsOverridesSuccessCallback()', function () {

    beforeEach(function () {
      sinon.spy(App.config, "handleSpecialProperties");
    });
    afterEach(function () {
      App.config.handleSpecialProperties.restore();
    });
    it('data.items is empty', function () {
      var data = {
        items: [
          {
            type: 'type1',
            tag: 'tag1',
            properties: {'prop1': 'value1'}
          }
        ]
      };
      controller.set('typeTagToGroupMap', {'type1///tag1': {}});
      controller.set('configKeyToConfigMap', {'prop1': {}});
      controller.loadServiceConfigHostsOverridesSuccessCallback(data);
      expect(App.config.handleSpecialProperties.calledWith({
        value: 'value1',
        isOriginalSCP: false,
        group: {}
      })).to.be.true;
    });
  });
});

});

;require.register("test/controllers/main/host/details_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/host/details');
require('models/service');
require('models/host_component');
var batchUtils = require('utils/batch_scheduled_requests');


describe('App.MainHostDetailsController', function () {

  var controller = App.MainHostDetailsController.create({
    getSecurityStatus: function () {
      return this.get('mockSecurityStatus');
    },
    mockSecurityStatus: false
  });

  describe('#serviceActiveComponents', function () {

    it('No host-components', function () {
      controller.set('content.hostComponents', []);
      expect(controller.get('serviceActiveComponents')).to.be.empty;
    });

    it('No host-components in active state', function () {
      controller.set('content.hostComponents', [Em.Object.create({
        service: {
          isInPassive: true
        }
      })]);
      expect(controller.get('serviceActiveComponents')).to.be.empty;
    });
    it('Host-components in active state', function () {
      controller.set('content.hostComponents', [Em.Object.create({
        service: {
          isInPassive: false
        }
      })]);
      expect(controller.get('serviceActiveComponents')).to.eql([Em.Object.create({
        service: {
          isInPassive: false
        }
      })]);
    });
  });

  describe('#serviceNonClientActiveComponents', function () {

    it('No active host-components', function () {
      controller.reopen({
        serviceActiveComponents: []
      });
      controller.set('serviceActiveComponents', []);
      expect(controller.get('serviceNonClientActiveComponents')).to.be.empty;
    });

    it('Active host-component is client', function () {
      controller.set('serviceActiveComponents', [Em.Object.create({
        isClient: true
      })]);
      expect(controller.get('serviceNonClientActiveComponents')).to.be.empty;
    });
    it('Active host-component is not client', function () {
      controller.set('serviceActiveComponents', [Em.Object.create({
        isClient: false
      })]);
      expect(controller.get('serviceNonClientActiveComponents')).to.eql( [Em.Object.create({
        isClient: false
      })]);
    });
  });

  describe('#startComponent()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "sendStartComponentCommand", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.sendStartComponentCommand.restore();
    });

    it('popup should be displayed', function () {
      var popup = controller.startComponent({context: Em.Object.create({'displayName': 'Comp1'})});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.sendStartComponentCommand.calledOnce).to.be.true;
    });
  });

  describe('#sendStartComponentCommand()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, "send", Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('Query should be sent', function () {
      var component = Em.Object.create({
        componentName: 'comp1'
      });
      controller.sendStartComponentCommand(component, '');
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#getDataToSend()', function () {
    var component = Em.Object.create({
      componentName: 'comp1',
      host: {
        hostName: 'host1'
      },
      service: {
        serviceName: 'serv1'
      }
    });
    it('should return correct query info', function () {
      controller.set("content.hostName", "host1");
      expect(controller.getDataToSend('STATE1', 'context', component)).to.deep.eql({
        RequestInfo: {
          "context": 'context',
          "operation_level": {
            "cluster_name": "tdk",
            "host_name": "host1",
            "hostcomponent_name": "comp1",
            "service_name": "serv1",
            "level": "HOST_COMPONENT"
          }
        },
        Body: {
          HostRoles: {
            state: 'STATE1'
          }
        }
      });
      expect(controller.getDataToSend('STATE1', 'context', [component])).to.deep.eql({
        RequestInfo: {
          "context": 'context',
          "operation_level": {
            "cluster_name": "tdk",
            "host_name": "host1",
            "level": "HOST"
          }
        },
        Body: {
          HostRoles: {
            state: 'STATE1'
          }
        }
      });
    });
  });

  describe('#setComponentToData()', function () {
    var testCases = [
      {
        title: 'dataToSend is null',
        content: {
          data: {},
          dataToSend: null,
          component: {}
        },
        result: {
          output: false,
          data: {}
        }
      },
      {
        title: 'component is null',
        content: {
          data: {},
          dataToSend: {},
          component: null
        },
        result: {
          output: false,
          data: {}
        }
      },
      {
        title: 'data is null',
        content: {
          data: null,
          dataToSend: {},
          component: {}
        },
        result: {
          output: false,
          data: null
        }
      },
      {
        title: 'component is object',
        content: {
          data: {},
          dataToSend: {},
          component: Em.Object.create({componentName: 'comp1'})
        },
        result: {
          output: true,
          data: {
            componentName: 'comp1',
            data: '{}'
          }
        }
      },
      {
        title: 'component is array',
        content: {
          data: {},
          dataToSend: {RequestInfo: {}},
          component: [Em.Object.create({componentName: 'comp1'})]
        },
        result: {
          output: true,
          data: {
            data: '{\"RequestInfo\":{\"query\":\"HostRoles/component_name.in(comp1)\"}}'
          }
        }
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.setComponentToData(test.content.data, test.content.dataToSend, test.content.component)).to.equal(test.result.output);
        expect(test.content.data).to.eql(test.result.data);
      });
    });
  });

  describe('#deleteComponent()', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, "show");
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('confirm popup should be displayed', function () {
      var event = {
        context: Em.Object.create({})
      };
      controller.deleteComponent(event);
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });
  });

  describe('#_doDeleteHostComponent()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, "send", Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('delete request should be sent, component is null', function () {
      controller.set('_deletedHostComponentResult', null);
      expect(controller._doDeleteHostComponent()).to.equal(null);
      expect(App.ajax.send.calledOnce).to.be.true;
    });
    it('delete request should be sent, component is correct', function () {
      controller.set('_deletedHostComponentResult', {});
      expect(controller._doDeleteHostComponent(Em.Object.create({componentName: 'COMP1'}))).to.eql({});
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#mimicWorkStatusChange()', function () {

    var clock;
    beforeEach(function () {
      clock = sinon.useFakeTimers();
    });
    afterEach(function () {
      clock.restore()
    });

    it('change status of object', function () {
      var entity = Em.Object.create({
        workStatus: ''
      });
      controller.mimicWorkStatusChange(entity, 'STATE1', 'STATE2');
      expect(entity.get('workStatus')).to.equal('STATE1');
      clock.tick(App.testModeDelayForActions);
      expect(entity.get('workStatus')).to.equal('STATE2');
    });
    it('change status of objects in array', function () {
      var entity = [Em.Object.create({
        workStatus: ''
      })];
      controller.mimicWorkStatusChange(entity, 'STATE1', 'STATE2');
      expect(entity[0].get('workStatus')).to.equal('STATE1');
      clock.tick(App.testModeDelayForActions);
      expect(entity[0].get('workStatus')).to.equal('STATE2');
    });
  });

  describe('#upgradeComponent()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(App.ajax, "send", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      App.ajax.send.restore();
    });

    it('confirm popup should be displayed', function () {
      var popup = controller.upgradeComponent({context: Em.Object.create()});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#stopComponent()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "sendStopComponentCommand", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.sendStopComponentCommand.restore();
    });

    it('popup should be displayed', function () {
      var popup = controller.stopComponent({context: Em.Object.create({'displayName': 'Comp1'})});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.sendStopComponentCommand.calledOnce).to.be.true;
    });
  });

  describe('#sendStopComponentCommand()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, "send", Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('Query should be sent', function () {
      var component = Em.Object.create({
        componentName: 'comp1'
      });
      controller.sendStopComponentCommand(component, '');
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#restartComponent()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(batchUtils, "restartHostComponents", Em.K);
    });

    afterEach(function () {
      App.showConfirmationPopup.restore();
      batchUtils.restartHostComponents.restore();
    });

    it('popup should be displayed', function () {
      var popup = controller.restartComponent({context: Em.Object.create({'displayName': 'Comp1'})});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(batchUtils.restartHostComponents.calledOnce).to.be.true;
    });
  });

  describe('#addComponent()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "addClientComponent", Em.K);
      sinon.stub(controller, "primary", Em.K);
    });

    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.addClientComponent.restore();
      controller.primary.restore();
    });

    it('add ZOOKEEPER_SERVER', function () {
      var event = {context: Em.Object.create({
        componentName: 'ZOOKEEPER_SERVER'
      })};
      var popup = controller.addComponent(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.primary.calledWith(Em.Object.create({
        componentName: 'ZOOKEEPER_SERVER'
      }))).to.be.true;
    });
    it('add slave component, securityEnabled = true', function () {
      var event = {context: Em.Object.create({
        componentName: 'COMP1'
      })};
      controller.set('mockSecurityStatus', true);
      var popup = controller.addComponent(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.primary.calledWith(Em.Object.create({
        componentName: 'COMP1'
      }))).to.be.true;
    });
    it('add slave component, securityEnabled = false', function () {
      var event = {context: Em.Object.create({
        componentName: 'COMP1'
      })};
      controller.set('mockSecurityStatus', false);
      controller.addComponent(event);
      expect(controller.addClientComponent.calledWith(Em.Object.create({
        componentName: 'COMP1'
      }))).to.be.true;
    });
    it('add CLIENTS', function () {
      var event = {context: Em.Object.create({
        componentName: 'CLIENTS'
      })};
      controller.set('mockSecurityStatus', true);
      controller.addComponent(event);
      expect(controller.addClientComponent.calledWith(Em.Object.create({
        componentName: 'CLIENTS'
      }))).to.be.true;
    });
  });

  describe('#formatClientsMessage()', function () {
    var testCases = [
      {
        title: 'subComponentNames is null',
        client: Em.Object.create({
          subComponentNames: null,
          displayName: 'CLIENTS'
        }),
        result: 'CLIENTS'
      },
      {
        title: 'subComponentNames is empty',
        client: Em.Object.create({
          subComponentNames: [],
          displayName: 'CLIENTS'
        }),
        result: 'CLIENTS'
      },
      {
        title: 'displayName is null',
        client: Em.Object.create({
          subComponentNames: ['DATANODE'],
          displayName: null
        }),
        result: ' (DataNode)'
      },
      {
        title: 'displayName is CLIENTS',
        client: Em.Object.create({
          subComponentNames: ['DATANODE'],
          displayName: 'CLIENTS'
        }),
        result: 'CLIENTS (DataNode)'
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.formatClientsMessage(test.client)).to.equal(test.result);
      });
    });
  });

  describe('#addClientComponent()', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, "show");
      sinon.stub(controller, "primary", Em.K);
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
      controller.primary.restore();
    });

    it('not CLIENT component', function () {
      var component = Em.Object.create({'componentName': 'Comp1'});
      var popup = controller.addClientComponent(component);
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.primary.calledWith(Em.Object.create({'componentName': 'Comp1'}))).to.be.true;
    });
    it('CLIENT components, with empty subComponentNames', function () {
      var component = Em.Object.create({
        componentName: 'CLIENTS',
        subComponentNames: []
      });
      var popup = controller.addClientComponent(component);
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.primary.calledOnce).to.be.false;
    });
    it('CLIENT components, with two sub-component', function () {
      var component = Em.Object.create({
        componentName: 'CLIENTS',
        subComponentNames: ['DATANODE', 'TASKTRACKER']
      });
      var popup = controller.addClientComponent(component);
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.primary.calledTwice).to.be.true;
    });
  });

  describe('#primary()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, "send", Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('Query should be sent', function () {
      var component = Em.Object.create({
        componentName: 'COMP1',
        displayName: 'comp1'
      });
      controller.primary(component);
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#addNewComponentSuccessCallback()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, "send", Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('Query should be sent', function () {
      controller.addNewComponentSuccessCallback({}, {}, {component: Em.Object.create()});
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#installNewComponentSuccessCallback()', function () {

    beforeEach(function () {
      sinon.stub(controller, "showBackgroundOperationsPopup", Em.K);
    });
    afterEach(function () {
      controller.showBackgroundOperationsPopup.restore();
    });

    it('data.Requests is null', function () {
      var data = {Requests: null};
      expect(controller.installNewComponentSuccessCallback(data, {}, {})).to.be.false;
      expect(controller.showBackgroundOperationsPopup.called).to.be.false;
    });
    it('data.Requests.id is null', function () {
      var data = {Requests: {id: null}};
      expect(controller.installNewComponentSuccessCallback(data, {}, {})).to.be.false;
      expect(controller.showBackgroundOperationsPopup.called).to.be.false;
    });
    it('data.Requests.id is correct', function () {
      var data = {Requests: {id: 1}};
      expect(controller.installNewComponentSuccessCallback(data, {}, {component: []})).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#refreshComponentConfigs()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "sendRefreshComponentConfigsCommand", Em.K);
    });

    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.sendRefreshComponentConfigsCommand.restore();
    });

    it('popup should be displayed', function () {
      var popup = controller.refreshComponentConfigs({context: Em.Object.create({'displayName': 'Comp1'})});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.sendRefreshComponentConfigsCommand.calledOnce).to.be.true;
    });
  });

  describe('#sendRefreshComponentConfigsCommand()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, "send", Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('Query should be sent', function () {
      var component = Em.Object.create({
        service: {},
        componentName: 'COMP1',
        host: {}
      });
      controller.sendRefreshComponentConfigsCommand(component, {});
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#loadConfigs()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, "send", Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('Query should be sent', function () {
      controller.loadConfigs();
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#constructConfigUrlParams()', function () {

    it('URL params should be empty', function () {
      var data = {};
      App.Service.find().clear();
      expect(controller.constructConfigUrlParams(data)).to.eql([]);
    });
    it('isHaEnabled = true', function () {
      var data = {Clusters: {desired_configs: {'core-site': {tag: 1}}}};
      App.HostComponent.find().clear();
      App.set('currentStackVersion', 'HDP-2.0.2');
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=core-site&tag=1)']);
      App.store.load(App.HostComponent, {
        id: 'SECONDARY_NAMENODE_host1',
        component_name: 'SECONDARY_NAMENODE'
      });
      App.set('currentStackVersion', 'HDP-2.0.1');
    });
    it('HBASE is installed', function () {
      App.store.load(App.Service, {
        id: 'HBASE',
        service_name: 'HBASE'
      });
      var data = {Clusters: {desired_configs: {'hbase-site': {tag: 1}}}};
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=hbase-site&tag=1)']);
      App.Service.find().clear();
    });
    it('HIVE is installed', function () {
      App.store.load(App.Service, {
        id: 'HIVE',
        service_name: 'HIVE'
      });
      var data = {Clusters: {desired_configs: {'webhcat-site': {tag: 1}}}};
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=webhcat-site&tag=1)']);
      App.Service.find().clear();
    });
    it('STORM is installed', function () {
      App.store.load(App.Service, {
        id: 'STORM',
        service_name: 'STORM'
      });
      var data = {Clusters: {desired_configs: {'storm-site': {tag: 1}}}};
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=storm-site&tag=1)']);
      App.Service.find().clear();
    });
  });

  describe('#loadConfigsSuccessCallback()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, "send", Em.K);
      sinon.stub(controller, "constructConfigUrlParams", function () {
        return this.get('mockUrlParams');
      });
    });
    afterEach(function () {
      App.ajax.send.restore();
      controller.constructConfigUrlParams.restore();
    });

    it('url params is empty', function () {
      controller.set('mockUrlParams', []);
      expect(controller.loadConfigsSuccessCallback()).to.be.false;
      expect(App.ajax.send.called).to.be.false;
    });
    it('url params are correct', function () {
      controller.set('mockUrlParams', ['param1']);
      expect(controller.loadConfigsSuccessCallback()).to.be.true;
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#saveZkConfigs()', function () {

    beforeEach(function () {
      sinon.stub(controller, "getZkServerHosts", Em.K);
      sinon.stub(controller, "concatZkNames", Em.K);
      sinon.stub(controller, "setZKConfigs", Em.K);
      sinon.spy(App.ajax, "send");
    });
    afterEach(function () {
      controller.getZkServerHosts.restore();
      controller.concatZkNames.restore();
      controller.setZKConfigs.restore();
      App.ajax.send.restore();
    });

    it('data.items is empty', function () {
      var data = {items: []};
      controller.saveZkConfigs(data);
      expect(App.ajax.send.called).to.be.false;
    });
    it('data.items has one item', function () {
      var data = {items: [
        {
          type: 'type1',
          properties: {}
        }
      ]};
      controller.saveZkConfigs(data);
      expect(App.ajax.send.calledOnce).to.be.true;
    });
    it('data.items has two items', function () {
      var data = {items: [
        {
          type: 'type1',
          properties: {}
        },
        {
          type: 'type2',
          properties: {}
        }
      ]};
      controller.saveZkConfigs(data);
      expect(App.ajax.send.calledTwice).to.be.true;
    });
  });

  describe('#setZKConfigs()', function () {

    it('configs is null', function () {
      expect(controller.setZKConfigs(null)).to.be.false;
    });
    it('zks is null', function () {
      expect(controller.setZKConfigs({}, '', null)).to.be.false;
    });
    it('isHaEnabled = true', function () {
      var configs = {'core-site': {}};
      App.HostComponent.find().clear();
      App.set('currentStackVersion', 'HDP-2.0.2');
      expect(controller.setZKConfigs(configs, 'host1:2181', [])).to.be.true;
      expect(configs).to.eql({"core-site": {
        "ha.zookeeper.quorum": "host1:2181"
      }});
      App.store.load(App.HostComponent, {
        id: 'SECONDARY_NAMENODE_host1',
        component_name: 'SECONDARY_NAMENODE'
      });
      App.set('currentStackVersion', 'HDP-2.0.1');
    });
    it('hbase-site is present', function () {
      var configs = {'hbase-site': {}};
      expect(controller.setZKConfigs(configs, '', ['host1', 'host2'])).to.be.true;
      expect(configs).to.eql({"hbase-site": {
        "hbase.zookeeper.quorum": "host1,host2"
      }});
    });
    it('webhcat-site is present', function () {
      var configs = {'webhcat-site': {}};
      expect(controller.setZKConfigs(configs, 'host1:2181', [])).to.be.true;
      expect(configs).to.eql({"webhcat-site": {
        "templeton.zookeeper.hosts": "host1:2181"
      }});
    });
    it('storm-site is present', function () {
      var configs = {'storm-site': {}};
      expect(controller.setZKConfigs(configs, '', ["host1", 'host2'])).to.be.true;
      expect(configs).to.eql({"storm-site": {
        "storm.zookeeper.servers": "['host1','host2']"
      }});
    });
  });

  describe('#concatZkNames()', function () {
    it('No ZooKeeper hosts', function () {
      expect(controller.concatZkNames([])).to.equal('');
    });
    it('One ZooKeeper host', function () {
      expect(controller.concatZkNames(['host1'])).to.equal('host1:2181');
    });
    it('Two ZooKeeper hosts', function () {
      expect(controller.concatZkNames(['host1', 'host2'])).to.equal('host1:2181,host2:2181');
    });
  });

  describe('#getZkServerHosts()', function () {
    controller.set('content', {});

    it('No ZooKeeper hosts, fromDeleteHost = false', function () {
      App.HostComponent.find().clear();
      controller.set('fromDeleteHost', false);
      expect(controller.getZkServerHosts()).to.be.empty;
    });
    it('No ZooKeeper hosts, fromDeleteHost = true', function () {
      controller.set('fromDeleteHost', true);
      expect(controller.getZkServerHosts()).to.be.empty;
      expect(controller.get('fromDeleteHost')).to.be.false;
    });
    it('One ZooKeeper host, fromDeleteHost = false', function () {
      controller.set('fromDeleteHost', false);
      App.store.load(App.HostComponent, {
        id: 'ZOOKEEPER_SERVER_host1',
        component_name: 'ZOOKEEPER_SERVER',
        host_id: 'host1'
      });
      expect(controller.getZkServerHosts()).to.eql(['host1']);
    });
    it('One ZooKeeper host match current host name, fromDeleteHost = true', function () {
      controller.set('fromDeleteHost', true);
      controller.set('content.hostName', 'host1');
      expect(controller.getZkServerHosts()).to.be.empty;
      expect(controller.get('fromDeleteHost')).to.be.false;
    });
    it('One ZooKeeper host does not match current host name, fromDeleteHost = true', function () {
      controller.set('fromDeleteHost', true);
      controller.set('content.hostName', 'host2');
      expect(controller.getZkServerHosts()[0]).to.equal("host1");
      expect(controller.get('fromDeleteHost')).to.be.false;
    });
  });

  describe('#installComponent()', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, "show");
      sinon.stub(App.ajax, "send", Em.K);
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
      App.ajax.send.restore();
    });

    it('popup should be displayed', function () {
      var event = {context: Em.Object.create()};
      var popup = controller.installComponent(event);
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onPrimary();
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#decommission()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "runDecommission", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.runDecommission.restore();
    });

    it('popup should be displayed', function () {
      var popup = controller.decommission(Em.Object.create({service: {}}));
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.runDecommission.calledOnce).to.be.true;
    });
  });

  describe('#runDecommission()', function () {

    beforeEach(function () {
      sinon.stub(controller, "doDecommission", Em.K);
      sinon.stub(controller, "showBackgroundOperationsPopup", Em.K);
      sinon.stub(controller, "doDecommissionRegionServer", Em.K);
    });

    afterEach(function () {
      controller.doDecommissionRegionServer.restore();
      controller.doDecommission.restore();
      controller.showBackgroundOperationsPopup.restore();
    });

    it('HDFS service', function () {
      controller.runDecommission('host1', 'HDFS');
      expect(controller.doDecommission.calledWith('host1', 'HDFS', "NAMENODE", "DATANODE")).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('YARN service', function () {
      controller.runDecommission('host1', 'YARN');
      expect(controller.doDecommission.calledWith('host1', 'YARN', "RESOURCEMANAGER", "NODEMANAGER")).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('MAPREDUCE service', function () {
      controller.runDecommission('host1', 'MAPREDUCE');
      expect(controller.doDecommission.calledWith('host1', 'MAPREDUCE', "JOBTRACKER", "TASKTRACKER")).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('HBASE service', function () {
      controller.runDecommission('host1', 'HBASE');
      expect(controller.doDecommissionRegionServer.calledWith('host1', 'HBASE', "HBASE_MASTER", "HBASE_REGIONSERVER")).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#runRecommission()', function () {

    beforeEach(function () {
      sinon.stub(controller, "doRecommissionAndStart", Em.K);
      sinon.stub(controller, "doRecommissionAndRestart", Em.K);
      sinon.stub(controller, "showBackgroundOperationsPopup", Em.K);
    });

    afterEach(function () {
      controller.doRecommissionAndStart.restore();
      controller.doRecommissionAndRestart.restore();
      controller.showBackgroundOperationsPopup.restore();
    });

    it('HDFS service', function () {
      controller.runRecommission('host1', 'HDFS');
      expect(controller.doRecommissionAndStart.calledWith('host1', 'HDFS', "NAMENODE", "DATANODE")).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('YARN service', function () {
      controller.runRecommission('host1', 'YARN');
      expect(controller.doRecommissionAndStart.calledWith('host1', 'YARN', "RESOURCEMANAGER", "NODEMANAGER")).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('MAPREDUCE service', function () {
      controller.runRecommission('host1', 'MAPREDUCE');
      expect(controller.doRecommissionAndRestart.calledWith('host1', 'MAPREDUCE', "JOBTRACKER", "TASKTRACKER")).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('HBASE service', function () {
      controller.runRecommission('host1', 'HBASE');
      expect(controller.doRecommissionAndStart.calledWith('host1', 'HBASE', "HBASE_MASTER", "HBASE_REGIONSERVER")).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#doDecommission()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, "send", Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('Query should be sent', function () {
      controller.doDecommission('', '', '', '');
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#doDecommissionRegionServer()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, "send", Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('Query should be sent', function () {
      controller.doDecommissionRegionServer('', '', '', '');
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  /**
   * TODO uncomment test when final rules will be implemented into warnBeforeDecommission function
   */
 /* describe('#warnBeforeDecommission()', function () {

    beforeEach(function () {
      sinon.stub(controller, "doDecommissionRegionServer", Em.K);
      sinon.stub(App.ModalPopup, "show", Em.K);
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
      controller.doDecommissionRegionServer.restore();
    });

    it('Component in passive state', function () {
      controller.set('content.hostComponents', [Em.Object.create({
        componentName: 'HBASE_REGIONSERVER',
        passiveState: 'ON'
      })]);
      controller.warnBeforeDecommission('host1', 'HBASE', 'HBASE_REGIONSERVER', 'SLAVE');
      expect(App.ModalPopup.show.called).to.be.false;
      expect(controller.doDecommissionRegionServer.calledWith('host1', 'HBASE', 'HBASE_REGIONSERVER', 'SLAVE')).to.be.true;
    });
    it('Component is not in passive state', function () {
      controller.set('content.hostComponents', [Em.Object.create({
        componentName: 'HBASE_REGIONSERVER',
        passiveState: 'OFF'
      })]);
      controller.warnBeforeDecommission('host1', 'HBASE', 'HBASE_REGIONSERVER', 'SLAVE');
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      expect(controller.doDecommissionRegionServer.called).to.be.false;
    });
  });*/

  describe('#doRecommissionAndStart()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, "send", Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('Query should be sent', function () {
      controller.doRecommissionAndStart('', '', '', '');
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#decommissionSuccessCallback()', function () {

    beforeEach(function () {
      sinon.stub(controller, "showBackgroundOperationsPopup", Em.K);
    });
    afterEach(function () {
      controller.showBackgroundOperationsPopup.restore();
    });

    it('data is null', function () {
      expect(controller.decommissionSuccessCallback(null)).to.be.false;
      expect(controller.showBackgroundOperationsPopup.called).to.be.false;
    });
    it('data has Requests', function () {
      var data = {Requests: []};
      expect(controller.decommissionSuccessCallback(data)).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('data has resources', function () {
      var data = {resources: [{RequestSchedule: {}}]};
      expect(controller.decommissionSuccessCallback(data)).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#doRecommissionAndRestart()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, "send", Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('Query should be sent', function () {
      controller.doRecommissionAndRestart('', '', '', '');
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#doAction()', function () {

    beforeEach(function () {
      sinon.stub(controller, "validateAndDeleteHost", Em.K);
      sinon.stub(controller, "doStartAllComponents", Em.K);
      sinon.stub(controller, "doStopAllComponents", Em.K);
      sinon.stub(controller, "doRestartAllComponents", Em.K);
      sinon.stub(controller, "onOffPassiveModeForHost", Em.K);
    });

    afterEach(function () {
      controller.validateAndDeleteHost.restore();
      controller.doStartAllComponents.restore();
      controller.doStopAllComponents.restore();
      controller.doRestartAllComponents.restore();
      controller.onOffPassiveModeForHost.restore();
    });

    it('"deleteHost" action', function () {
      var option = {context: {action: "deleteHost"}};
      controller.doAction(option);
      expect(controller.validateAndDeleteHost.calledOnce).to.be.true;
    });
    it('"startAllComponents" action, isNotHeartBeating = false', function () {
      var option = {context: {action: "startAllComponents"}};
      controller.set('content.isNotHeartBeating', false);
      controller.doAction(option);
      expect(controller.doStartAllComponents.calledOnce).to.be.true;
    });
    it('"startAllComponents" action, isNotHeartBeating = true', function () {
      var option = {context: {action: "startAllComponents"}};
      controller.set('content.isNotHeartBeating', true);
      controller.doAction(option);
      expect(controller.doStartAllComponents.called).to.be.false;
    });
    it('"stopAllComponents" action, isNotHeartBeating = false', function () {
      var option = {context: {action: "stopAllComponents"}};
      controller.set('content.isNotHeartBeating', false);
      controller.doAction(option);
      expect(controller.doStopAllComponents.calledOnce).to.be.true;
    });
    it('"stopAllComponents" action, isNotHeartBeating = true', function () {
      var option = {context: {action: "stopAllComponents"}};
      controller.set('content.isNotHeartBeating', true);
      controller.doAction(option);
      expect(controller.doStopAllComponents.called).to.be.false;
    });
    it('"restartAllComponents" action, isNotHeartBeating = false', function () {
      var option = {context: {action: "restartAllComponents"}};
      controller.set('content.isNotHeartBeating', false);
      controller.doAction(option);
      expect(controller.doRestartAllComponents.calledOnce).to.be.true;
    });
    it('"restartAllComponents" action, isNotHeartBeating = true', function () {
      var option = {context: {action: "restartAllComponents"}};
      controller.set('content.isNotHeartBeating', true);
      controller.doAction(option);
      expect(controller.doRestartAllComponents.called).to.be.false;
    });
    it('"onOffPassiveModeForHost" action', function () {
      var option = {context: {action: "onOffPassiveModeForHost"}};
      controller.doAction(option);
      expect(controller.onOffPassiveModeForHost.calledWith({action: "onOffPassiveModeForHost"})).to.be.true;
    });
  });

  describe('#onOffPassiveModeForHost()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "hostPassiveModeRequest", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.hostPassiveModeRequest.restore();
    });

    it('popup should be displayed, active = true', function () {
      var popup = controller.onOffPassiveModeForHost({active: true});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.hostPassiveModeRequest.calledWith('ON')).to.be.true;
    });
    it('popup should be displayed, active = false', function () {
      var popup = controller.onOffPassiveModeForHost({active: false});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.hostPassiveModeRequest.calledWith('OFF')).to.be.true;
    });
  });

  describe('#hostPassiveModeRequest()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, "send", Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('Query should be sent', function () {
      controller.hostPassiveModeRequest('', '');
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#doStartAllComponents()', function () {

    beforeEach(function () {
      sinon.stub(App, "showConfirmationPopup", Em.K);
      sinon.stub(controller, "sendStartComponentCommand", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.sendStartComponentCommand.restore();
    });

    it('serviceNonClientActiveComponents is null', function () {
      controller.reopen({
        serviceNonClientActiveComponents: []
      });
      controller.set('serviceNonClientActiveComponents', null);
      controller.doStartAllComponents();
      expect(App.showConfirmationPopup.called).to.be.false;
    });
    it('serviceNonClientActiveComponents is empty', function () {
      controller.set('serviceNonClientActiveComponents', []);
      controller.doStartAllComponents();
      expect(App.showConfirmationPopup.called).to.be.false;
    });
    it('serviceNonClientActiveComponents is correct', function () {
      controller.set('serviceNonClientActiveComponents', [{}]);
      var popup = controller.doStartAllComponents();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      /*popup.onPrimary();
      expect(controller.sendStartComponentCommand.calledWith([{}])).to.be.true;*/
    });
  });

  describe('#doStopAllComponents()', function () {

    beforeEach(function () {
      sinon.stub(App, "showConfirmationPopup", Em.K);
      sinon.stub(controller, "sendStartComponentCommand", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.sendStartComponentCommand.restore();
    });

    it('serviceNonClientActiveComponents is null', function () {
      controller.set('serviceNonClientActiveComponents', null);
      controller.doStopAllComponents();
      expect(App.showConfirmationPopup.called).to.be.false;
    });
    it('serviceNonClientActiveComponents is empty', function () {
      controller.set('serviceNonClientActiveComponents', []);
      controller.doStopAllComponents();
      expect(App.showConfirmationPopup.called).to.be.false;
    });
    it('serviceNonClientActiveComponents is correct', function () {
      controller.set('serviceNonClientActiveComponents', [{}]);
      var popup = controller.doStopAllComponents();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      /*popup.onPrimary();
      expect(controller.sendStopComponentCommand.calledWith([{}])).to.be.true;*/
    });
  });

  describe('#doRestartAllComponents()', function () {

    beforeEach(function () {
      sinon.stub(App, "showConfirmationPopup", Em.K);
      sinon.stub(controller, "sendStartComponentCommand", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.sendStartComponentCommand.restore();
    });

    it('serviceActiveComponents is null', function () {
      controller.set('serviceActiveComponents', null);
      controller.doRestartAllComponents();
      expect(App.showConfirmationPopup.called).to.be.false;
    });
    it('serviceActiveComponents is empty', function () {
      controller.set('serviceActiveComponents', []);
      controller.doRestartAllComponents();
      expect(App.showConfirmationPopup.called).to.be.false;
    });
    it('serviceActiveComponents is correct', function () {
      controller.set('serviceActiveComponents', [{}]);
      var popup = controller.doRestartAllComponents();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      /*popup.onPrimary();
       expect(controller.restartHostComponents.calledWith([{}])).to.be.true;*/
    });
  });

  describe('#getHostComponentsInfo()', function () {

    var result = {
      zkServerInstalled: false,
      lastComponents: [],
      masterComponents: [],
      runningComponents: [],
      nonDeletableComponents: [],
      unknownComponents: []
    };

    it('content.hostComponents is null', function () {
      controller.set('content.hostComponents', null);
      expect(controller.getHostComponentsInfo()).to.eql(result);
    });
    it('content.hostComponents is empty', function () {
      controller.set('content.hostComponents', []);
      expect(controller.getHostComponentsInfo()).to.eql(result);
    });
    it('content.hostComponents has ZOOKEEPER_SERVER', function () {
      App.HostComponent.find().clear();
      controller.set('content.hostComponents', [Em.Object.create({
        componentName: 'ZOOKEEPER_SERVER',
        workStatus: 'INIT',
        isDeletable: true
      })]);
      expect(controller.getHostComponentsInfo().zkServerInstalled).to.be.true;
    });
    it('content.hostComponents has last component', function () {
      App.store.load(App.HostComponent, {
        id: 'TASKTRACKER_host1',
        component_name: 'TASKTRACKER'
      });
      controller.set('content.hostComponents', [Em.Object.create({
        componentName: 'TASKTRACKER',
        displayName: 'TaskTracker',
        workStatus: 'INIT',
        isDeletable: true
      })]);
      expect(controller.getHostComponentsInfo().lastComponents).to.eql(['TaskTracker']);
      App.HostComponent.find().clear();
    });
    it('content.hostComponents has master non-deletable component', function () {
      controller.set('content.hostComponents', [Em.Object.create({
        componentName: 'TASKTRACKER',
        workStatus: 'INIT',
        isDeletable: false,
        isMaster: true,
        displayName: 'ZK1'
      })]);
      expect(controller.getHostComponentsInfo().masterComponents).to.eql(['ZK1']);
      expect(controller.getHostComponentsInfo().nonDeletableComponents).to.eql(['ZK1']);
    });
    it('content.hostComponents has running component', function () {
      controller.set('content.hostComponents', [Em.Object.create({
        componentName: 'TASKTRACKER',
        workStatus: 'STARTED',
        isDeletable: true,
        displayName: 'ZK1'
      })]);
      expect(controller.getHostComponentsInfo().runningComponents).to.eql(['ZK1']);
    });
    it('content.hostComponents has non-deletable component', function () {
      controller.set('content.hostComponents', [Em.Object.create({
        componentName: 'TASKTRACKER',
        workStatus: 'INIT',
        isDeletable: false,
        displayName: 'ZK1'
      })]);
      expect(controller.getHostComponentsInfo().nonDeletableComponents).to.eql(['ZK1']);
    });
    it('content.hostComponents has component with UNKNOWN state', function () {
      controller.set('content.hostComponents', [Em.Object.create({
        componentName: 'TASKTRACKER',
        workStatus: 'UNKNOWN',
        isDeletable: false,
        displayName: 'ZK1'
      })]);
      expect(controller.getHostComponentsInfo().unknownComponents).to.eql(['ZK1']);
    });
  });

  describe('#validateAndDeleteHost()', function () {

    beforeEach(function () {
      sinon.stub(App, "showConfirmationPopup", Em.K);
      sinon.stub(controller, "getHostComponentsInfo", function(){
        return this.get('mockHostComponentsInfo');
      });
      sinon.stub(controller, "raiseDeleteComponentsError", Em.K);
      sinon.stub(controller, "_doDeleteHost", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.getHostComponentsInfo.restore();
      controller.raiseDeleteComponentsError.restore();
      controller._doDeleteHost.restore();
    });

    it('App.supports.deleteHost = false', function () {
      App.supports.deleteHost = false;
      expect(controller.validateAndDeleteHost()).to.be.false;
      App.supports.deleteHost = true;
    });
    it('masterComponents exist', function () {
      controller.set('mockHostComponentsInfo', {masterComponents: [{}]});
      controller.validateAndDeleteHost();
      expect(controller.raiseDeleteComponentsError.calledWith([{}], 'masterList')).to.be.true;
    });
    it('nonDeletableComponents exist', function () {
      controller.set('mockHostComponentsInfo', {
        masterComponents: [],
        nonDeletableComponents: [{}]
      });
      controller.validateAndDeleteHost();
      expect(controller.raiseDeleteComponentsError.calledWith([{}], 'nonDeletableList')).to.be.true;
    });
    it('runningComponents exist', function () {
      controller.set('mockHostComponentsInfo', {
        masterComponents: [],
        nonDeletableComponents: [],
        runningComponents: [{}]
      });
      controller.validateAndDeleteHost();
      expect(controller.raiseDeleteComponentsError.calledWith([{}], 'runningList')).to.be.true;
    });
    it('zkServerInstalled = true', function () {
      controller.set('mockHostComponentsInfo', {
        masterComponents: [],
        nonDeletableComponents: [],
        runningComponents: [],
        unknownComponents: [],
        lastComponents: [],
        zkServerInstalled: true
      });
      var popup = controller.validateAndDeleteHost();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
     /* popup.onPrimary();
      expect(controller._doDeleteHost.calledWith([], [])).to.be.true;*/
    });
    it('zkServerInstalled = false', function () {
      controller.set('mockHostComponentsInfo', {
        masterComponents: [],
        nonDeletableComponents: [],
        runningComponents: [],
        unknownComponents: [],
        lastComponents: [],
        zkServerInstalled: false
      });
      controller.validateAndDeleteHost();
      expect(controller._doDeleteHost.calledWith([], [])).to.be.true;
    });
  });

  describe('#raiseDeleteComponentsError()', function () {

    beforeEach(function () {
      sinon.stub(App.ModalPopup, "show", Em.K);
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('Popup should be displayed', function () {
      controller.raiseDeleteComponentsError([], '');
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });
  });

  describe('#_doDeleteHost()', function () {

    beforeEach(function () {
      sinon.stub(App.ModalPopup, "show", Em.K);
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('Popup should be displayed', function () {
      controller._doDeleteHost([], []);
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });
  });

  describe('#restartAllStaleConfigComponents()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(batchUtils, "restartHostComponents", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      batchUtils.restartHostComponents.restore();
    });

    it('popup should be displayed', function () {
      controller.set('content.componentsWithStaleConfigs', [{}]);
      var popup = controller.restartAllStaleConfigComponents();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(batchUtils.restartHostComponents.calledWith([{}])).to.be.true;
    });
  });

  describe('#moveComponent()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
    });

    it('popup should be displayed', function () {
      var popup = controller.moveComponent();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
    });
  });

  describe('#refreshConfigs()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(batchUtils, "restartHostComponents", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      batchUtils.restartHostComponents.restore();
    });

    it('No components', function () {
      var event = {context: []};
      controller.refreshConfigs(event);
      expect(App.showConfirmationPopup.called).to.be.false;
    });
    it('No components with stale configs', function () {
      var event = {context: [Em.Object.create({
        staleConfigs: false
      })]};
      controller.refreshConfigs(event);
      expect(App.showConfirmationPopup.called).to.be.false;
    });
    it('Components with stale configs', function () {
      var event = {context: [Em.Object.create({
        staleConfigs: true
      })]};
      var popup = controller.refreshConfigs(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(batchUtils.restartHostComponents.calledWith([Em.Object.create({
        staleConfigs: true
      })])).to.be.true;
    });
  });
});
});

;require.register("test/controllers/main/host_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var validator = require('utils/validator');
require('utils/component');
require('utils/batch_scheduled_requests');
require('controllers/main/host');
require('mappers/server_data_mapper');

describe('MainHostController', function () {

  var hostController;

  // @todo add unit tests after bulk ops reimplementing
  describe.skip('#bulkOperation', function() {

    beforeEach(function() {
      hostController = App.MainHostController.create({
        bulkOperationForHostsRestart: function(){},
        bulkOperationForHosts: function(){},
        bulkOperationForHostComponentsRestart: function(){},
        bulkOperationForHostComponentsDecommission: function(){},
        bulkOperationForHostComponents: function(){},
        bulkOperationForHostsPassiveState: function(){}
      });
      sinon.spy(hostController, 'bulkOperationForHostsRestart');
      sinon.spy(hostController, 'bulkOperationForHosts');
      sinon.spy(hostController, 'bulkOperationForHostComponentsRestart');
      sinon.spy(hostController, 'bulkOperationForHostComponentsDecommission');
      sinon.spy(hostController, 'bulkOperationForHostComponents');
      sinon.spy(hostController, 'bulkOperationForHostsPassiveState');
    });

    afterEach(function() {
      hostController.bulkOperationForHosts.restore();
      hostController.bulkOperationForHostsRestart.restore();
      hostController.bulkOperationForHostComponentsRestart.restore();
      hostController.bulkOperationForHostComponentsDecommission.restore();
      hostController.bulkOperationForHostComponents.restore();
      hostController.bulkOperationForHostsPassiveState.restore();

    });

    it('RESTART for hosts', function() {
      var operationData = {
        action: 'RESTART'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostsRestart.calledOnce).to.equal(true);
    });

    it('START for hosts', function() {
      var operationData = {
        action: 'STARTED'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHosts.calledOnce).to.equal(true);
    });

    it('STOP for hosts', function() {
      var operationData = {
        action: 'INSTALLED'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHosts.calledOnce).to.equal(true);
    });

    it('PASSIVE_STATE for hosts', function() {
      var operationData = {
        action: 'PASSIVE_STATE'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostsPassiveState.calledOnce).to.equal(true);
    });

    it('RESTART for hostComponents', function() {
      var operationData = {
        action: 'RESTART',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponentsRestart.calledOnce).to.equal(true);
    });

    it('START for hostComponents', function() {
      var operationData = {
        action: 'STARTED',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponents.calledOnce).to.equal(true);
    });

    it('STOP for hostComponents', function() {
      var operationData = {
        action: 'INSTALLED',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponents.calledOnce).to.equal(true);
    });

    it('DECOMMISSION for hostComponents', function() {
      var operationData = {
        action: 'DECOMMISSION',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponentsDecommission.calledOnce).to.equal(true);
    });

    it('RECOMMISSION for hostComponents', function() {
      var operationData = {
        action: 'DECOMMISSION_OFF',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponentsDecommission.calledOnce).to.equal(true);
    });

  });

  // @todo add unit tests after bulk ops reimplementing
  describe.skip('#bulkOperationForHosts', function() {

    beforeEach(function(){
      hostController = App.MainHostController.create({});
      sinon.spy($, 'ajax');
    });

    afterEach(function() {
      $.ajax.restore();
    });

    var tests = [
      {
        operationData: {},
        hosts: [],
        m: 'no hosts',
        e: false
      },
      {
        operationData: {
          actionToCheck: 'STARTED'
        },
        hosts: [
          Em.Object.create({
            hostComponents: Em.A([
              Em.Object.create({isMaster: true, isSlave: false, host: {hostName:'host1'}, workStatus: 'STARTED', componentName: 'NAMENODE', passiveState: 'OFF'}),
              Em.Object.create({isMaster: false, isSlave: true, host: {hostName:'host1'}, workStatus: 'STARTED', componentName: 'DATANODE', passiveState: 'OFF'})
            ])
          })
        ],
        m: '1 host. components are in proper state',
        e: true
      },
      {
        operationData: {
          actionToCheck: 'INSTALLED'
        },
        hosts: [
          Em.Object.create({
            hostComponents: Em.A([
              Em.Object.create({isMaster: true, isSlave: false, host: {hostName:'host1'}, workStatus: 'STARTED', componentName: 'NAMENODE', passiveState: 'OFF'}),
              Em.Object.create({isMaster: false, isSlave: true, host: {hostName:'host1'}, workStatus: 'STARTED', componentName: 'DATANODE', passiveState: 'OFF'})
            ])
          })
        ],
        m: '1 host. components are not in proper state',
        e: false
      },
      {
        operationData: {
          actionToCheck: 'INSTALLED'
        },
        hosts: [
          Em.Object.create({
            hostComponents: Em.A([
              Em.Object.create({isMaster: true, isSlave: false, host: {hostName:'host1'}, workStatus: 'INSTALLED', componentName: 'NAMENODE', passiveState: 'OFF'}),
              Em.Object.create({isMaster: false, isSlave: true, host: {hostName:'host1'}, workStatus: 'STARTED', componentName: 'DATANODE', passiveState: 'OFF'})
            ])
          })
        ],
        m: '1 host. some components are in proper state',
        e: true
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        hostController.bulkOperationForHosts(test.operationData, test.hosts);
        expect($.ajax.called).to.equal(test.e);
      });
    });

  });

  // @todo add unit tests after bulk ops reimplementing
  describe.skip('#bulkOperationForHostsRestart', function() {

    beforeEach(function(){
      hostController = App.MainHostController.create({});
      sinon.spy($, 'ajax');
    });

    afterEach(function() {
      $.ajax.restore();
    });

    var tests = Em.A([
      {
        hosts: Em.A([]),
        m: 'No hosts',
        e: false
      },
      {
        hosts: Em.A([
          Em.Object.create({
            hostComponents: Em.A([Em.Object.create({passiveState: 'OFF'}), Em.Object.create({passiveState: 'OFF'})])
          })
        ]),
        m: 'One host',
        e: true
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        hostController.bulkOperationForHostsRestart({}, test.hosts);
        expect($.ajax.calledOnce).to.equal(test.e)
      });
    });

  });

  // @todo add unit tests after bulk ops reimplementing
  describe.skip('#bulkOperationForHostsPassiveState', function() {

    beforeEach(function(){
      hostController = App.MainHostController.create({});
      sinon.spy($, 'ajax');
    });

    afterEach(function() {
      $.ajax.restore();
    });

    var tests = [
      {
        hosts: Em.A([]),
        operationData: {},
        m: 'No hosts',
        e: false
      },
      {
        hosts: Em.A([
          Em.Object.create({
            passiveState: 'OFF'
          })
        ]),
        operationData: {
          state: 'OFF'
        },
        m: 'One host, but in state that should get',
        e: false
      },
      {
        hosts: Em.A([
          Em.Object.create({
            passiveState: 'OFF'
          })
        ]),
        operationData: {
          state: 'ON'
        },
        m: 'One host with proper state',
        e: true
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        hostController.bulkOperationForHostsPassiveState(test.operationData, test.hosts);
        expect($.ajax.calledOnce).to.equal(test.e)
      });
    });

  });

  describe('#getRegExp()', function() {
    before(function() {
      hostController = App.MainHostController.create({});
    });

    var message = '`{0}` should convert to `{1}`',
        tests = [
      { value: '.*', expected: '.*' },
      { value: '.', expected: '.*' },
      { value: '.*.*', expected: '.*' },
      { value: '*', expected: '^$' },
      { value: '........', expected: '.*' },
      { value: '........*', expected: '.*' },
      { value: 'a1', expected: '.*a1.*' },
      { value: 'a1.', expected: '.*a1.*' },
      { value: 'a1...', expected: '.*a1.*' },
      { value: 'a1.*', expected: '.*a1.*' },
      { value: 'a1.*.a2.a3', expected: '.*a1.*.a2.a3.*' },
      { value: 'a1.*.a2...a3', expected: '.*a1.*.a2...a3.*' }
    ]

    tests.forEach(function(test){
      it(message.format(test.value, test.expected), function() {
        expect(hostController.getRegExp(test.value)).to.be.equal(test.expected);
      });
    });
  });

});

});

;require.register("test/controllers/main/jobs/hive_job_details_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var jobsUtils = require('utils/jobs');
require('models/service/yarn');
require('mappers/jobs/hive_job_mapper');
require('utils/ajax/ajax');
require('utils/http_client');
require('models/jobs/tez_dag');
require('controllers/main/jobs/hive_job_details_controller');

describe('App.MainHiveJobDetailsController', function () {
  var yarnService = {
    id: 'YARN',
    ahsWebPort: 8188
  };
  App.store.load(App.YARNService, yarnService);
  var job = {
    id: 'hrt_qa_20140311131919_1d932567-71c2-4341-9b50-6df1f58a9114',
    queryText: 'show tables',
    name: 'hrt_qa_20140311131919_1d932567-71c2-4341-9b50-6df1f58a9114',
    user: ['hrt_qa'],
    hasTezDag: true,
    failed: false,
    startTime: 1394569191001,
    jobType: 'hive',
    tezDag: {
      id: 'hrt_qa_20140311131919_1d932567-71c2-4341-9b50-6df1f58a9114:1',
      instanceId: 'dag_1394502141829_0425_1',
      name: 'hrt_qa_20140311131919_1d932567-71c2-4341-9b50-6df1f58a9114:1',
      yarnApplicationId: 'application_1395263571423_0014',
      stage: 'Stage-1'
    }
  };
  var mainHiveJobDetailsController = App.MainHiveJobDetailsController.create({
    job: Ember.Object.create(job),
    content: {
      id: 'id'
    }
  });
  mainHiveJobDetailsController.set('job', mainHiveJobDetailsController.get('content'));
  describe('#loaded', function () {
    it('content loading from model', function () {
      jobsUtils.refreshHiveJobDetails = function (hiveJob, successCallback, errorCallback) {
        successCallback();
      };
      mainHiveJobDetailsController.loadJobDetails();
      expect(mainHiveJobDetailsController.get('loaded')).to.equal(true);
      expect(mainHiveJobDetailsController.get('content.id')).to.equal(mainHiveJobDetailsController.get('job.id'));
    });
  });
});

});

;require.register("test/controllers/main/jobs_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('mappers/jobs/hive_jobs_mapper');
require('models/service/yarn');
require('models/jobs/job');
require('models/jobs/hive_job');
require('controllers/main/jobs_controller');

describe('App.MainJobsController', function () {
  var mainJobsController = App.MainJobsController.create();
  var filterObject = mainJobsController.get('filterObject');
  describe('#totalOfJobs', function () {
    it('should be equal to content.length', function () {
      mainJobsController.set('content', [
        Ember.Object.create({
          id: 'id0',
          queryText: 'show tables',
          name: 'id0',
          user: ['user1'],
          hasTezDag: true,
          failed: false,
          startTime: 1393443850756,
          endTime: 1393443875265,
          tezDagId: 'id0:1'
        })
      ]);
      expect(mainJobsController.get('totalOfJobs')).to.equal(1);
    });
  });
  describe('#sortingDone', function () {
    it('should be true after automatically ran sorting', function () {
      expect(mainJobsController.get('sortingDone')).to.equal(true);
    });
  });
  describe('#sortProperty', function () {
    it('should change according to sortingColumn.name', function () {
      mainJobsController.set('sortingColumn').set('name', 'id');
      expect(mainJobsController.get('sortProperty')).to.equal('id');
    });
  });
  describe('#sortAscending', function () {
    it('sorting should be ascending as default', function () {
      mainJobsController.set('sortingColumn').set('status', '');
      expect(mainJobsController.get('sortAscending')).to.equal(true);
    });
  });
  describe('#filterObject.isIdFilterApplied', function () {
    it('should be true if id field is not empty', function () {
      filterObject.set('id', 'some_id');
      expect(filterObject.get('isIdFilterApplied')).to.equal(true);
    });
  });
  describe('#filterObject.isAnyFilterApplied', function () {
    it('should be true if id field is not empty', function () {
      filterObject.createJobsFiltersLink();
      expect(filterObject.get('isAnyFilterApplied')).to.equal(true);
    });
  });
  describe('#sortedContent', function () {
    it('sorting by different properties', function () {
      mainJobsController.get('content').push(Ember.Object.create({
        id: 'id1',
        queryText: 'show tables',
        name: 'id1',
        user: ['user0'],
        failed: false,
        startTime: 1393443850757,
        endTime: 1393443875264,
        tezDagId: null
      }));
      mainJobsController.contentAndSortUpdater();
      expect(mainJobsController.get('sortedContent')[0].get('user')).to.eql(['user1']);
      mainJobsController.toggleProperty('sortAscending');
      mainJobsController.contentAndSortUpdater();
      expect(mainJobsController.get('sortedContent')[0].get('user')).to.eql(['user0']);
      mainJobsController.set('sortProperty', 'user');
      mainJobsController.contentAndSortUpdater();
      expect(mainJobsController.get('sortedContent')[0].get('id')).to.equal('id0');
      mainJobsController.get('content').push(Ember.Object.create({
        id: 'id2',
        queryText: 'show tables',
        name: 'id2',
        user: ['user2'],
        failed: false,
        startTime: 1393443850758,
        endTime: 1393443875263,
        tezDagId: null
      }));
      mainJobsController.contentAndSortUpdater();
      mainJobsController.set('sortProperty', 'startTime');
      expect(mainJobsController.get('sortedContent')[0].get('id')).to.equal('id2');
      mainJobsController.set('sortProperty', 'endTime');
      mainJobsController.contentAndSortUpdater();
      expect(mainJobsController.get('sortedContent')[0].get('id')).to.equal('id0');
      mainJobsController.set('sortProperty', 'duration');
      mainJobsController.toggleProperty('sortAscending');
      mainJobsController.contentAndSortUpdater();
      expect(mainJobsController.get('sortedContent')[0].get('user')).to.eql(['user1']);
    });
  });
});

});

;require.register("test/controllers/main/mirroring/edit_dataset_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/mirroring/edit_dataset_controller');
require('models/target_cluster');
require('views/main/mirroring/edit_dataset_view');

describe('App.MainMirroringEditDataSetController', function () {

  describe('#clearStep', function () {
    it('should clear all fields, error flags and messages', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      var errors = mainMirroringEditDataSetController.get('errors');
      var errorMessages = mainMirroringEditDataSetController.get('errorMessages');
      var formFeilds = mainMirroringEditDataSetController.get('formFields');
      formFeilds.set('datasetName', 'test');
      sinon.spy(mainMirroringEditDataSetController, 'clearErrors');
      mainMirroringEditDataSetController.clearStep();
      expect(mainMirroringEditDataSetController.clearErrors.calledOnce).to.be.true;
      Em.keys(formFeilds).forEach(function (field) {
        expect(formFeilds[field]).to.be.null;
      });
      mainMirroringEditDataSetController.clearErrors.restore();
    });
  });

  describe('#clearErrors', function () {
    it('should clear all error messages and flags', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      var errors = mainMirroringEditDataSetController.get('errors');
      var errorMessages = mainMirroringEditDataSetController.get('errorMessages');
      Em.keys(errors).forEach(function (error) {
        errors[error] = true;
      }, this);
      Em.keys(errorMessages).forEach(function (errorMessage) {
        errorMessages[errorMessage] = 'test';
      }, this);
      mainMirroringEditDataSetController.clearErrors();
      Em.keys(errors).forEach(function (error) {
        expect(errors[error]).to.be.false;
      });
      Em.keys(errorMessages).forEach(function (errorMessage) {
        expect(errorMessages[errorMessage]).to.be.empty;
      });
    });
  });

  describe('#showAddPopup', function () {
    it('should show popup and set isEdit as false', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      sinon.spy(App.ModalPopup, 'show');
      mainMirroringEditDataSetController.showAddPopup();
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      expect(mainMirroringEditDataSetController.get('isEdit')).to.be.false;
      App.ModalPopup.show.restore();
    });
  });

  describe('#showEditPopup', function () {
    it('should show popup,set isEdit as true and set dataset id', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      var dataset = Ember.Object.create({
        id: 'test'
      });
      sinon.spy(App.ModalPopup, 'show');
      mainMirroringEditDataSetController.showEditPopup(dataset);
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      expect(mainMirroringEditDataSetController.get('isEdit')).to.be.true;
      expect(mainMirroringEditDataSetController.get('datasetIdToEdit')).to.equal('test');
      App.ModalPopup.show.restore();
    });
  });

  describe('#showPopup', function () {
    it('should show dataset popup and save its view', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      sinon.spy(App.ModalPopup, 'show');
      mainMirroringEditDataSetController.showPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      expect(mainMirroringEditDataSetController.get('popup')).to.not.be.empty;
      App.ModalPopup.show.restore();
    });
  });

  describe('#applyValidation', function () {
    it('should add observers to all fields to validate form', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      sinon.spy(mainMirroringEditDataSetController, 'validate');
      mainMirroringEditDataSetController.applyValidation();
      expect(mainMirroringEditDataSetController.validate.calledOnce).to.be.true;
      Em.keys(mainMirroringEditDataSetController.get('formFields')).forEach(function (field) {
        expect(mainMirroringEditDataSetController.hasObserverFor('formFields.' + field)).to.be.true;
      });
      mainMirroringEditDataSetController.validate.restore();
    });
  });

  var testCases = [
    {
      day: '01/01/2001',
      hours: '00',
      minutes: '00',
      middayPeriod: 'AM',
      result: new Date('01/01/2001 00:00 AM'),
      message: 'should return date object'
    },
    {
      day: '06/05/2014',
      hours: '12',
      minutes: '59',
      middayPeriod: 'PM',
      result: new Date('06/05/2014 12:59 PM'),
      message: 'should return date object'
    },
    {
      day: '',
      hours: '00',
      minutes: '00',
      middayPeriod: 'AM',
      result: null,
      message: 'should return null if there are empty fields'
    }
  ];

  describe('#scheduleStartDate', function () {
    testCases.forEach(function (test) {
      it(test.message, function () {
        var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create({
          formFields: Ember.Object.create({
            datasetStartDate: test.day,
            hoursForStart: test.hours,
            minutesForStart: test.minutes,
            middayPeriodForStart: test.middayPeriod
          })
        });
        expect(mainMirroringEditDataSetController.get('scheduleStartDate')).to.deep.equal(test.result);
      });
    });
  });

  describe('#scheduleEndDate', function () {
    testCases.forEach(function (test) {
      it(test.message, function () {
        var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create({
          formFields: Ember.Object.create({
            datasetEndDate: test.day,
            hoursForEnd: test.hours,
            minutesForEnd: test.minutes,
            middayPeriodForEnd: test.middayPeriod
          })
        });
        expect(mainMirroringEditDataSetController.get('scheduleEndDate')).to.deep.equal(test.result);
      });
    });
  });

  var formFields = Ember.Object.create({
    datasetName: 'test',
    datasetTargetClusterName: 'test',
    datasetSourceDir: '/test',
    datasetTargetDir: '/test',
    datasetStartDate: '01/19/2038',
    hoursForStart: '03',
    minutesForStart: '15',
    middayPeriodForStart: 'AM',
    datasetEndDate: '01/19/2039',
    hoursForEnd: '03',
    minutesForEnd: '15',
    middayPeriodForEnd: 'AM',
    datasetFrequency: '1',
    repeatOptionSelected: 'days'
  })

  describe('#validate', function () {
    it('should set an error for empty fields', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      mainMirroringEditDataSetController.validate();
      var errors = mainMirroringEditDataSetController.get('errors');
      var errorMessages = mainMirroringEditDataSetController.get('errorMessages');
      Em.keys(errors).forEach(function (error) {
        expect(errors[error]).to.be.true;
      });
      Em.keys(errorMessages).forEach(function (errorMessage) {
        expect(errorMessages[errorMessage]).to.equal(Em.I18n.t('mirroring.required.error'));
      });
    });
    it('should set an error if start date is after end date', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      var formFields = mainMirroringEditDataSetController.get('formFields');
      formFields.set('datasetStartDate', '04/07/2014');
      formFields.set('hoursForStart', '11');
      formFields.set('minutesForStart', '00');
      formFields.set('middayPeriodForStart', 'PM');
      formFields.set('datasetEndDate', '04/07/2014');
      formFields.set('hoursForEnd', '11');
      formFields.set('minutesForEnd', '00');
      formFields.set('middayPeriodForEnd', 'AM');
      mainMirroringEditDataSetController.validate();
      expect(mainMirroringEditDataSetController.get('errors.isEndDateError')).to.be.true;
      expect(mainMirroringEditDataSetController.get('errorMessages.endDate')).to.equal(Em.I18n.t('mirroring.dateOrder.error'));
    });
    it('should set an error if start date is in the past', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      var formFields = mainMirroringEditDataSetController.get('formFields');
      formFields.set('datasetStartDate', '04/07/2014');
      formFields.set('hoursForStart', '11');
      formFields.set('minutesForStart', '00');
      formFields.set('middayPeriodForStart', 'AM');
      mainMirroringEditDataSetController.validate();
      expect(mainMirroringEditDataSetController.get('errors.isStartDateError')).to.be.true;
      expect(mainMirroringEditDataSetController.get('errorMessages.startDate')).to.equal(Em.I18n.t('mirroring.startDate.error'));
    });
    it('should set an error if repeat field value consist not only form digits', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      var formFields = mainMirroringEditDataSetController.get('formFields');
      formFields.set('datasetFrequency', 'test');
      mainMirroringEditDataSetController.validate();
      expect(mainMirroringEditDataSetController.get('errors.isFrequencyError')).to.be.true;
      expect(mainMirroringEditDataSetController.get('errorMessages.frequency')).to.equal(Em.I18n.t('mirroring.required.invalidNumberError'));
      formFields.set('datasetFrequency', '100test');
      mainMirroringEditDataSetController.validate();
      expect(mainMirroringEditDataSetController.get('errors.isFrequencyError')).to.be.true;
      expect(mainMirroringEditDataSetController.get('errorMessages.frequency')).to.equal(Em.I18n.t('mirroring.required.invalidNumberError'));
    });
    it('should not set errors if all fields are filled correctly', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create({
        formFields: formFields
      });
      mainMirroringEditDataSetController.validate();
      var errors = mainMirroringEditDataSetController.get('errors');
      var errorMessages = mainMirroringEditDataSetController.get('errorMessages');
      Em.keys(errors).forEach(function (error) {
        expect(errors[error]).to.be.false;
      });
      Em.keys(errorMessages).forEach(function (errorMessage) {
        expect(errorMessages[errorMessage]).to.be.empty;
      });
    });
  });

  describe('#addZero', function () {
    it('should add 0 for numbers less than 10', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      expect(mainMirroringEditDataSetController.addZero(1)).to.equal('01');
      expect(mainMirroringEditDataSetController.addZero(9)).to.equal('09');
      expect(mainMirroringEditDataSetController.addZero(0)).to.equal('00');
    });
    it('should not add 0 for numbers greater than 9', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      expect(mainMirroringEditDataSetController.addZero(10)).to.equal('10');
      expect(mainMirroringEditDataSetController.addZero(99)).to.equal('99');
    });
  });

  describe('#toTZFormat', function () {
    it('should convert date to TZ format', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      expect(mainMirroringEditDataSetController.toTZFormat(new Date(Date.UTC(2014, 0, 1, 1, 1)))).to.equal('2014-01-01T01:01Z');
      expect(mainMirroringEditDataSetController.toTZFormat(new Date(Date.UTC(2014, 11, 31, 23, 59)))).to.equal('2014-12-31T23:59Z');
    });
  });

  describe('#toAMPMHours', function () {
    it('should convert time to 12-hours format', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      expect(mainMirroringEditDataSetController.toAMPMHours(13)).to.equal('01');
      expect(mainMirroringEditDataSetController.toAMPMHours(20)).to.equal('08');
      expect(mainMirroringEditDataSetController.toAMPMHours(24)).to.equal('12');
      expect(mainMirroringEditDataSetController.toAMPMHours(0)).to.equal('12');
    });
    it('should not convert time if argument is less than 12', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      expect(mainMirroringEditDataSetController.toAMPMHours(1)).to.equal('01');
      expect(mainMirroringEditDataSetController.toAMPMHours(8)).to.equal('08');
      expect(mainMirroringEditDataSetController.toAMPMHours(11)).to.equal('11');
    });
  });

  describe('#save', function () {
    it('should create XML and send it to server', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create({
        popup: Ember.Object.create({
          isSaving: false
        })
      });
      sinon.spy(mainMirroringEditDataSetController, 'createDatasetXML');
      sinon.spy(mainMirroringEditDataSetController, 'sendDatasetToServer');
      mainMirroringEditDataSetController.save();
      expect(mainMirroringEditDataSetController.createDatasetXML.calledOnce).to.be.true;
      expect(mainMirroringEditDataSetController.sendDatasetToServer.calledOnce).to.be.true;
      expect(mainMirroringEditDataSetController.get('popup.isSaving')).to.be.true;
      mainMirroringEditDataSetController.createDatasetXML.restore();
      mainMirroringEditDataSetController.sendDatasetToServer.restore();
    });
  });

  describe('#createDatasetXML', function () {
    it('should create XML-fromatted data', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create({
        formFields: formFields
      });
      var startDate = new Date('01/19/2038 03:15 AM').toISOString().replace(/\:\d{2}\.\d{3}/, '');
      var endDate = new Date('01/19/2039 03:15 AM').toISOString().replace(/\:\d{2}\.\d{3}/, '');
      var expectedResult = '<?xml version="1.0"?><feed description="" name="' + App.mirroringDatasetNamePrefix + 'test" xmlns="uri:falcon:feed:0.1"><frequency>days(1)' +
          '</frequency><clusters><cluster name="' + App.get('clusterName') + '" type="source"><validity start="' + startDate + '" end="' + endDate +
          '"/><retention limit="days(7)" action="delete"/></cluster><cluster name="test" type="target"><validity start="' + startDate + '" end="' + endDate +
          '"/><retention limit="months(1)" action="delete"/><locations><location type="data" path="/test" /></locations></cluster></clusters><locations><location type="data" path="' +
          '/test" /></locations><ACL owner="hue" group="users" permission="0755" /><schema location="/none" provider="none"/></feed>';
      var result = mainMirroringEditDataSetController.createDatasetXML();
      expect(result).to.equal(expectedResult);
    });
  });

  describe('#sendDatasetToServer', function () {
    var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create({
      formFields: formFields
    });
    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });
    it('should send data with correct dataset name', function () {
      mainMirroringEditDataSetController.sendDatasetToServer('test');
      expect(App.ajax.send.args[0][0].data.name).to.equal(App.mirroringDatasetNamePrefix + formFields.datasetName);
    });
    it('should send data from param', function () {
      mainMirroringEditDataSetController.sendDatasetToServer('test');
      expect(App.ajax.send.args[0][0].data.entity).to.equal('test');
    });
    it('should use edit request if isEdit is true', function () {
      mainMirroringEditDataSetController.set('isEdit', true);
      mainMirroringEditDataSetController.sendDatasetToServer('test');
      expect(App.ajax.send.args[0][0].name).to.equal('mirroring.update_entity');
    });
    it('should use create request if isEdit is false', function () {
      mainMirroringEditDataSetController.set('isEdit', false);
      mainMirroringEditDataSetController.sendDatasetToServer('test');
      expect(App.ajax.send.args[0][0].name).to.equal('mirroring.create_new_dataset');
    });
  });

  describe('#onSaveSuccess', function () {
    it('should hide popup and load data', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create({
        popup: Ember.Object.create({
          isSaving: true,
          hide: function () {
          }
        })
      });
      App.router.set('mainMirroringController', Ember.Object.create({
        loadData: function () {
        }
      }));
      sinon.spy(mainMirroringEditDataSetController.get('popup'), 'hide');
      sinon.spy(App.router.get('mainMirroringController'), 'loadData');
      mainMirroringEditDataSetController.onSaveSuccess();
      expect(mainMirroringEditDataSetController.get('popup.isSaving')).to.be.false;
      expect(App.router.get('mainMirroringController').loadData.calledOnce).to.be.true;
      expect(mainMirroringEditDataSetController.get('popup').hide.calledOnce).to.be.true;
      mainMirroringEditDataSetController.get('popup').hide.restore();
      App.router.get('mainMirroringController').loadData.restore();
    });
  });

  describe('#onSaveError', function () {
    var mainMirroringEditDataSetController;
    beforeEach(function () {
      mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create({
        popup: Ember.Object.create({
          isSaving: true
        })
      });
      sinon.stub(App, 'showAlertPopup', Em.K);
    });
    afterEach(function () {
      App.showAlertPopup.restore();
    });
    it('shouldn\'t show error popup and enable button', function () {
      mainMirroringEditDataSetController.onSaveError(null);
      expect(App.showAlertPopup.calledOnce).to.be.false;
      expect(mainMirroringEditDataSetController.get('popup.isSaving')).to.be.false;
    });
    it('should show error popup and enable button', function () {
      mainMirroringEditDataSetController.onSaveError({responseText: '<message>test</message>'});
      expect(App.showAlertPopup.args[0][1]).to.be.equal(Em.I18n.t('mirroring.manageClusters.error') + ': test');
      expect(mainMirroringEditDataSetController.get('popup.isSaving')).to.be.false;
    });
  });

  describe('#saveDisabled', function () {
    it('should return false if there are no errors', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create({});
      expect(mainMirroringEditDataSetController.get('saveDisabled')).to.be.false;
    });
    it('should return true if there are some errors', function () {
      var mainMirroringEditDataSetController = App.MainMirroringEditDataSetController.create();
      mainMirroringEditDataSetController.set('errors.isNameError', true);
      expect(mainMirroringEditDataSetController.get('saveDisabled')).to.be.true;
    });
  });
});

});

;require.register("test/controllers/main/service/add_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/wizard');
require('controllers/main/service/add_controller');
var addServiceController = null;

describe('App.AddServiceController', function() {

  beforeEach(function () {
    addServiceController = App.AddServiceController.create({});
  });

  describe('#isServiceConfigurable', function() {
    var tests = [
      {
        services: [
          {serviceName: 'HDFS'},
          {serviceName: 'MAPREDUCE'},
          {serviceName: 'NAGIOS'}
        ],
        service: 'HDFS',
        m: 'Service is configurable',
        e: true
      },
      {
        services: [
          {serviceName: 'HDFS'},
          {serviceName: 'MAPREDUCE'},
          {serviceName: 'NAGIOS'}
        ],
        service: 'PIG',
        m: 'Service is not configurable',
        e: false
      },
      {
        services: [],
        service: 'HDFS',
        m: 'No services',
        e: false
      }
    ];
    tests.forEach(function(test) {
      var controller = App.AddServiceController.create({serviceConfigs: test.services});
      it('', function() {
        expect(controller.isServiceConfigurable(test.service)).to.equal(test.e);
      });
    });
  });

  describe('#skipConfigStep', function() {
    var tests = [
      {
        content: {
          services:[
            {serviceName: 'HDFS', isInstalled: true, isSelected: true},
            {serviceName: 'PIG', isInstalled: false, isSelected: true},
            {serviceName: 'MAPREDUCE', isInstalled: true, isSelected: true}
          ]
        },
        serviceConfigs: [
          {serviceName: 'HDFS'},
          {serviceName: 'MAPREDUCE'},
          {serviceName: 'NAGIOS'}
        ],
        m: '2 installed services and 1 new that can\'t be configured',
        e: true
      },
      {
        content: {
          services:[
            {serviceName: 'HDFS', isInstalled: true, isSelected: true},
            {serviceName: 'NAGIOS', isInstalled: false, isSelected: true},
            {serviceName: 'MAPREDUCE', isInstalled: true, isSelected: true}
          ]
        },
        serviceConfigs: [
          {serviceName: 'HDFS'},
          {serviceName: 'MAPREDUCE'},
          {serviceName: 'NAGIOS'}
        ],
        m: '2 installed services and 1 new that can be configured',
        e: false
      },
      {
        content: {
          services:[
            {serviceName: 'HDFS', isInstalled: true, isSelected: true},
            {serviceName: 'PIG', isInstalled: false, isSelected: true},
            {serviceName: 'SQOOP', isInstalled: false, isSelected: true},
            {serviceName: 'MAPREDUCE', isInstalled: true, isSelected: true}
          ]
        },
        serviceConfigs: [
          {serviceName: 'HDFS'},
          {serviceName: 'MAPREDUCE'},
          {serviceName: 'NAGIOS'}
        ],
        m: '2 installed services and 2 new that can\'t be configured',
        e: true
      }
    ];
    tests.forEach(function(test) {
      var controller = App.AddServiceController.create({content:{services: test.content.services}, serviceConfigs: test.serviceConfigs});
      it(test.m, function() {
        expect(controller.skipConfigStep()).to.equal(test.e);
      })
    });
  });

  describe('#installAdditionalClients', function() {

    var t = {
      additionalClients: {
        componentName: "TEZ_CLIENT",
        hostName: "hostName"
      },
      RequestInfo: {
        "context": Em.I18n.t('requestInfo.installHostComponent') + " hostName"
      },
      Body: {
        HostRoles: {
          state: 'INSTALLED'
        }
      }
    };

    beforeEach(function () {
      sinon.spy($, 'ajax');
    });

    afterEach(function () {
      $.ajax.restore();
    });

    it('send request to install client', function () {
      addServiceController.set("content.additionalClients", [t.additionalClients]);
      addServiceController.installAdditionalClients();
      expect($.ajax.calledOnce).to.equal(true);

      expect(JSON.parse($.ajax.args[0][0].data).Body).to.deep.eql(t.Body);
      expect(JSON.parse($.ajax.args[0][0].data).RequestInfo).to.eql(t.RequestInfo);
    });
  });

});

});

;require.register("test/controllers/main/service/info/config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/service/info/configs');
var batchUtils = require('utils/batch_scheduled_requests');
var mainServiceInfoConfigsController = null;
describe("App.MainServiceInfoConfigsController", function () {

  beforeEach(function () {
    mainServiceInfoConfigsController = App.MainServiceInfoConfigsController.create({});
  });

  describe("#showSavePopup", function () {
    var tests = [
      {
        path: false,
        event: false,
        action: "onSave",
        m: "save configs without path/event",
        results: [
          {
            method: "restartServicePopup",
            called: true
          },
          {
            method: "selectConfigGroup",
            called: false
          }
        ]
      },
      {
        path: true,
        event: true,
        action: "onSave",
        m: "save configs with path/event",
        results: [
          {
            method: "restartServicePopup",
            called: true
          },
          {
            method: "selectConfigGroup",
            called: false
          }
        ]
      },
      {
        path: false,
        event: false,
        action: "onDiscard",
        m: "discard changes without path/event",
        results: [
          {
            method: "restartServicePopup",
            called: false
          },
          {
            method: "selectConfigGroup",
            called: false
          }
        ]
      },
      {
        path: false,
        event: true,
        action: "onDiscard",
        m: "discard changes with event",
        results: [
          {
            method: "restartServicePopup",
            called: false
          },
          {
            method: "selectConfigGroup",
            called: true
          },
          {
            field: "hash",
            value: "hash"
          }
        ]
      },
      {
        path: true,
        event: false,
        action: "onDiscard",
        m: "discard changes with path",
        results: [
          {
            method: "restartServicePopup",
            called: false
          },
          {
            method: "selectConfigGroup",
            called: false
          },
          {
            field: "forceTransition",
            value: true
          }
        ]
      }
    ];

    var rRoute = App.router.route;
    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "restartServicePopup", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "selectConfigGroup", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "getHash", function () {
        return "hash"
      });
      App.router.route = Em.K;
    });
    afterEach(function () {
      mainServiceInfoConfigsController.restartServicePopup.restore();
      mainServiceInfoConfigsController.selectConfigGroup.restore();
      mainServiceInfoConfigsController.getHash.restore();
      App.router.route = rRoute;
    });

    tests.forEach(function (t) {
      t.results.forEach(function (r) {
        it(t.m + " " + r.method + " " + r.field, function () {
          mainServiceInfoConfigsController.showSavePopup(t.path, t.event)[t.action]();
          if (r.method) {
            expect(mainServiceInfoConfigsController[r.method].calledOnce).to.equal(r.called);
          } else if (r.field) {
            expect(mainServiceInfoConfigsController.get(r.field)).to.equal(r.value);
          }
        }, this);
      });
    }, this);
  });

  describe("#hasUnsavedChanges", function () {
    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "getHash", function () {
        return "hash"
      });
    });
    afterEach(function () {
      mainServiceInfoConfigsController.getHash.restore();
    });

    it("with unsaved", function () {
      mainServiceInfoConfigsController.set("hash", "hash1");
      expect(mainServiceInfoConfigsController.hasUnsavedChanges()).to.equal(true);
    });

    it("without unsaved", function () {
      mainServiceInfoConfigsController.set("hash", "hash");
      expect(mainServiceInfoConfigsController.hasUnsavedChanges()).to.equal(false);
    });
  });

  describe("#selectConfigGroup", function () {

    var tests = [
      {
        event: {
          context: "cfgGroup"
        },
        isInit: true,
        showPopup: false,
        m: "setup new cfg group"
      },
      {
        event: {
          context: "cfgGroup"
        },
        isInit: false,
        hash: "hash",
        showPopup: false,
        m: "setup new cfg group, has some changes"
      },
      {
        event: {
          context: "cfgGroup"
        },
        isInit: false,
        hash: "hash1",
        showPopup: true,
        m: "show popup, doesn't setup new cfg group"
      }
    ];

    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "showSavePopup", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "getHash", function () {
        return "hash"
      });
      sinon.stub(mainServiceInfoConfigsController, "onConfigGroupChange", Em.K);
    });
    afterEach(function () {
      mainServiceInfoConfigsController.showSavePopup.restore();
      mainServiceInfoConfigsController.getHash.restore();
      mainServiceInfoConfigsController.onConfigGroupChange.restore();
    });
    tests.forEach(function (t) {
      it(t.m, function () {
        mainServiceInfoConfigsController.set("isInit", t.isInit);
        mainServiceInfoConfigsController.set("hash", t.hash);
        mainServiceInfoConfigsController.selectConfigGroup(t.event);
        if (!t.showPopup) {
          expect(mainServiceInfoConfigsController.get("selectedConfigGroup")).to.equal(t.event.context);
          expect(mainServiceInfoConfigsController.showSavePopup.calledOnce).to.equal(false);
        } else {
          expect(mainServiceInfoConfigsController.showSavePopup.calledWith(null, t.event)).to.equal(true);
        }
      });
    });

  });

  describe("#manageConfigurationGroup", function () {
    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "manageConfigurationGroups", Em.K);
    });
    afterEach(function () {
      mainServiceInfoConfigsController.manageConfigurationGroups.restore();
    });
    it("run manageConfigurationGroups", function () {
      mainServiceInfoConfigsController.manageConfigurationGroup();
      expect(mainServiceInfoConfigsController.manageConfigurationGroups.calledOnce).to.equal(true);
    });
  });

  describe("#addOverrideProperty", function () {
    var serviceConfigProperty = Em.Object.create({
      overrides: []
    });

    var newSCP = App.ServiceConfigProperty.create(serviceConfigProperty);
    newSCP.set('value', '');
    newSCP.set('isOriginalSCP', false);
    newSCP.set('parentSCP', serviceConfigProperty);
    newSCP.set('isEditable', true);

    it("add new overridden property", function () {
      mainServiceInfoConfigsController.addOverrideProperty(serviceConfigProperty);
      expect(serviceConfigProperty.get("overrides")[0]).to.eql(newSCP);
    });
  });

  describe("#showComponentsShouldBeRestarted", function () {

    var tests = [
      {
        input: {
          'publicHostName1': ['TaskTracker'],
          'publicHostName2': ['JobTracker', 'TaskTracker']
        },
        components: "2 TaskTrackers, 1 JobTracker",
        text: Em.I18n.t('service.service.config.restartService.shouldBeRestarted').format(Em.I18n.t('common.components'))
      },
      {
        input: {
          'publicHostName1': ['TaskTracker']
        },
        components: "1 TaskTracker",
        text: Em.I18n.t('service.service.config.restartService.shouldBeRestarted').format(Em.I18n.t('common.component'))
      }
    ];

    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "showItemsShouldBeRestarted", Em.K);
      mainServiceInfoConfigsController.set("content", {restartRequiredHostsAndComponents: ""});
    });
    afterEach(function () {
      mainServiceInfoConfigsController.showItemsShouldBeRestarted.restore();
      mainServiceInfoConfigsController.set("content", undefined);
    });

    tests.forEach(function (t) {
      it("trigger showItemsShouldBeRestarted popup with components", function () {
        mainServiceInfoConfigsController.set("content.restartRequiredHostsAndComponents", t.input);
        mainServiceInfoConfigsController.showComponentsShouldBeRestarted();
        expect(mainServiceInfoConfigsController.showItemsShouldBeRestarted.calledWith(t.components, t.text)).to.equal(true);
      });
    });
  });

  describe("#showHostsShouldBeRestarted", function () {

    var tests = [
      {
        input: {
          'publicHostName1': ['TaskTracker'],
          'publicHostName2': ['JobTracker', 'TaskTracker']
        },
        hosts: "publicHostName1, publicHostName2",
        text: Em.I18n.t('service.service.config.restartService.shouldBeRestarted').format(Em.I18n.t('common.hosts'))
      },
      {
        input: {
          'publicHostName1': ['TaskTracker']
        },
        hosts: "publicHostName1",
        text: Em.I18n.t('service.service.config.restartService.shouldBeRestarted').format(Em.I18n.t('common.host'))
      }
    ];

    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "showItemsShouldBeRestarted", Em.K);
      mainServiceInfoConfigsController.set("content", {restartRequiredHostsAndComponents: ""});
    });
    afterEach(function () {
      mainServiceInfoConfigsController.showItemsShouldBeRestarted.restore();
      mainServiceInfoConfigsController.set("content", undefined);
    });

    tests.forEach(function (t) {
      it("trigger showItemsShouldBeRestarted popup with hosts", function () {
        mainServiceInfoConfigsController.set("content.restartRequiredHostsAndComponents", t.input);
        mainServiceInfoConfigsController.showHostsShouldBeRestarted();
        expect(mainServiceInfoConfigsController.showItemsShouldBeRestarted.calledWith(t.hosts, t.text)).to.equal(true);
      });
    });
  });

  describe("rollingRestartStaleConfigSlaveComponents", function () {
    var tests = [
      {
        componentName: {
          context: "ComponentName"
        },
        displayName: "displayName",
        passiveState: "ON"
      },
      {
        componentName: {
          context: "ComponentName1"
        },
        displayName: "displayName1",
        passiveState: "OFF"
      }
    ];

    beforeEach(function () {
      mainServiceInfoConfigsController.set("content", {displayName: "", passiveState: ""});
      sinon.stub(batchUtils, "launchHostComponentRollingRestart", Em.K);
    });
    afterEach(function () {
      batchUtils.launchHostComponentRollingRestart.restore();
    });
    tests.forEach(function (t) {
      it("trigger rollingRestartStaleConfigSlaveComponents", function () {
        mainServiceInfoConfigsController.set("content.displayName", t.displayName);
        mainServiceInfoConfigsController.set("content.passiveState", t.passiveState);
        mainServiceInfoConfigsController.rollingRestartStaleConfigSlaveComponents(t.componentName);
        expect(batchUtils.launchHostComponentRollingRestart.calledWith(t.componentName.context, t.displayName, t.passiveState == "ON", true)).to.equal(true);
      });
    });
  });

  describe("#restartAllStaleConfigComponents", function () {
    beforeEach(function () {
      sinon.stub(batchUtils, "restartAllServiceHostComponents", Em.K);
    });
    afterEach(function () {
      batchUtils.restartAllServiceHostComponents.restore();
    });
    it("trigger restartAllServiceHostComponents", function () {
      mainServiceInfoConfigsController.restartAllStaleConfigComponents().onPrimary();
      expect(batchUtils.restartAllServiceHostComponents.calledOnce).to.equal(true);
    });
  });

  describe("#doCancel", function () {
    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "loadStep", Em.K);
    });
    afterEach(function () {
      mainServiceInfoConfigsController.loadStep.restore();
    });
    it("trigger loadStep", function () {
      mainServiceInfoConfigsController.doCancel();
      expect(mainServiceInfoConfigsController.loadStep.calledOnce).to.equal(true);
    });
  });

  describe("#getCurrentServiceComponents", function () {
    var t = Em.Object.create({
      content: Em.Object.create({
        hostComponents: [
          Em.Object.create({
            componentName: "componentName1",
            displayName: "displayName1"
          }),
          Em.Object.create({
            componentName: "componentName2",
            displayName: "displayName2"
          })
        ]
      }),
      validComponents: Em.A([
        Em.Object.create({
          componentName: "componentName1",
          displayName: "displayName1",
          selected: false
        }),
        Em.Object.create({
          componentName: "componentName2",
          displayName: "displayName2",
          selected: false
        })
      ])
    });

    beforeEach(function () {
      mainServiceInfoConfigsController.set("content", { hostComponents: Em.A([])});
    });

    it("get current service components", function () {
      mainServiceInfoConfigsController.get("content.hostComponents").push(t.content.hostComponents[0]);
      var com = mainServiceInfoConfigsController.get("getCurrentServiceComponents");
      expect(com[0]).to.eql(t.validComponents[0]);
    });
  });

  describe("#getMasterComponentHostValue", function () {
    var tests = [
      {
        content: {
          hostComponents: [
            Em.Object.create({
              componentName: "componentName1",
              host: {
                hostName: "hostName"
              }
            })
          ]
        },
        result: "hostName",
        multiple: false,
        m: "returns hostname"
      },
      {
        content: {
          hostComponents: [
            Em.Object.create({
              componentName: "componentName2",
              host: {
                  hostName: "hostName1"
              }
            }),
            Em.Object.create({
              componentName: "componentName2",
              host: {
                hostName: "hostName2"
              }
            })
          ]
        },
        result: ["hostName1","hostName2"],
        multiple: true,
        m: "returns hostnames"
      }
    ];
    tests.forEach(function(t){
      beforeEach(function () {
        mainServiceInfoConfigsController.set("content", { hostComponents: []});
      });

      it(t.m, function () {
        mainServiceInfoConfigsController.set("content.hostComponents", t.content.hostComponents);
        expect(mainServiceInfoConfigsController.getMasterComponentHostValue(t.content.hostComponents[0].componentName, t.multiple)).to.eql(t.result);
      });
    });
  });

  describe("#setServerConfigValue", function () {

    it("parsing storm.zookeeper.servers property in non standart method", function () {
      expect(mainServiceInfoConfigsController.setServerConfigValue("storm.zookeeper.servers", ["a", "b"])).to.equal('[\'a\',\'b\']');
    });
    it("parsing content property in non standart method", function () {
      expect(mainServiceInfoConfigsController.setServerConfigValue("content", "value")).to.equal("value");
    });
    it("parsing default properties", function () {
      expect(mainServiceInfoConfigsController.setServerConfigValue("any.other.property", "value&lt;")).to.equal("value<");
    });
  });

  describe("#createSiteObj", function () {

    var tests = [
      {
        siteName: "hdfs-site",
        tagName: "version1",
        siteObj: Em.A([
          {
            name: "property1",
            value: "value1"
          },
          {
            name: "property2",
            value: "value2&lt;"
          }
        ]),
        result: {
          "type": "hdfs-site",
          "tag": "version1",
          "properties": {
            "property1": "value1",
            "property2": "value2<"
          }
        },
        m: "default"
      },
      {
        siteName: "falcon-startup.properties",
        tagName: "version1",
        siteObj: Em.A([
          {
            name: "property1",
            value: "value1"
          },
          {
            name: "property2",
            value: "value2&lt;"
          }
        ]),
        result: {
          "type": "falcon-startup.properties",
          "tag": "version1",
          "properties": {
            "property1": "value1",
            "property2": "value2&lt;"
          }
        },
        m: "for falcon-startup.properties"

      }
    ];
    tests.forEach(function (t) {
      it("create site object " + t.m, function () {
        expect(mainServiceInfoConfigsController.createSiteObj(t.siteName, t.tagName, t.siteObj)).to.deep.eql(t.result)
      });
    });
  });

  describe("#createCoreSiteObj", function () {

    var tests = [
      {
        tagName: "version1",
        uiConfigs: Em.A([
          Em.Object.create({
            name: "property1",
            value: "value1",
            filename: "core-site.xml"
          }),
          Em.Object.create({
            name: "property2",
            value: "value2&lt;",
            filename: "core-site.xml"
          })
        ]),
        result: {
          "type": "core-site",
          "tag": "version1",
          "properties": {
            "property1": "value1",
            "property2": "value2<"
          }
        }
      }
    ];
    tests.forEach(function (t) {
      it("create core object", function () {
        mainServiceInfoConfigsController.set("uiConfigs", t.uiConfigs);
        expect(mainServiceInfoConfigsController.createCoreSiteObj(t.tagName)).to.deep.eql(t.result);
      });
    });
  });

  describe("#createGlobalSiteObj", function () {

    var t = {
      tagName: "version1",
      globalConfigs: Em.A([
        Em.Object.create({
          name: "property1",
          value: "value1"
        }),
        Em.Object.create({
          name: "property2",
          value: "value2&lt;"
        }),
        Em.Object.create({
          name: "some_heapsize",
          value: "1000"
        }),
        Em.Object.create({
          name: "some_newsize",
          value: "1000"
        }),
        Em.Object.create({
          name: "some_maxnewsize",
          value: "1000"
        }),
        Em.Object.create({
          name: "hadoop_heapsize",
          value: "1000"
        })
      ]),
      result: {
        "type": "global",
        "tag": "version1",
        "properties": {
          "property1": "value1",
          "property2": "value2<",
          "some_heapsize": "1000m",
          "some_newsize": "1000m",
          "some_maxnewsize": "1000m",
          "hadoop_heapsize": "1000"
        }
      }
    };
    it("create global object", function () {
      expect(mainServiceInfoConfigsController.createGlobalSiteObj(t.tagName, t.globalConfigs)).to.deep.eql(t.result);
    });
  });

  describe("#doPUTClusterConfigurationSiteErrorCallback", function () {
    it("set doPUTClusterConfigurationSiteResult to false", function () {
      mainServiceInfoConfigsController.doPUTClusterConfigurationSiteErrorCallback({responseText: ""});
      expect(mainServiceInfoConfigsController.get("doPUTClusterConfigurationSiteResult")).to.equal(false);
    });
  });

  describe("#doPUTClusterConfigurationSiteSuccessCallback", function () {
    it("set doPUTClusterConfigurationSiteResult to true", function () {
      mainServiceInfoConfigsController.doPUTClusterConfigurationSiteSuccessCallback();
      expect(mainServiceInfoConfigsController.get("doPUTClusterConfigurationSiteResult")).to.equal(true);
    });
  });

  describe("#doPUTClusterConfigurationSite", function () {
    var t = {
      data: "data",
      request: {
        Clusters: {
          desired_config: "data"
        }
      }
    };
    var temp = App.router.getClusterName;
    beforeEach(function () {
      App.router.getClusterName = function () {
        return "clName";
      };
      sinon.spy($, "ajax");
    });
    afterEach(function () {
      $.ajax.restore();
      App.router.getClusterName = temp;
    });
    it("ajax request to put clsuter cfg", function () {
      expect(mainServiceInfoConfigsController.doPUTClusterConfigurationSite(t.data)).to.equal(mainServiceInfoConfigsController.get("doPUTClusterConfigurationSiteResult"));
      expect(JSON.parse($.ajax.args[0][0].data)).to.deep.equal(t.request);
    });
  });

  describe("#isConfigChanged", function () {

    var tests = [
      {
        loadedConfig: {
          apptimelineserver_heapsize: "1024",
          hbase_log_dir: "/var/log/hbase",
          lzo_enabled: "true"
        },
        savingConfig: {
          apptimelineserver_heapsize: "1024",
          hbase_log_dir: "/var/log/hbase",
          lzo_enabled: "true"
        },
        m: "configs doesn't changed",
        res: false
      },
      {
        loadedConfig: {
          apptimelineserver_heapsize: "1024",
          hbase_log_dir: "/var/log/hbase",
          lzo_enabled: "true"
        },
        savingConfig: {
          apptimelineserver_heapsize: "1024",
          hbase_log_dir: "/var/log/hbase",
          lzo_enabled: "false"
        },
        m: "configs changed",
        res: true
      },
      {
        loadedConfig: {
          apptimelineserver_heapsize: "1024",
          hbase_log_dir: "/var/log/hbase"
        },
        savingConfig: {
          apptimelineserver_heapsize: "1024",
          hbase_log_dir: "/var/log/hbase",
          lzo_enabled: "false"
        },
        m: "add new config",
        res: true
      }
    ];

    tests.forEach(function(t){
      it(t.m, function () {
        expect(mainServiceInfoConfigsController.isConfigChanged(t.loadedConfig, t.savingConfig)).to.equal(t.res);
      });
    });
  });

  describe("#addDynamicProperties", function() {

    var tests = [
      {
        stepConfigs: [Em.Object.create({
          serviceName: "WEBHCAT",
          configs: []
        })],
        content: Em.Object.create({
          serviceName: "WEBHCAT"
        }),
        m: "add dynamic property",
        addDynamic: true
      },
      {
        stepConfigs: [Em.Object.create({
          serviceName: "WEBHCAT",
          configs: [
            Em.Object.create({
              name: "templeton.hive.properties"
            })
          ]
        })],
        content: Em.Object.create({
          serviceName: "WEBHCAT"
        }),
        m: "don't add dynamic property (already included)",
        addDynamic: false
      },
      {
        stepConfigs: [Em.Object.create({
          serviceName: "HDFS",
          configs: []
        })],
        content: Em.Object.create({
          serviceName: "HDFS"
        }),
        m: "don't add dynamic property (wrong service)",
        addDynamic: false
      }
    ];
    var dynamicProperty = {
      "name": "templeton.hive.properties",
      "templateName": ["hivemetastore_host"],
      "foreignKey": null,
      "value": "hive.metastore.local=false,hive.metastore.uris=thrift://<templateName[0]>:9083,hive.metastore.sasl.enabled=yes,hive.metastore.execute.setugi=true,hive.metastore.warehouse.dir=/apps/hive/warehouse",
      "filename": "webhcat-site.xml"
    };



    tests.forEach(function(t) {
      it(t.m, function() {
        mainServiceInfoConfigsController.set("content", t.content);
        mainServiceInfoConfigsController.set("stepConfigs", t.stepConfigs);
        var configs = [];
        mainServiceInfoConfigsController.addDynamicProperties(configs);
        if (t.addDynamic){
          expect(configs.findProperty("name","templeton.hive.properties")).to.deep.eql(dynamicProperty);
        }
      });
    });
  });

  describe("#loadUiSideConfigs", function () {

    var t = {
      configMapping: [
        {
          foreignKey: null,
          templateName: "",
          value: "default",
          name: "name1",
          filename: "filename1"
        },
        {
          foreignKey: "notNull",
          templateName: "",
          value: "default2",
          name: "name2",
          filename: "filename2"
        }
      ],
      configMappingf: [
        {
          foreignKey: null,
          templateName: "",
          value: "default",
          name: "name1",
          filename: "filename1"
        }
      ],
      valueWithOverrides: {
        "value": "default",
        "overrides": {
          "value1": "value1",
          "value2": "value2"
        }
      },
      uiConfigs: [
        {
          "id": "site property",
          "name": "name1",
          "value": "default",
          "filename": "filename1",
          "overrides": {
            "value1": "value1",
            "value2": "value2"
          }
        }
      ]
    };

    beforeEach(function(){
      sinon.stub(mainServiceInfoConfigsController, "addDynamicProperties", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "getGlobConfigValueWithOverrides", function () {
        return t.valueWithOverrides
      });
    });

    afterEach(function(){
      mainServiceInfoConfigsController.addDynamicProperties.restore();
      mainServiceInfoConfigsController.getGlobConfigValueWithOverrides.restore();
    });

    it("load ui config", function() {
      expect(mainServiceInfoConfigsController.loadUiSideConfigs(t.configMapping)[0]).to.deep.equal(t.uiConfigs[0]);
      expect(mainServiceInfoConfigsController.addDynamicProperties.calledWith(t.configMappingf)).to.equal(true);
    });
  });

  describe("#formatConfigValues", function () {
    var t = {
      configs: [
        Em.Object.create({ name: "p1", value: " v1 v1 ", displayType: "" }),
        Em.Object.create({ name: "p2", value: true, displayType: "" }),
        Em.Object.create({ name: "p3", value: " d1 ", displayType: "directory" }),
        Em.Object.create({ name: "p4", value: " d1 d2 d3 ", displayType: "directories" }),
        Em.Object.create({ name: "p5", value: " v1 ", displayType: "password" }),
        Em.Object.create({ name: "p6", value: " v ", displayType: "host" }),
        Em.Object.create({ name: "javax.jdo.option.ConnectionURL", value: " v1 ", displayType: "advanced" }),
        Em.Object.create({ name: "oozie.service.JPAService.jdbc.url", value: " v1 ", displayType: "advanced" })
      ],
      result: [
        Em.Object.create({ name: "p1", value: " v1 v1", displayType: "" }),
        Em.Object.create({ name: "p2", value: "true", displayType: "" }),
        Em.Object.create({ name: "p3", value: "d1", displayType: "directory" }),
        Em.Object.create({ name: "p4", value: "d1,d2,d3", displayType: "directories" }),
        Em.Object.create({ name: "p5", value: " v1 ", displayType: "password" }),
        Em.Object.create({ name: "p6", value: "v", displayType: "host" }),
        Em.Object.create({ name: "javax.jdo.option.ConnectionURL", value: " v1", displayType: "advanced" }),
        Em.Object.create({ name: "oozie.service.JPAService.jdbc.url", value: " v1", displayType: "advanced" })
      ]
    };

    it("format config values", function () {
      mainServiceInfoConfigsController.formatConfigValues(t.configs);
      expect(t.configs).to.deep.equal(t.result);
    });

  });

  describe("#setHostForService", function () {
    var tests = [
      {
        globalConfigs: [],
        componentName: "ZOOKEEPER_SERVER",
        serviceName: "ZOOKEEPER",
        hostProperty: "zookeeperserver_hosts",
        multiple: true,
        result: ["hostName1", "hostName2"],
        serviceConfigs: [
          {
            serviceName: "ZOOKEEPER",
            configs: [
              {
                "name": "zookeeperserver_hosts",
                "defaultValue": null
              }
            ]
          }
        ],
        m: "set hostNames to globalConfigs for current service"
      },
      {
        globalConfigs: [],
        componentName: "STORM_UI_SERVER",
        serviceName: "STORM",
        hostProperty: "stormuiserver_host",
        multiple: false,
        result: "hostName1",
        serviceConfigs: [
          {
            serviceName: "STORM",
            configs: [
              {
                "name": "stormuiserver_host",
                "defaultValue": null
              }
            ]
          }
        ],
        m: "set hostName to globalConfigs for current service"
      }
    ];

    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "getMasterComponentHostValue", function (a,m) {
        if (m) {
          return ["hostName1", "hostName2"];
        } else {
          return "hostName1";
        }
      });
    });

    afterEach(function () {
      mainServiceInfoConfigsController.getMasterComponentHostValue.restore();
    });

    tests.forEach(function (t) {
      it(t.m, function () {
        mainServiceInfoConfigsController.set("globalConfigs", t.globalConfigs);
        mainServiceInfoConfigsController.set("serviceConfigs", t.serviceConfigs);
        mainServiceInfoConfigsController.setHostForService(t.serviceName, t.componentName, t.hostProperty, t.multiple);
        expect(mainServiceInfoConfigsController.get("globalConfigs").findProperty("name", t.hostProperty).defaultValue).to.eql(t.result);

      });
    }, this);
  });

  describe("#addHostNamesToGlobalConfig", function () {
    var tests = [
      {
        globalConfigs: [],
        serviceName: "ZOOKEEPER",
        hostProperty: "zookeeperserver_hosts",
        nameNodeHost: "namenode_host",
        serviceConfigs: [
          {
            serviceName: "ZOOKEEPER",
            configs: [
              {
                "name": "zookeeperserver_hosts",
                "defaultValue": null
              },
              {
                "name": "namenode_host",
                "defaultValue": null
              }
            ]
          }
        ],
        result: ["hostName1", "hostName2"],
        result2: ["hostName1", "hostName2"],
        m: "set hostNames to globalConfigs for required services"
      },
      {
        globalConfigs: [
          {
            "name": "hive_database",
            "value": "Existing MySQL Database"
          },
          {
            "name": "hive_hostname",
            "isVisible": false
          }
        ],
        serviceName: "HIVE",
        hostProperty: "hivemetastore_host",
        nameNodeHost: "namenode_host",
        isVisible: true,
        serviceConfigs: [
          {
            serviceName: "HIVE",
            configs: [
              {
                "name": "hivemetastore_host",
                "defaultValue": null
              },
              {
                "name": "namenode_host",
                "defaultValue": null
              }
            ]
          }
        ],
        result: "hostName3",
        result2: ["hostName1", "hostName2"],
        m: "set hostNames to globalConfigs for required services and isVisible property for HIVE"
      }
    ];

    beforeEach(function () {
      mainServiceInfoConfigsController.set("content", Em.Object.create({}));
      sinon.stub(mainServiceInfoConfigsController, "getMasterComponentHostValue", function (a,m) {
        if (m) {
          return ["hostName1", "hostName2"];
        } else {
          return "hostName3";
        }
      });
    });

    afterEach(function () {
      mainServiceInfoConfigsController.getMasterComponentHostValue.restore();
    });

    tests.forEach(function (t) {
      it(t.m, function () {
        mainServiceInfoConfigsController.set("content.serviceName", t.serviceName);
        mainServiceInfoConfigsController.set("globalConfigs", t.globalConfigs);
        mainServiceInfoConfigsController.set("serviceConfigs", t.serviceConfigs);
        mainServiceInfoConfigsController.addHostNamesToGlobalConfig();
        expect(mainServiceInfoConfigsController.get("globalConfigs").findProperty("name", t.hostProperty).defaultValue).to.eql(t.result);
        expect(mainServiceInfoConfigsController.get("globalConfigs").findProperty("name", t.nameNodeHost).defaultValue).to.eql(t.result2);
        if (t.serviceName == "HIVE" || t.serviceName == "OOZIE") {
          expect(mainServiceInfoConfigsController.get("globalConfigs").findProperty("name", t.hostProperty).isVisible).to.eql(t.isVisible);
        }
      });
    }, this);
  });

  describe("#doPUTClusterConfiguration", function () {
    var tests = [
      {
        configs: {
          properties: {
            property1: "1001",
            property2: "text"
          }
        },
        siteName: "global",
        r: true,
        m: "save changed properties"
      },
      {
        configs: {
          properties: {
            property1: "1000",
            property2: "text"
          }
        },
        siteName: "global",
        r: true,
        m: "skip saving becouse nothing changed (returns true)"
      },
      {
        configs: {
          properties: {
            property1: "1001",
            property2: "text"
          },
          success: false
        },
        siteName: "global",
        r: false,
        m: "saving failed"
      }
    ];
    var getConfigsByTags = {
      property1: "1000",
      property2: "text"
    }
    beforeEach(function () {
      sinon.stub(App.router.get('configurationController'), "getConfigsByTags", function () {
        return getConfigsByTags
      });
      sinon.stub(mainServiceInfoConfigsController, "doPUTClusterConfigurationSite", function (k) {
        return k.success !== false;
      });
    });

    afterEach(function () {
      mainServiceInfoConfigsController.doPUTClusterConfigurationSite.restore();
      App.router.get('configurationController').getConfigsByTags.restore();
    });
    tests.forEach(function (t) {
      it(t.m, function () {
        var siteNameToServerDataMap = {};
        expect(mainServiceInfoConfigsController.doPUTClusterConfiguration(siteNameToServerDataMap, t.siteName, t.configs)).to.equal(t.r);
        expect(siteNameToServerDataMap[t.siteName]).to.eql(t.configs);
      })
    });
  });

  describe("#createConfigObject", function() {
    var tests = [
      {
        siteName: "global",
        method: "createGlobalSiteObj"
      },
      {
        siteName: "core-site",
        serviceName: "HDFS",
        method: "createCoreSiteObj"
      },
      {
        siteName: "core-site",
        serviceName: "ANY",
        method: false
      },
      {
        siteName: "any",
        method: "createSiteObj"
      },
      {
        siteName: "mapred-queue-acls",
        method: false,
        capacitySchedulerUi: false
      },
      {
        siteName: "mapred-queue-acls",
        method: "createSiteObj",
        capacitySchedulerUi: true
      }
    ];

    var capacitySchedulerUi = App.supports.capacitySchedulerUi;
    beforeEach(function() {
      sinon.stub(mainServiceInfoConfigsController, "createGlobalSiteObj", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "createCoreSiteObj", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "createSiteObj", Em.K);
      mainServiceInfoConfigsController.set("content", {});
    });

    afterEach(function() {
      mainServiceInfoConfigsController.createGlobalSiteObj.restore();
      mainServiceInfoConfigsController.createCoreSiteObj.restore();
      mainServiceInfoConfigsController.createSiteObj.restore();
      App.supports.capacitySchedulerUi = capacitySchedulerUi;
    });

    tests.forEach(function(t) {
      it("create object for " + t.siteName + " run method " + t.method, function() {
        App.supports.capacitySchedulerUi = t.capacitySchedulerUi;
        mainServiceInfoConfigsController.set("content.serviceName", t.serviceName);
        mainServiceInfoConfigsController.createConfigObject(t.siteName, "versrion1");
        if (t.method) {
          expect(mainServiceInfoConfigsController[t.method].calledOnce).to.equal(true);
        } else {
          expect(mainServiceInfoConfigsController["createGlobalSiteObj"].calledOnce).to.equal(false);
          expect(mainServiceInfoConfigsController["createCoreSiteObj"].calledOnce).to.equal(false);
          expect(mainServiceInfoConfigsController["createSiteObj"].calledOnce).to.equal(false);
        }
      });
    });
  });

  describe("#doPUTClusterConfigurations", function() {

    var t = {
     propertyName: "global",
     properties: {
       propertu1: "text",
       property2: 1000
     },
     serviceConfigTags: [{
       siteName: "global",
       tagName: "version1"
     }]
    };

    beforeEach(function() {
      sinon.stub(mainServiceInfoConfigsController, "createConfigObject", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "setNewTagNames", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "doPUTClusterConfiguration", function (siteNameToServerDataMap) {
        siteNameToServerDataMap[t.propertyName] = t.properties;
        return true;
      });
    });

    afterEach(function() {
      mainServiceInfoConfigsController.createConfigObject.restore();
      mainServiceInfoConfigsController.setNewTagNames.restore();
      mainServiceInfoConfigsController.doPUTClusterConfiguration.restore();
    });

    it("Saves cluster level configurations", function() {
      var siteNameToServerDataMap = {};
      siteNameToServerDataMap[t.propertyName] = t.properties;
      mainServiceInfoConfigsController.set("serviceConfigTags", t.serviceConfigTags);
      expect(mainServiceInfoConfigsController.doPUTClusterConfigurations()).to.equal(true);
      expect(mainServiceInfoConfigsController["createConfigObject"].calledOnce).to.equal(true);
      expect(mainServiceInfoConfigsController["setNewTagNames"].calledOnce).to.equal(true);
      expect(mainServiceInfoConfigsController["doPUTClusterConfiguration"].calledOnce).to.equal(true);
      expect(mainServiceInfoConfigsController.get("savedSiteNameToServerServiceConfigDataMap")).to.eql(siteNameToServerDataMap);
    });
  });

  describe("#putConfigGroupChanges", function() {

    var t = {
      data: {
        ConfigGroup: {
          id: "id"
        }
      },
      request: [{
        ConfigGroup: {
          id: "id"
        }
      }]
    };

    beforeEach(function() {
      sinon.spy($,"ajax");
    });
    afterEach(function() {
      $.ajax.restore();
    });

    it("updates configs groups", function() {
      mainServiceInfoConfigsController.putConfigGroupChanges(t.data);
      expect(JSON.parse($.ajax.args[0][0].data)).to.deep.equal(t.request);
    });
  });

  describe("#putConfigGroupChangesSuccess", function() {
    it("set isPutConfigGroupChangesSuccess to true", function() {
      mainServiceInfoConfigsController.set("mainServiceInfoConfigsController", false);
      mainServiceInfoConfigsController.putConfigGroupChangesSuccess();
      expect(mainServiceInfoConfigsController.get("isPutConfigGroupChangesSuccess")).to.equal(true);
    });
  });

  describe("#setValueForCheckBox", function() {
    var tests = [
      {
        serviceConfigPropertyInput: Em.Object.create({
          value: "true",
          defaultValue: "true",
          displayType: 'checkbox'
        }),
        serviceConfigProperty: Em.Object.create({
            value: true,
            defaultValue: true,
          displayType: 'checkbox'
        })
      },
      {
        serviceConfigPropertyInput: Em.Object.create({
          value: "false",
          defaultValue: "false",
          displayType: 'checkbox'
        }),
        serviceConfigProperty: Em.Object.create({
          value: false,
          defaultValue: false,
          displayType: 'checkbox'
        })
      },
      {
        serviceConfigPropertyInput: Em.Object.create({
          value: "false",
          defaultValue: "false"
        }),
        serviceConfigProperty: Em.Object.create({
          value: "false",
          defaultValue: "false"
        })
      }
    ];
    tests.forEach(function(t) {
      it("set " + t.serviceConfigPropertyInput.value, function(){
        var serviceConfigProperty = t.serviceConfigPropertyInput;
        mainServiceInfoConfigsController.setValueForCheckBox(serviceConfigProperty);
        expect(serviceConfigProperty).to.eql(t.serviceConfigProperty);
      });
    });
  });

  describe("#setEditability", function () {

    var tests = [
      {
        isAdmin: true,
        isHostsConfigsPage: false,
        defaultGroupSelected: true,
        isReconfigurable: true,
        isEditable: true,
        m: ""
      },
      {
        isAdmin: false,
        isHostsConfigsPage: false,
        defaultGroupSelected: true,
        isReconfigurable: true,
        isEditable: false,
        m: "(non admin)"
      },
      {
        isAdmin: true,
        isHostsConfigsPage: true,
        defaultGroupSelected: true,
        isReconfigurable: true,
        isEditable: false,
        m: "(isHostsConfigsPage)"
      },
      {
        isAdmin: true,
        isHostsConfigsPage: false,
        defaultGroupSelected: false,
        isReconfigurable: true,
        isEditable: false,
        m: "(defaultGroupSelected is false)"
      },
      {
        isAdmin: true,
        isHostsConfigsPage: false,
        defaultGroupSelected: true,
        isReconfigurable: false,
        isEditable: false,
        m: "(isReconfigurable is false)"
      }
    ];

    var a = App.get('isAdmin');
    afterEach(function () {
      App.set('isAdmin', a);
    });
    tests.forEach(function(t) {
      it("set isEditable " + t.isEditable + t.m, function(){
        App.set('isAdmin', t.isAdmin);
        mainServiceInfoConfigsController.set("isHostsConfigsPage", t.isHostsConfigsPage);
        var serviceConfigProperty = Em.Object.create({
          isReconfigurable: t.isReconfigurable
        });
        mainServiceInfoConfigsController.setEditability(serviceConfigProperty, t.defaultGroupSelected);
        expect(serviceConfigProperty.get("isEditable")).to.equal(t.isEditable);
      });
    });
  });

  describe("#setValidator", function () {
    var tests = [
      {
        content: Em.Object.create({
          serviceName: "service1"
        }),
        serviceConfigsData: {
          configsValidator: Em.Object.create({
            configValidators: {
              val1: "yarnNodemanagerResourceMemoryMb",
              val2: "yarnSchedulerMaximumAllocationMb"
            }
          })
        },
        serviceConfigPropertyInput: Em.Object.create({
          serviceName: "service1",
          name: "val1",
          serviceValidator: null,
          isVisible: true
        }),
        serviceConfigProperty: Em.Object.create({
          serviceName: "service1",
          name: "val1",
          serviceValidator: Em.Object.create({
            configValidators: {
              val1: "yarnNodemanagerResourceMemoryMb",
              val2: "yarnSchedulerMaximumAllocationMb"
            }
          }),
          isVisible: true
        }),

        m: "set appropriate configsValidator "
      },
      {
        content: Em.Object.create({
          serviceName: "service"
        }),
        serviceConfigsData: {
          configsValidator: Em.Object.create({
            configValidators: {
              val1: "yarnNodemanagerResourceMemoryMb",
              val2: "yarnSchedulerMaximumAllocationMb"
            }
          })
        },
        serviceConfigPropertyInput: Em.Object.create({
          serviceName: "service1",
          name: "yarnNodemanagerResourceMemoryMb",
          serviceValidator: null,
          isVisible: true
        }),
        serviceConfigProperty: Em.Object.create({
          serviceName: "service1",
          name: "yarnNodemanagerResourceMemoryMb",
          serviceValidator: null,
          isVisible: false
        }),
        m: "different service "
      }
    ];
    tests.forEach(function (t) {
      it(t.m, function () {
        mainServiceInfoConfigsController.set("content", t.content);
        var serviceConfigProperty = t.serviceConfigPropertyInput;
        mainServiceInfoConfigsController.setValidator(serviceConfigProperty, t.serviceConfigsData);
        expect(serviceConfigProperty).to.deep.eql(t.serviceConfigProperty);
      });
    });
  });

  describe("#checkOverrideProperty", function () {
    var tests = [{
      overrideToAdd: {
        name: "name1"
      },
      componentConfig: {
        configs: [
          {
            name: "name1"
          }
        ]
      },
      add: true,
      m: "add property"
    },
      {
        overrideToAdd: {
          name: "name1"
        },
        componentConfig: {
          configs: [
            {
              name: "name2"
            }
          ]
        },
        add: false,
        m: "don't add property, different names"
      },
      {
        overrideToAdd: null,
        componentConfig: {},
        add: false,
        m: "don't add property, overrideToAdd is null"
      }];

    beforeEach(function() {
      sinon.stub(mainServiceInfoConfigsController,"addOverrideProperty", Em.K)
    });
    afterEach(function() {
      mainServiceInfoConfigsController.addOverrideProperty.restore();
    });
    tests.forEach(function(t) {
      it(t.m, function() {
        mainServiceInfoConfigsController.set("overrideToAdd", t.overrideToAdd);
        mainServiceInfoConfigsController.checkOverrideProperty(t.componentConfig);
        if(t.add) {
          expect(mainServiceInfoConfigsController.addOverrideProperty.calledOnce).to.equal(true);
          expect(mainServiceInfoConfigsController.get("overrideToAdd")).to.equal(null);
        } else {
          expect(mainServiceInfoConfigsController.addOverrideProperty.calledOnce).to.equal(false);
        }
      });
    });
  });

  describe("#setRecommendedDefaults", function() {
    var tests = [{
      content: Em.Object.create({
        serviceName: "service1"
      }),
      serviceConfigsDataInput:[{
        serviceName: "service1",
        defaultsProviders: [
          App.DefaultsProvider.create({
            getDefaults: function() {
            return {
              p1: "-Xmx546m1",
              p2: null
            }
          }
          })
        ],
        configsValidator: Em.Object.create({
          recommendedDefaults: null
        })
      }],
      advancedConfigs: [
        { name: "p1", value: "1"},
        { name: "p2", value: "2"}
      ],

      serviceConfigsData:[{
        serviceName: "service1",
        defaultsProviders: [
          App.DefaultsProvider.create({
            getDefaults: function() {
              return {
                p1: "-Xmx546m1",
                p2: null
              }
            }
          })
        ],
        configsValidator: Em.Object.create({
          recommendedDefaults: {
            p1: "-Xmx546m1",
            p2: "2"
          }
        })
      }]
    }];

    beforeEach(function() {
      sinon.stub(mainServiceInfoConfigsController, "getInfoForDefaults", Em.K);
    });
    afterEach(function() {
      mainServiceInfoConfigsController.getInfoForDefaults.restore();
    });
    tests.forEach(function(t) {
      it("", function() {
        mainServiceInfoConfigsController.set("content", t.content);
        mainServiceInfoConfigsController.set("serviceConfigsData", t.serviceConfigsDataInput);
        mainServiceInfoConfigsController.setRecommendedDefaults(t.advancedConfigs);
        expect(mainServiceInfoConfigsController.get("serviceConfigsData")[0].configsValidator).to.deep.eql(t.serviceConfigsData[0].configsValidator);

      });
    });
  });


  describe("#setValuesForOverrides", function() {
    var tests = [
      {
        overrides: [
          {name: "override1"},
          {name: "override2"}
        ],
        _serviceConfigProperty: {},
        serviceConfigProperty: Em.Object.create({overrides: Em.A([])}),
        defaultGroupSelected: true
      }
    ];
    beforeEach(function() {
      sinon.stub(mainServiceInfoConfigsController, "createNewSCP", function(override) {return {name: override.name}})
    });
    afterEach(function() {
      mainServiceInfoConfigsController.createNewSCP.restore();
    });
    tests.forEach(function(t) {
      it("set values for overrides. use createNewSCP method to do this", function() {
        var serviceConfigProperty = t.serviceConfigProperty;
        mainServiceInfoConfigsController.setValuesForOverrides(t.overrides, serviceConfigProperty, t.serviceConfigProperty, t.defaultGroupSelected);
        expect(serviceConfigProperty.get("overrides")[0]).to.eql(t.overrides[0]);
        expect(serviceConfigProperty.get("overrides")[1]).to.eql(t.overrides[1]);
      });
    });
  });
  describe("#createConfigProperty", function() {
    var tests = [
      {
        _serviceConfigProperty: {
          overrides: {

          }
        },
        defaultGroupSelected: true,
        restartData: {},
        serviceConfigsData: {},
        serviceConfigProperty: {
          overrides: null,
          isOverridable: true
        }
      }];
    beforeEach(function() {
      sinon.stub(mainServiceInfoConfigsController, "setValueForCheckBox", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "setRestartInfo", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "setValidator", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "setValuesForOverrides", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "setEditability", Em.K);
    });
    afterEach(function() {
      mainServiceInfoConfigsController.setValueForCheckBox.restore();
      mainServiceInfoConfigsController.setRestartInfo.restore();
      mainServiceInfoConfigsController.setValidator.restore();
      mainServiceInfoConfigsController.setValuesForOverrides.restore();
      mainServiceInfoConfigsController.setEditability.restore();
    });
    tests.forEach(function(t) {
      it("create service config. run methods to correctly set object fileds", function() {
        var result = mainServiceInfoConfigsController.createConfigProperty(t._serviceConfigProperty, t.defaultGroupSelected, t.restartData, t.serviceConfigsData);
        expect(mainServiceInfoConfigsController.setValueForCheckBox.calledWith(t.serviceConfigProperty));
        expect(mainServiceInfoConfigsController.setRestartInfo.calledWith(t.restartData, t.serviceConfigProperty));
        expect(mainServiceInfoConfigsController.setValidator.calledWith(t.serviceConfigProperty, t.serviceConfigsData));
        expect(mainServiceInfoConfigsController.setValuesForOverrides.calledWith(t._serviceConfigProperty.overrides, t._serviceConfigProperty, t.serviceConfigProperty, t.defaultGroupSelected));
        expect(mainServiceInfoConfigsController.setValidator.calledWith(t.serviceConfigProperty, t.defaultGroupSelected));
        expect(result.getProperties('overrides','isOverridable')).to.eql(t.serviceConfigProperty);
      });
    });
  });

  describe("#createNewSCP", function() {
    var tests = [
      {
        overrides: {
          value: "value",
          group: {
            value: "group1"
          }
        },
        _serviceConfigProperty: {},
        serviceConfigProperty: {
          value: "parentSCP"
        },
        defaultGroupSelected: true,

        newSCP: {
          value: "value",
          isOriginalSCP: false,
          parentSCP:{
            value: "parentSCP"
          },
          group: {
            value: "group1"
          },
          isEditable: false
        }
      }
    ];
    tests.forEach(function(t) {
      it("", function() {
        var newSCP = mainServiceInfoConfigsController.createNewSCP(t.overrides, t._serviceConfigProperty, t.serviceConfigProperty, t.defaultGroupSelected);
        expect(newSCP.getProperties("value", "isOriginalSCP", "parentSCP", "group", "isEditable")).to.eql(t.newSCP);
      });
    });
  });
});

});

;require.register("test/controllers/main/service/item_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

App = require('app');
require('ember');
require('models/host_component')
require('views/common/modal_popup');
require('mixins/common/userPref');
require('controllers/application');
require('controllers/global/background_operations_controller');
require('controllers/global/cluster_controller');
require('controllers/main/service/reassign_controller')
require('controllers/main/service/item');
var batchUtils = require('utils/batch_scheduled_requests');

describe('App.MainServiceItemController', function () {

  describe('#setStartStopState', function () {
    var tests = [
      {
        serviceController: {
          serviceName: "YARN"
        },
        backgroundOperationsController: {
          services: [
            {
              isRunning: true,
              dependentService: "ALL_SERVICES"
            }
          ]
        },
        isPending: true,
        m: 'operaion is active because all services are running'
      },
      {
        serviceController: {
          serviceName: "HBASE"
        },
        backgroundOperationsController: {
          services: [
            {
              isRunning: true,
              dependentService: "HBASE"
            }
          ]
        },
        isPending: true,
        m: 'operaion is active button because current service is running'
      },
      {
        serviceController: {
          serviceName: "HDFS"
        },
        backgroundOperationsController: {
          services: [

          ]
        },
        isPending: true,
        m: 'pending is true - backgroundOperationsController.services is empty'
      },
      {
        serviceController: {
          serviceName: "HBASE"
        },
        backgroundOperationsController: {
          services: [
            {
              isRunning: false,
              dependentService: "ALL_SERVICES"
            }
          ]
        },
        isPending: false,
        m: 'pending is false - operation is not running'
      },
      {
        serviceController: {
          serviceName: "HBASE"
        },
        backgroundOperationsController: {
          services: [
            {
              isRunning: true,
              dependentService: "HDFS"
            }
          ]
        },
        isPending: false,
        m: 'pending is false - current service is not running'
      }
    ];


    tests.forEach(function (test) {
      it(test.m, function () {
        var backgroundOperationsController = App.BackgroundOperationsController.create();
        backgroundOperationsController.set('services', []);
        test.backgroundOperationsController.services.forEach(function (service) {
          backgroundOperationsController.get('services').push(service);
        });
        backgroundOperationsController.set("serviceTimestamp", new Date().getTime());
        App.router.set('backgroundOperationsController', backgroundOperationsController);
        var mainServiceItemController = App.MainServiceItemController.create({content: {serviceName: test.serviceController.serviceName}});
        mainServiceItemController.setStartStopState();
        expect(mainServiceItemController.get('isPending')).to.equal(test.isPending);
      });
    })
  });

  describe('#reassignMaster()', function () {
    var v;
    var tests = [
      {
        host_components: [
          {component_name: "RESOURCEMANGER"}
        ],
        conponentName: "RESOURCEMANGER",
        result: true,
        m: 'run reassignMaster'
      },
      {
        host_components: [
          {component_name: "RESOURCEMANGER"}
        ],
        conponentName: "DATANODE",
        result: false,
        m: 'don\t run reassignMaster'
      }
    ];

    tests.forEach(function (test) {
      var reassignMasterController = App.ReassignMasterController.create({currentStep: ''});
      beforeEach(function () {
        sinon.spy(reassignMasterController, 'saveComponentToReassign');
        sinon.spy(reassignMasterController, 'getSecurityStatus');
        sinon.spy(reassignMasterController, 'setCurrentStep');
        App.router.transitionTo = Em.K;
      });
      afterEach(function () {
        reassignMasterController.saveComponentToReassign.restore();
        reassignMasterController.getSecurityStatus.restore();
        reassignMasterController.setCurrentStep.restore();
        App.router.transitionTo = v;
      });
      it(test.m, function () {
        v = App.router.transitionTo;
        var mainServiceItemController = App.MainServiceItemController.create({});
        App.router.set('reassignMasterController', reassignMasterController);
        App.store.loadMany(App.HostComponent, test.host_components);
        mainServiceItemController.reassignMaster(test.conponentName);
        expect(reassignMasterController.saveComponentToReassign.calledOnce).to.equal(test.result);
        expect(reassignMasterController.getSecurityStatus.calledOnce).to.equal(test.result);
        expect(reassignMasterController.setCurrentStep.calledOnce).to.equal(test.result);
      });
    }, this);
  });

  describe("#updateService", function () {

    var tests = [
      {
        params: {
          passive_state: "ON"
        },
        m: "turn on passive"
      },
      {
        params: {
          passive_state: "OFF"
        },
        m: "turn off passive"
      }
    ];
    tests.forEach(function (test) {
      it(test.m, function () {
        var clusterController = App.ClusterController.create();
        App.router.set('clusterController', clusterController);
        var mainServiceItemController = App.MainServiceItemController.create({content: {passiveState: "ON"}});
        mainServiceItemController.updateService(null, null, test.params);
        expect(mainServiceItemController.get('content.passiveState')).to.equal(test.params.passive_state);
      });
    });
  });

  describe("#doAction", function () {

    var el = document.createElement("BUTTON");
    el.disabled = false;
    var tests = [
      {
        event: {
          target: el,
          context: {
            action: 'runSmokeTest'
          }
        },
        m: "run runSmokeTest"
      },
      {
        event: {
          target: el,
          context: {
            action: 'refreshConfigs'
          }
        },
        m: "run refreshConfigs"
      },
      {
        event: {
          target: el,
          context: {
            action: 'restartAllHostComponents'
          }
        },
        m: "run restartAllHostComponents"
      },
      {
        event: {
          target: el,
          context: {
            action: 'rollingRestart'
          }
        },
        m: "run rollingRestart"
      }
    ];

    tests.forEach(function (test) {
      var mainServiceItemController = App.MainServiceItemController.create({});
      mainServiceItemController.set(test.event.context.action, Em.K);
      beforeEach(function () {
        sinon.spy(mainServiceItemController, test.event.context.action);
      });
      afterEach(function () {
        mainServiceItemController[test.event.context.action].restore();
      });
      it(test.m, function () {
        mainServiceItemController.doAction(test.event);
        expect(mainServiceItemController[test.event.context.action].calledOnce).to.equal(!test.event.target.disabled);
      });
    });
  });

  describe("#startStopPopupPrimary", function () {


    var tests = [
      {
        data: {
          "serviceName": "HDFS",
          "state": "STARTED",
          "query": Em.Object.create({ServiceInfo: "FAIL"})
        },
        request: {
          "RequestInfo": {
            "context": "_PARSE_.START.HDFS"
          },
          "Body": {
            "ServiceInfo": {
              "state": "STARTED"
            }
          }
        },
        m: "Start HDFS"
      },
      {
        data: {
          "serviceName": "YARN",
          "state": "STOPPED",
          "query": Em.Object.create({ServiceInfo: "FAIL"})
        },
        request: {
          "RequestInfo": {
            "context": "_PARSE_.STOP.YARN"
          },
          "Body": {
            "ServiceInfo": {
              "state": "STOPPED"
            }
          }
        },
        m: "Stop YARN"
      }
    ];

    beforeEach(function () {
      sinon.spy($, 'ajax');
    });

    afterEach(function () {
      $.ajax.restore();
    });


    tests.forEach(function (test) {
      it('', function () {
        var mainServiceItemController = App.MainServiceItemController.create({content: {serviceName: test.data.serviceName}});
        mainServiceItemController.startStopPopupPrimary(test.data.state, test.data.query);
        expect($.ajax.calledOnce).to.equal(true);

        expect(JSON.parse($.ajax.args[0][0].data).Body.ServiceInfo.state).to.equal(test.request.Body.ServiceInfo.state);
        expect(JSON.parse($.ajax.args[0][0].data).RequestInfo.context).to.equal(test.request.RequestInfo.context);

        expect(mainServiceItemController.get('isStopDisabled')).to.equal(true);
        expect(mainServiceItemController.get('isStartDisabled')).to.equal(true);
      });
    });


  });

  describe("#startStopPopupSuccessCallback", function () {

    var data = {
      Requests: true
    };
    var params = Em.Object.create({
      query: Em.Object.create()
    });
    var ajaxOptions = {
      data: '{"RequestInfo":{"context":"_PARSE_.STOP.ZOOKEEPER"},"Body":{"ServiceInfo":{"state":"INSTALLED"}}}'
    };

    var content = {
      workStatus: "",
      hostComponents: [
        {
          workStatus: ""
        }
      ]
    };

    var mainServiceItemController = App.MainServiceItemController.create({content: content});
    var applicationController = App.ApplicationController.create(App.UserPref, {});
    var clusterController = App.ClusterController.create({loadUpdatedStatusDelayed: Em.K});
    var backgroundOperationsController = App.BackgroundOperationsController.create({showPopup: Em.K});
    App.testMode = false;
    beforeEach(function () {
      App.testMode = false;
      sinon.spy(clusterController, "loadUpdatedStatusDelayed");
    });
    afterEach(function () {
      clusterController.loadUpdatedStatusDelayed.restore();
      App.testMode = true;
    });
    it("open bgo popup", function () {
      App.router.set('applicationController', applicationController);
      App.router.set('clusterController', clusterController);
      App.router.set('backgroundOperationsController', backgroundOperationsController);
      mainServiceItemController.startStopPopupSuccessCallback(data, ajaxOptions, params);
      expect(clusterController.loadUpdatedStatusDelayed.calledOnce).to.equal(true);
    })
  });


  describe("#startService , #stopService", function () {
    var mainServiceItemController = App.MainServiceItemController.create({startStopPopup: Em.K});
    beforeEach(function () {
      sinon.spy(mainServiceItemController, "startStopPopup");
    });
    afterEach(function () {
      mainServiceItemController.startStopPopup.restore();
    });
    it("start service", function () {
      mainServiceItemController.startService({});
      expect(mainServiceItemController.startStopPopup.calledWith({},App.HostComponentStatus.started)).to.equal(true);
    });
    it("stop service", function () {
      mainServiceItemController.stopService({});
      expect(mainServiceItemController.startStopPopup.calledWith({},App.HostComponentStatus.stopped)).to.equal(true);
    });
  });


  describe("#turnOnOffPassive", function () {
    var mainServiceItemController = App.MainServiceItemController.create({turnOnOffPassiveRequest: Em.K});
    beforeEach(function () {
      sinon.spy(mainServiceItemController, "turnOnOffPassiveRequest");
    });
    afterEach(function () {
      mainServiceItemController.turnOnOffPassiveRequest.restore();
    });
    it("turns on/off passive mode for service", function () {
      mainServiceItemController.turnOnOffPassive({}).onPrimary();
      expect(mainServiceItemController.turnOnOffPassiveRequest.calledOnce).to.equal(true);
    });
  });

  describe("#runSmokeTest", function () {
    var tests = [
      {
        content: {
          id: "YARN",
          service_name: "YARN",
          work_status: "STARTED"
        },
        startSmoke: true,
        serviceName: "MAPREDUCE2",
        m: "don't run smoke test primary for MAPREDUCE2"
      },
      {
        content: {
          id: "YARN",
          service_name: "YARN",
          work_status: "STOPPED"
        },
        startSmoke: false,
        serviceName: "MAPREDUCE2",
        m: "run smoke test primary for MAPREDUCE2"
      },
      {
        m: "run smoke test primary for all services (not MAPREDUCE2)",
        startSmoke: true,
        default: true
      }
    ];

    tests.forEach(function (test) {
      var mainServiceItemController = test.default ? App.MainServiceItemController.create({runSmokeTestPrimary: Em.K}) :
          App.MainServiceItemController.create({content: {serviceName: test.serviceName}, runSmokeTestPrimary: Em.K});
      beforeEach(function () {
        sinon.spy(mainServiceItemController, "runSmokeTestPrimary");
      });
      afterEach(function () {
        mainServiceItemController.runSmokeTestPrimary.restore();
      });
      it(test.m, function () {
        if (!test.default) {
          App.store.load(App.Service, test.content);
        }
        mainServiceItemController.runSmokeTest({}).onPrimary();
        expect(mainServiceItemController.runSmokeTestPrimary.calledOnce).to.equal(test.startSmoke);
      });
    });
  });

  describe("#refreshConfigs", function () {
    var temp = batchUtils.restartHostComponents;
    beforeEach(function () {
      sinon.stub(App.ajax, 'send', function(opt) {
        return opt.data.callback({ items: [] });
      });
      batchUtils.restartHostComponents = Em.K;
      sinon.spy(batchUtils, "restartHostComponents");
    });
    afterEach(function () {
      batchUtils.restartHostComponents.restore();
      batchUtils.restartHostComponents = temp;
      App.ajax.send.restore();
    });
    var tests = [
      {
        isClientsOnly: true,
        m: "run refresh for clients"
      },
      {
        isClientsOnly: false,
        m: "don't run refresh for non clients"
      }
    ];
    tests.forEach(function (test) {
      var mainServiceItemController = App.MainServiceItemController.create({content: {isClientsOnly: test.isClientsOnly}});
      it(test.m, function () {
        if (test.isClientsOnly) {
          mainServiceItemController.refreshConfigs().onPrimary();
        } else {
          mainServiceItemController.refreshConfigs();
        }
        expect(batchUtils.restartHostComponents.calledOnce).to.equal(test.isClientsOnly);
      });
    }, this);
  });

  describe("#startStopPopup", function () {
    var el = document.createElement("BUTTON");
    el.disabled = false;
    var event = {
      target: el
    }
    var mainServiceItemController = App.MainServiceItemController.create({content: {serviceName: "HDFS"}});
    beforeEach(function () {
      sinon.spy(mainServiceItemController, "startStopPopupPrimary");
    });
    afterEach(function () {
      mainServiceItemController.startStopPopupPrimary.restore();
    });
    it("start start/stop service popup", function () {
      mainServiceItemController.startStopPopup(event, "").onPrimary();
      expect(mainServiceItemController.startStopPopupPrimary.calledOnce).to.equal(true);
    });
  });

  describe("#restartAllHostComponents", function () {
    var temp = batchUtils.restartAllServiceHostComponents;
    beforeEach(function () {
      batchUtils.restartAllServiceHostComponents = Em.K;
      sinon.spy(batchUtils, "restartAllServiceHostComponents");
    });
    afterEach(function () {
      batchUtils.restartAllServiceHostComponents.restore();
      batchUtils.restartAllServiceHostComponents = temp;
    });

    var mainServiceItemController = App.MainServiceItemController.create({content: {displayName: "HDFS"}});

    it("start restartAllHostComponents for service", function () {
      mainServiceItemController.restartAllHostComponents({}).onPrimary();
      expect(batchUtils.restartAllServiceHostComponents.calledOnce).to.equal(true);
    });
  });

  describe("#rollingRestart", function () {
    var temp = batchUtils.launchHostComponentRollingRestart;
    beforeEach(function () {
      batchUtils.launchHostComponentRollingRestart = Em.K;
      sinon.spy(batchUtils, "launchHostComponentRollingRestart");
    });
    afterEach(function () {
      batchUtils.launchHostComponentRollingRestart.restore();
      batchUtils.launchHostComponentRollingRestart = temp;
    });

    var mainServiceItemController = App.MainServiceItemController.create();

    it("start restartAllHostComponents for service", function () {
      mainServiceItemController.rollingRestart();
      expect(batchUtils.launchHostComponentRollingRestart.calledOnce).to.equal(true);
    });
  });

  describe("#isStartDisabled", function () {
    var tests = [
      {
        content: {
          healthStatus: 'red'
        },
        isPending: true,
        disabled: true,
        m: "disabled because of pending"
      },
      {
        content: {
          healthStatus: 'green'
        },
        isPending: false,
        disabled: true,
        m: "disabled because healthStatus is not red"
      },
      {
        content: {
          healthStatus: 'red'
        },
        isPending: false,
        disabled: false,
        m: "enabled because healthStatus is red and pending is false"
      }
    ];
    tests.forEach(function (test) {
      it(test.m, function () {
        var mainServiceItemController = App.MainServiceItemController.create({content: {healthStatus: test.content.healthStatus}, isPending: test.isPending});
        expect(mainServiceItemController.get('isStartDisabled')).to.equal(test.disabled);
      });
    });
  });

  describe("#isSopDisabled", function () {
    var tests = [
      {
        content: {
          healthStatus: 'red'
        },
        isPending: true,
        disabled: true,
        m: "disabled because of pending"
      },
      {
        content: {
          healthStatus: 'green'
        },
        isPending: false,
        disabled: false,
        m: "enabled because healthStatus is green and pending is false"
      },
      {
        content: {
          healthStatus: 'red'
        },
        isPending: false,
        disabled: true,
        m: "disabled because healthStatus is not green"
      }
    ];
    tests.forEach(function (test) {
      it(test.m, function () {
        var mainServiceItemController = App.MainServiceItemController.create({content: test.content, isPending: test.isPending});
        expect(mainServiceItemController.get('isStopDisabled')).to.equal(test.disabled);
      });
    });
  });

  describe("#runRebalancer", function () {
    it("run rebalancer", function () {
      var mainServiceItemController = App.MainServiceItemController.create({content: {runRebalancer: false}});
      mainServiceItemController.runRebalancer().onPrimary();
      expect(mainServiceItemController.get("content.runRebalancer")).to.equal(true);
    });
  });

  describe("#runCompaction", function () {
    it("run compaction", function () {
      var mainServiceItemController = App.MainServiceItemController.create({content: {runCompaction: false}});
      mainServiceItemController.runCompaction().onPrimary();
      expect(mainServiceItemController.get("content.runCompaction")).to.equal(true);
    });
  });

  describe("#turnOnOffPassiveRequest", function () {
    var tests = [
      {
        data: {
          "requestInfo": 'Turn On Maintenance Mode',
          "serviceName" : "HDFS",
          "passive_state": "ON"
        },
        RequestInfo: {
          "context": 'Turn On Maintenance Mode'
        },
        Body: {
          ServiceInfo: {
            maintenance_state: "ON"
          }
        }
      }
    ];

    beforeEach(function () {
      sinon.spy($, 'ajax');
    });

    afterEach(function () {
      $.ajax.restore();
    });

    tests.forEach(function (test) {
      it('send request to turn on passive state', function () {
        var mainServiceItemController = App.MainServiceItemController.create({content: {serviceName: test.data.serviceName}});
        mainServiceItemController.turnOnOffPassiveRequest(test.data.passive_state, test.data.requestInfo);
        expect($.ajax.calledOnce).to.equal(true);

        expect(JSON.parse($.ajax.args[0][0].data).Body.ServiceInfo.maintenance_state).to.equal(test.Body.ServiceInfo.maintenance_state);
        expect(JSON.parse($.ajax.args[0][0].data).RequestInfo.context).to.equal(test.RequestInfo.context);
      });
    });
  });

  describe("#runSmokeTestPrimary", function () {
    var tests = [
      {
        data: {
          'serviceName': "HDFS",
          'displayName': "HDFS",
          'query': "test"
        },
        "RequestInfo": {
          "context": "HDFS Service Check",
          "command" : "HDFS_SERVICE_CHECK"
        },
        "Requests/resource_filters": [{"service_name" : "HDFS"}]
      }
    ];
    tests.forEach(function (test) {

    var mainServiceItemController = App.MainServiceItemController.create({content: {serviceName: test.data.serviceName,
      displayName: test.data.displayName}});
    beforeEach(function () {
      mainServiceItemController.set("runSmokeTestErrorCallBack", Em.K);
      mainServiceItemController.set("runSmokeTestSuccessCallBack", Em.K);
      sinon.spy($, 'ajax');
    });

    afterEach(function () {
      $.ajax.restore();
    });

      it('send request to run smoke test', function () {

        mainServiceItemController.runSmokeTestPrimary(test.data.query);
        expect($.ajax.calledOnce).to.equal(true);

        expect(JSON.parse($.ajax.args[0][0].data).RequestInfo.context).to.equal(test.RequestInfo.context);
        expect(JSON.parse($.ajax.args[0][0].data).RequestInfo.command).to.equal(test.RequestInfo.command);
        expect(JSON.parse($.ajax.args[0][0].data)["Requests/resource_filters"][0].serviceName).to.equal(test["Requests/resource_filters"][0].serviceName);
      });
    });
  });
});

});

;require.register("test/controllers/main/service/reassign_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/cluster');
require('controllers/wizard');
require('controllers/main/service/reassign_controller');

describe('App.ReassignMasterController', function () {

  var reassignMasterController = App.ReassignMasterController.create({});

  describe('#totalSteps', function () {
    it('check', function () {
      expect(reassignMasterController.get('totalSteps')).to.equal(6);
    });
  });

  reassignMasterController.set('content.reassign', {service_id:null});

});

});

;require.register("test/controllers/main/service_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/service');

var mainServiceController;

describe('App.MainServiceController', function () {

  var tests = Em.A([
    {
      isStartStopAllClicked: false,
      content: Em.A([
        Em.Object.create({
          healthStatus: 'green',
          serviceName: 'HIVE',
          isClientsOnly: false
        }),
        Em.Object.create({
          healthStatus: 'green',
          serviceName: 'HDFS',
          isClientsOnly: false
        }),
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'TEZ',
          isClientsOnly: true
        })
      ]),
      eStart: true,
      eStop: false,
      mStart: 'mainServiceController StartAll is Disabled 1',
      mStop: 'mainServiceController StopAll is Enabled 1'
    },
    {
      isStartStopAllClicked: true,
      content: Em.A([
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'HIVE',
          isClientsOnly: false
        }),
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'HDFS',
          isClientsOnly: false
        }),
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'TEZ',
          isClientsOnly: true
        })
      ]),
      eStart: true,
      eStop: true,
      mStart: 'mainServiceController StartAll is Disabled 2',
      mStop: 'mainServiceController StopAll is Disabled 2'
    },
    {
      isStartStopAllClicked: false,
      content: Em.A([
        Em.Object.create({
          healthStatus: 'green',
          serviceName: 'HIVE',
          isClientsOnly: false
        }),
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'HDFS',
          isClientsOnly: false
        }),
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'TEZ',
          isClientsOnly: true
        })
      ]),
      eStart: false,
      eStop: false,
      mStart: 'mainServiceController StartAll is Enabled 3',
      mStop: 'mainServiceController StopAll is Enabled 3'
    }

  ]);
  describe('#isStartAllDisabled', function () {
    tests.forEach(function (test) {
      it(test.mStart, function () {
        mainServiceController = App.MainServiceController.create({
          content: test.content,
          isStartStopAllClicked: test.isStartStopAllClicked
        });
        expect(mainServiceController.get('isStartAllDisabled')).to.equals(test.eStart);
      });
    });
  });

  describe('#isStopAllDisabled', function () {
    tests.forEach(function (test) {
      it(test.mStop, function () {
        mainServiceController = App.MainServiceController.create({
          content: test.content,
          isStartStopAllClicked: test.isStartStopAllClicked
        });
        expect(mainServiceController.get('isStopAllDisabled')).to.equals(test.eStop);
      });
    });
  });
});

});

;require.register("test/controllers/wizard/stack_upgrade/step3_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
var Ember = require('ember');

require('models/host');
require('controllers/wizard/stack_upgrade/step3_controller');

if (!App.router) {
  App.router = Em.Object.create({});
}

App.router.set('stackUpgradeController', Em.Object.create({
  save: Em.K
}));

describe('App.StackUpgradeStep3Controller', function() {

  var stackUpgradeStep3Controller = App.StackUpgradeStep3Controller.create();

  describe('#runUpgradeErrorCallback', function() {
    var processes = [
      Ember.Object.create({
        status: '',
        isRetry: false,
        name: 'UPGRADE_SERVICES'
      })
    ];

    stackUpgradeStep3Controller.set('processes', processes);
    stackUpgradeStep3Controller.set('content', {cluster: {}, controllerName:'stackUpgradeController'});

    it('check process condition', function() {
      App.testMode = true;
      stackUpgradeStep3Controller.runUpgradeErrorCallback();
      expect(stackUpgradeStep3Controller.get('processes').findProperty('name', 'UPGRADE_SERVICES').get('status')).to.equal('FAILED');
      expect(stackUpgradeStep3Controller.get('processes').findProperty('name', 'UPGRADE_SERVICES').get('isRetry')).to.equal(true);
      expect(stackUpgradeStep3Controller.get('submitButton')).to.equal(false);
      App.testMode = false;
    });
  });

});

});

;require.register("test/controllers/wizard/step0_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/cluster_states');
require('controllers/wizard/step0_controller');
var wizardStep0Controller;

if (!App.router) {
  App.router = Em.Object.create({});
}
App.router.set('send', Em.K);

describe('App.WizardStep0Controller', function () {

  beforeEach(function() {
    wizardStep0Controller = App.WizardStep0Controller.create({content: {cluster: {}}});
    sinon.stub(App.clusterStatus, 'set', Em.K);
    sinon.spy(App.router, 'send');
  });

  afterEach(function() {
    App.clusterStatus.set.restore();
    App.router.send.restore();
  });

  describe('#invalidClusterName', function () {
    it('should return true if no cluster name is present', function () {
      wizardStep0Controller.set('hasSubmitted', true);
      wizardStep0Controller.set('content', {'cluster':{'name':''}});
      expect(wizardStep0Controller.get('invalidClusterName')).to.equal(true);
    });
    it('should return true if cluster name contains white spaces', function () {
      wizardStep0Controller.set('hasSubmitted', true);
      wizardStep0Controller.set('content', {'cluster':{'name':'the cluster'}});
      expect(wizardStep0Controller.get('invalidClusterName')).to.equal(true);
    });
    it('should return true if cluster name contains special chars', function () {
      wizardStep0Controller.set('hasSubmitted', true);
      wizardStep0Controller.set('content', {'cluster':{'name':'$cluster'}});
      expect(wizardStep0Controller.get('invalidClusterName')).to.equal(true);
    })
  });

  describe('#loadStep', function() {
    it('should clear step data', function() {
      wizardStep0Controller.loadStep();
      expect(wizardStep0Controller.get('hasSubmitted')).to.equal(false);
      expect(wizardStep0Controller.get('clusterNameError')).to.equal('');
    });
  });

  describe('#submit', function() {
    it('if cluster name is valid should proceed', function() {
      wizardStep0Controller.set('content.cluster.name', 'tdk');
      wizardStep0Controller.submit();
      expect(wizardStep0Controller.get('content.cluster.status')).to.equal('PENDING');
      expect(wizardStep0Controller.get('content.cluster.isCompleted')).to.equal(false);
      expect(App.router.send.calledWith('next')).to.equal(true);
      expect(App.clusterStatus.set.calledWith('clusterName', 'tdk')).to.equal(true);
    });

    it('if cluster name isn\'t valid shouldn\'t proceed', function() {
      wizardStep0Controller.set('content.cluster.name', '@@@@');
      wizardStep0Controller.submit();
      expect(App.router.send.called).to.equal(false);
      expect(App.clusterStatus.set.called).to.equal(false);
    });
  });

});
});

;require.register("test/controllers/wizard/step10_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var App = require('app');
require('controllers/wizard/step10_controller');

var controller;

describe('App.WizardStep10Controller', function () {

  beforeEach(function() {
    controller = App.WizardStep10Controller.create();
    controller.set('content', {cluster: {status: 'INSTALL COMPLETE'}});
  });

  afterEach(function() {
    controller.clearStep();
  });

  describe('#clearStep', function() {
    it('should clear clusterInfo', function() {
      controller.get('clusterInfo').pushObject({});
      controller.clearStep();
      expect(controller.get('clusterInfo.length')).to.equal(0);
    });
  });

  describe('#loadStep', function() {
    beforeEach(function() {
      sinon.spy(controller, 'clearStep');
      sinon.stub(controller, 'loadRegisteredHosts', Em.K);
      sinon.stub(controller, 'loadInstalledHosts', Em.K);
      sinon.stub(controller, 'loadInstallTime', Em.K);
    });
    afterEach(function() {
      controller.clearStep.restore();
      controller.loadRegisteredHosts.restore();
      controller.loadInstalledHosts.restore();
      controller.loadInstallTime.restore();
    });
    it('should call clearStep', function() {
      controller.loadStep();
      expect(controller.clearStep.calledOnce).to.equal(true);
    });
    it('should call loadInstalledHosts', function() {
      controller.loadStep();
      expect(controller.loadInstalledHosts.calledOnce).to.equal(true);
    });
    it('should loadInstallTime if not installerController', function() {
      controller.set('content.controllerName', 'addServiceController');
      controller.loadStep();
      expect(controller.loadInstallTime.calledOnce).to.equal(true);
    });
    var testsForLoadInstallTime = Em.A([
      {
        loadMasterComponents: true,
        loadStartedServices: true,
        e: true
      },
      {
        loadMasterComponents: true,
        loadStartedServices: false,
        e: false
      },
      {
        loadMasterComponents: false,
        loadStartedServices: false,
        e: false
      },
      {
        loadMasterComponents: false,
        loadStartedServices: false,
        e: false
      }
    ]);
    testsForLoadInstallTime.forEach(function(test) {
      it('loadMasterComponents: ' + test.loadMasterComponents.toString() + ' loadStartedServices: ' + test.loadStartedServices.toString(), function() {
        controller.set('content.controllerName', 'installerController');
        sinon.stub(controller, 'loadMasterComponents', function() {return test.loadMasterComponents;});
        sinon.stub(controller, 'loadStartedServices', function() {return test.loadStartedServices;});
        controller.loadStep();
        expect(controller.loadInstallTime.called).to.equal(test.e);
        controller.loadMasterComponents.restore();
        controller.loadStartedServices.restore();
      });
    });
  });

  describe('#loadInstalledHosts', function() {
    var tests = Em.A([
      {
        hosts: {
          'h1': Em.Object.create({status: 'success', tasks: []}),
          'h2': Em.Object.create({status: 'success', tasks: []}),
          'h3': Em.Object.create({status: 'success', tasks: []})
        },
        m: 'all success',
        e: Em.A([
          {id: 1, l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({status: 'warning', tasks: []}),
          'h2': Em.Object.create({status: 'failed', tasks: []}),
          'h3': Em.Object.create({status: 'failed', tasks: []})
        },
        m: 'some failed, some warning',
        e: Em.A([
          {id: 2, l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({status: 'failed', tasks: []}),
          'h2': Em.Object.create({status: 'success', tasks: []}),
          'h3': Em.Object.create({status: 'warning', tasks: []})
        },
        m: 'sone failed, some success, some warning',
        e: Em.A([
          {id: 1, l: 1},
          {id: 2, l: 2}
        ])
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        controller.set('content.hosts', test.hosts);
        controller.set('clusterInfo', Em.A([Em.Object.create({id: 1, status: []})]));
        controller.loadInstalledHosts();
        test.e.forEach(function(ex) {
          expect(controller.get('clusterInfo').findProperty('id', 1).get('status').findProperty('id', ex.id).get('displayStatement').contains(ex.l)).to.equal(true);
        });
      })
    });
    var testsForFailedTasks = Em.A([
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'FAILED'}},
              {Tasks: {status: 'FAILED'}}
            ]
          }),
          'h2': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'FAILED'}}
            ]
          }),
          'h3': Em.Object.create({status: 'failed', tasks: []})
        },
        m: 'only failed tasks',
        e: Em.A([
          {st: 'failed', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          }),
          'h2': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          }),
          'h3': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          })
        },
        m: 'only timedout tasks',
        e: Em.A([
          {st: 'timedout', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'failed',
            tasks: []
          }),
          'h2': Em.Object.create({
            status: 'failed',
            tasks: []
          }),
          'h3': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'ABORTED'}},
              {Tasks: {status: 'ABORTED'}},
              {Tasks: {status: 'ABORTED'}}
            ]
          })
        },
        m: 'only aborted tasks',
        e: Em.A([
          {st: 'aborted', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'FAILED'}},
              {Tasks: {status: 'FAILED'}}
            ]
          }),
          'h2': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'FAILED'}}
            ]
          }),
          'h3': Em.Object.create({status: 'warning', tasks: []})
        },
        m: 'only failed tasks, warning hosts',
        e: Em.A([
          {st: 'failed', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          }),
          'h2': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          }),
          'h3': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          })
        },
        m: 'only timedout tasks, warning hosts',
        e: Em.A([
          {st: 'timedout', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'warning',
            tasks: []
          }),
          'h2': Em.Object.create({
            status: 'warning',
            tasks: []
          }),
          'h3': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'ABORTED'}},
              {Tasks: {status: 'ABORTED'}},
              {Tasks: {status: 'ABORTED'}}
            ]
          })
        },
        m: 'only aborted tasks, warning hosts',
        e: Em.A([
          {st: 'aborted', l: 3}
        ])
      }
    ]);
    testsForFailedTasks.forEach(function(test) {
      it(test.m, function() {
        controller.set('content.hosts', test.hosts);
        controller.set('clusterInfo', Em.A([Em.Object.create({id: 1, status: []})]));
        controller.loadInstalledHosts();
        test.e.forEach(function(ex) {
          expect(controller.get('clusterInfo').findProperty('id', 1).get('status').findProperty('id', 2).get('statements').mapProperty('status', ex.st).length).to.equal(ex.l);
        });
      })
    });
  });

  describe('#loadMasterComponent', function() {
    var tests = Em.A([
      {
        component: Em.Object.create({hostName: 'h1'}),
        e: 1
      },
      {
        component: Em.Object.create({}),
        e: 0
      }
    ]);

    tests.forEach(function(test) {
      it(test.component.get('hostName') ? 'Has hosNBame' : 'Doesn\'t have hostName', function() {
        controller.clearStep();
        controller.get('clusterInfo').pushObject(Em.Object.create({id: 2, status: []}));
        controller.loadMasterComponent(test.component);
        expect(controller.get('clusterInfo').findProperty('id', 2).get('status').length).to.equal(test.e);
      })
    });
  });

  describe('#loadStartedServices', function() {
    var tests = Em.A([
      {
        status: 'STARTED',
        e: {
          ids: [3, 4],
          r: true
        }
      },
      {
        status: 'FAILED',
        e: {
          ids: [3],
          r: false
        }
      }
    ]);
    tests.forEach(function(test) {
      it(test.status, function() {
        controller.set('content', {cluster: {status: test.status}});
        var r = controller.loadStartedServices();
        expect(r).to.equal(test.e.r);
        expect(controller.get('clusterInfo').mapProperty('id')).to.eql(test.e.ids);
      });
    });
  });

  describe('#loadInstallTime', function() {
    var tests = Em.A([
      {
        installTime: 123,
        e: [5]
      },
      {
        installTime: null,
        e: []
      }
    ]);

    tests.forEach(function(test) {
      it('Install time' + test.installTime ? ' available' : ' not available', function() {
        controller.set('content', {cluster: {installTime: test.installTime}});
        var r = controller.loadInstallTime();
        expect(controller.get('clusterInfo').mapProperty('id')).to.eql(test.e);
      });
    });
  });

  describe('#calculateInstallTime', function () {
    it('from "9.21" to 9 minutes 12 seconds', function () {
      expect(controller.calculateInstallTime('9.21')).to.eql({minutes: 9, seconds: 12});
    });
    it('from "0" to 0 minutes 0 seconds', function () {
      expect(controller.calculateInstallTime('0')).to.eql({minutes: 0, seconds: 0});
    });
    it('from "10" to 10 minutes 0 seconds', function () {
      expect(controller.calculateInstallTime('10')).to.eql({minutes: 10, seconds: 0});
    });
    it('from "0.5" to 0 minutes 30 seconds', function () {
      expect(controller.calculateInstallTime('0.5')).to.eql({minutes: 0, seconds: 30});
    });
  });

  describe('#loadMasterComponents', function() {

    var components = Em.A(['NAMENODE','SECONDARY_NAMENODE','JOBTRACKER','HISTORYSERVER','RESOURCEMANAGER','HBASE_MASTER','HIVE_SERVER','OOZIE_SERVER','GANGLIA_SERVER','NAGIOS_SERVER']);

    d3.range(1, components.length).forEach(function(i) {
      d3.range(1, i).forEach(function(j) {
        var c = components.slice(0, j);
        it(c.join(', '), function() {
          var m = c.map(function(component){return {component: component, displayName: component, hostName: 'h1'};});
          controller.set('content.masterComponentHosts', m);
          controller.loadMasterComponents();
          expect(controller.get('clusterInfo').findProperty('id', 2).get('status').length).to.equal(m.length);
        });
      });
    });

  });

  describe('#isNagiosRestartRequired', function() {
    Em.A([
      {
        controllerName: 'addServiceController',
        isLoaded: true,
        e: true
      },
      {
        controllerName: 'installerController',
        isLoaded: true,
        e: false
      },
      {
        controllerName: 'addServiceController',
        isLoaded: false,
        e: false
      },
      {
        controllerName: 'installerController',
        isLoaded: false,
        e: false
      }
    ]).forEach(function (test) {
        it(test.controllerName + ' Nagios loaded' + test.isLoaded.toString(), function () {
          controller.set('content.controllerName', test.controllerName);
          sinon.stub(App.Service, 'find', function() {
            return Em.Object.create({
              isLoaded: test.isLoaded
            })
          });
          expect(controller.get('isNagiosRestartRequired')).to.equal(test.e);
          App.Service.find.restore();
        });
      });
  });

  describe('#loadRegisteredHosts', function() {
    it('should add object to clusterInfo', function() {
      var masterComponentHosts = [{hostName: 'h1'}, {hostName: 'h2'}, {hostName: 'h3'}],
        slaveComponentHosts = [{hosts: [{hostName: 'h1'}, {hostName: 'h4'}]}, {hosts: [{hostName: 'h2'}, {hostName: 'h5'}]}],
        hosts = [{hostName: 'h6'}, {hostName: 'h3'}, {hostName: 'h7'}];
      controller.set('content.masterComponentHosts', masterComponentHosts);
      controller.set('content.slaveComponentHosts', slaveComponentHosts);
      controller.set('clusterInfo', []);
      sinon.stub(App.Host, 'find', function() {
        return hosts;
      });
      var obj = controller.loadRegisteredHosts();
      App.Host.find.restore();
      expect(obj.id).to.equal(1);
      expect(obj.color).to.equal('text-info');
      expect(obj.displayStatement).to.equal(Em.I18n.t('installer.step10.hostsSummary').format(7));
      expect(obj.status).to.eql([]);
      expect(controller.get('clusterInfo.firstObject')).to.eql(obj);
    });
  });

});
});

;require.register("test/controllers/wizard/step2_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var Ember = require('ember');
require('controllers/wizard/step2_controller');
require('models/host');
require('models/host_component');
require('messages');
var c;
describe('App.WizardStep2Controller', function () {

  beforeEach(function() {
    c = App.WizardStep2Controller.create();
  });

  describe('#isInstaller', function() {
    it('true if controllerName is installerController', function() {
      var controller = App.WizardStep2Controller.create({content: {controllerName: 'installerController'}});
      expect(controller.get('isInstaller')).to.equal(true);
    });
    it('false if controllerName isn\'t installerController', function() {
      var controller = App.WizardStep2Controller.create({content: {controllerName: 'addServiceController'}});
      expect(controller.get('isInstaller')).to.equal(false);
    });
  });

  describe('#manualInstall', function() {
    it('should be equal to content.installOptions.manualInstall', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: true}}});
      expect(controller.get('manualInstall')).to.equal(true);
      controller.toggleProperty('content.installOptions.manualInstall');
      expect(controller.get('manualInstall')).to.equal(false);
    });
  });

  describe('#hostNames', function() {
    it('should be equal to content.installOptions.hostNames', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {hostNames: ['1','2','3']}}});
      expect(controller.get('hostNames')).to.eql(['1','2','3']);
      controller.set('content.installOptions.hostNames', ['1', '2']);
      expect(controller.get('hostNames')).to.eql(['1', '2']);
    });
  });

  describe('#sshKey', function() {
    it('should be equal to content.installOptions.sshKey', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {sshKey: '123'}}});
      expect(controller.get('sshKey')).to.equal('123');
      controller.set('content.installOptions.sshKey', '321');
      expect(controller.get('sshKey')).to.equal('321');
    });
  });

  describe('#sshUser', function() {
    it('should be equal to content.installOptions.sshUser', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {sshUser: '123'}}});
      expect(controller.get('sshUser')).to.equal('123');
      controller.set('content.installOptions.sshUser', '321');
      expect(controller.get('sshUser')).to.equal('321');
    });
  });

  describe('#installType', function() {
    it('should be manualDriven if manualInstall is selected', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: true}}});
      expect(controller.get('installType')).to.equal('manualDriven');
    });
    it('should be ambariDriven if manualInstall isn\'t selected', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: false}}});
      expect(controller.get('installType')).to.equal('ambariDriven');
    });
  });

  describe('#updateHostNameArr()', function () {

      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari'
      });
      App.store.load(App.Host, {'host_name': 'apache.ambari', id: '1'});
      controller.updateHostNameArr();

      it('should push to hostNameArr only new host names', function(){
        expect(controller.get('hostNameArr').length).to.equal(0);
      });

      it('should push to inputtedAgainHostNames already installed host names', function(){
        expect(controller.get('inputtedAgainHostNames').length).to.equal(1);
      })
  });

  describe('#isAllHostNamesValid()', function () {

    var controller = App.WizardStep2Controller.create({
      hostNames: ''
    });

    it('should return true if all host names are valid', function(){
      controller.set('hostNames', 'amache.org ambari.com');
      expect(controller.isAllHostNamesValid()).to.equal(true);
    });

    var tests = Em.A([
      'hostname',
      '-hostname.com',
      'hostname-.com',
      'host_name.com',
      '123.123.123.123',
      'hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname.hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname.hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname.hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname',
      'hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname.hostname'
    ]);
    tests.forEach(function (test) {
      it('should return false for invalid host names ' + test + ' ', function () {
        controller.set('hostNames', test);
        expect(controller.isAllHostNamesValid()).to.equal(false);
      });
    });
  });

  describe('#checkHostError()', function () {

    var controller = App.WizardStep2Controller.create();

    it('should set hostsError if hostNames is ""', function () {
      controller.set('content', {'installOptions': {'hostNames': ''}});
      controller.checkHostError();
      expect(controller.get('hostsError').length).to.be.above(2);
    });

    it('should set hostsError to null if hostNames is valid', function () {
      controller.set('content', {'installOptions': {'hostNames': 'ambari'}});
      controller.checkHostError();
      expect(controller.get('hostsError')).to.equal(null);
    })
  });

  describe('#checkHostAfterSubmitHandler()', function () {

    it('should be called after changing hasSubmitted', function (done) {
      var controller = App.WizardStep2Controller.create({
        checkHostError: function () {
          done();
        }
      });
      controller.set('hasSubmitted', true);
    });

    it('should be called after changing hostNames', function (done) {
      var controller = App.WizardStep2Controller.create({
        hasSubmitted: true,
        checkHostError: function () {
          done();
        }
      });
      controller.set('content', {'installOptions': {'hostNames': 'ambari'}});
    })
  });

  describe('#sshKeyError', function () {

    var tests = Em.A([
      {
        manualInstall: false,
        sshKey: '',
        hasSubmitted: false,
        e: null
      },
      {
        manualInstall: true,
        sshKey: '',
        hasSubmitted: false,
        e: null
      },
      {
        manualInstall: true,
        sshKey: 'nobody',
        hasSubmitted: false,
        e: null
      },
      {
        manualInstall: false,
        sshKey: 'nobody',
        hasSubmitted: false,
        e: null
      },
      {
        manualInstall: false,
        sshKey: '',
        hasSubmitted: true,
        e: null
      },
      {
        manualInstall: true,
        sshKey: '',
        hasSubmitted: true,
        e: null
      },
      {
        manualInstall: true,
        sshKey: 'nobody',
        hasSubmitted: true,
        e: null
      },
      {
        manualInstall: false,
        sshKey: 'nobody',
        hasSubmitted: true,
        e: null
      }
    ]);

    tests.forEach(function(test) {
      it(test.sshKey + ' ' + test.manualInstall.toString() + ' ' + test.hasSubmitted.toString(), function() {
        var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: test.manualInstall, sshKey: test.sshKey}}});
        if(Em.isNone(test.e)) {
          expect(controller.get('sshKeyError')).to.equal(null);
        }
        else {
          expect(controller.get('sshKeyError').length).to.be.above(2);
        }
      });
    });
  });

  describe('#sshUserError', function () {

    var tests = Em.A([
      {
        manualInstall: false,
        sshUser: '',
        e: ''
      },
      {
        manualInstall: true,
        sshUser: '',
        e: null
      },
      {
        manualInstall: true,
        sshUser: 'nobody',
        e: null
      },
      {
        manualInstall: false,
        sshUser: 'nobody',
        e: null
      }
    ]);

    tests.forEach(function(test) {
      it('', function() {
        var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: test.manualInstall, sshUser: test.sshUser}}});
        if(Em.isNone(test.e)) {
          expect(controller.get('sshUserError')).to.equal(null);
        }
        else {
          expect(controller.get('sshUserError').length).to.be.above(2);
        }
      });
    });

  });

  describe('#getHostInfo()', function () {

    it('should return object with bootStatus, installType and name for every element in hostNameArr', function () {
      var controller = App.WizardStep2Controller.create({
        hostNameArr: ['apache', 'ambari'],
        installType: 'manualDriven'
      });

      var test = controller.getHostInfo();
      expect(test).to.eql({
        'apache':{'name':'apache', 'installType': 'manualDriven', 'bootStatus': 'PENDING'},
        'ambari':{'name':'ambari', 'installType': 'manualDriven', 'bootStatus': 'PENDING'}
      });
    })
  });

  describe('#setSshKey()', function () {

    it('should set content.installOptions.sshKey', function () {
      var controller = App.WizardStep2Controller.create({
       content: {'installOptions': {'sshKey': '111'}}
      });
      controller.setSshKey('222');
      expect(controller.get('content.installOptions.sshKey')).to.equal('222');
    })
  });

  describe('#evaluateStep()', function () {

    it('should return false if isSubmitDisabled is true', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari'
      });
      controller.set('isSubmitDisabled', true);
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if hostsError is not empty', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari'
      });
      controller.set('hostsError', 'error');
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if sshKeyError is not empty', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari'
      });
      controller.set('sshKeyError', 'error');
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if hostNameArr is empty', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: ''
      });
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if isPattern is false', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari',
        isPattern: false
      });
      expect(controller.evaluateStep()).to.equal(false);
    })
  });

  describe('#parseHostNamesAsPatternExpression()', function () {

    it('should parse hosts from pattern expression to hostNameArr', function () {
      var controller = App.WizardStep2Controller.create({
        hostNameArr: ['host[001-011]']
      });
      controller.parseHostNamesAsPatternExpression();
      var result = true;
      var hosts = controller.get('hostNameArr');
      for (var i = 1; i<12; i++) {
        var extra = (i.toString().length == 1) ? 0 : '';
        if (hosts[i-1] !== 'host0' + extra + i) {
          result = false;
        }
      }
      expect(result).to.equal(true);
    })
  });

  describe('#proceedNext()', function () {

    it('should call warningPopup if not isAllHostNamesValid and no warningConfirmed', function() {
      c.reopen({
        isAllHostNamesValid: function() {
          return false;
        },
        warningPopup: Em.K
      });
      sinon.spy(c, 'warningPopup');
      var r = c.proceedNext(false);
      expect(r).to.equal(false);
      expect(c.warningPopup.calledOnce).to.equal(true);
    });

    it('should call manualInstallPopup if manualInstall is true', function () {
      c.reopen({
        hostNames: '',
        manualInstall: true,
        manualInstallPopup: Em.K
      });
      sinon.spy(c, 'manualInstallPopup');
      var r = c.proceedNext(true);
      expect(r).to.equal(false);
      expect(c.manualInstallPopup.calledOnce).to.equal(true);
    });

    it ('should save hosts and proceed next if skipBootstrap is true', function() {
      sinon.stub(App, 'get', function(k) {
        if ('skipBootstrap' === k) {
          return true;
        }
        return Em.get(App, k);
      });
      sinon.stub(App.router, 'send', Em.K);
      c.reopen({
        hostNameArr: ['h1'],
        isAllHostNamesValid: function() {return true;},
        content: {
          installOptions: {},
          hosts: null
        }
      });
      var r = c.proceedNext();
      expect(r).to.equal(true);
      expect(Em.keys(c.get('content.hosts'))).to.eql(['h1']);
      expect(App.router.send.calledWith('next')).to.equal(true);
      App.get.restore();
      App.router.send.restore();
    });

    it('should call setupBootStrap', function() {
      sinon.stub(App, 'get', function(k) {
        if ('skipBootstrap' === k) {
          return false;
        }
        return Em.get(App, k);
      });
      c.reopen({
        hostNameArr: ['h1'],
        isAllHostNamesValid: function() {return true;},
        content: {
          installOptions: {},
          hosts: null
        }
      });
      sinon.stub(c, 'setupBootStrap', Em.K);
      var r = c.proceedNext();
      expect(r).to.equal(true);
      expect(c.setupBootStrap.calledOnce).to.eql(true);
      App.get.restore();
      c.setupBootStrap.restore();
    });

  });

  describe('#isSubmitDisabled', function () {

    var controller = App.WizardStep2Controller.create({
      hostsError: '',
      sshKeyError: ''
    });

    it('should return value if hostsError is not empty', function () {
      controller.set('hostsError', 'error');
      expect(controller.get('isSubmitDisabled').length).to.above(0);
    });

    it('should return value if sshKeyError is not empty', function () {
      controller.set('sshKeyError', 'error');
      controller.set('hostsError', '');
      expect(controller.get('isSubmitDisabled').length).to.above(0);
    })
  });

  describe('#installedHostsPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(c, 'proceedNext', Em.K);
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
      c.proceedNext.restore();
    });
    it('should call App.ModalPopup.show', function() {
      c.installedHostsPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('should proceed next on primary', function() {
      c.installedHostsPopup().onPrimary();
      expect(c.proceedNext.calledOnce).to.equal(true);
    });
  });

  describe('#warningPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(c, 'proceedNext', Em.K);
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
      c.proceedNext.restore();

    });
    it('should call App.ModalPopup.show', function() {
      c.warningPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('should proceed next on primary', function() {
      c.warningPopup().onPrimary();
      expect(c.proceedNext.calledWith(true)).to.equal(true);
    });
  });

  describe('#hostNamePatternPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(c, 'proceedNext', Em.K);
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
      c.proceedNext.restore();
    });
    it('should call App.ModalPopup.show', function() {
      c.hostNamePatternPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('should proceed next on primary', function() {
      c.hostNamePatternPopup().onPrimary();
      expect(c.proceedNext.calledOnce).to.equal(true);
    });
  });

  describe('#manualInstallPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(App.router, 'send', Em.K);
      sinon.stub(c, 'saveHosts', Em.K);
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
      App.router.send.restore();
      c.saveHosts.restore();
    });
    it('should call App.ModalPopup.show', function() {
      c.manualInstallPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('should save hosts and go next on primary', function() {
      c.manualInstallPopup().onPrimary();
      expect(c.saveHosts.calledOnce).to.equal(true);
      expect(App.router.send.calledWith('next')).to.equal(true);
    });
  });

  describe('#manualInstallWarningPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
    });
    it('should call App.ModalPopup.show if content.installOptions.useSsh is false', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {useSsh: false}}});
      controller.manualInstallWarningPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('shouldn\'t call App.ModalPopup.show if content.installOptions.useSsh is true', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {useSsh: true}}});
      controller.manualInstallWarningPopup();
      expect(App.ModalPopup.show.called).to.equal(false);
    });
  });

  describe('#setAmbariJavaHome', function() {
    beforeEach(function() {
      sinon.spy($, 'ajax');
    });
    afterEach(function() {
      $.ajax.restore();
    });
    it('should do ajax-request', function() {
      var controller = App.WizardStep2Controller.create({onGetAmbariJavaHomeSuccess: Em.K, onGetAmbariJavaHomeError: Em.K});
      controller.setAmbariJavaHome();
      expect($.ajax.calledOnce).to.equal(true);
    });
  });

  describe('#onGetAmbariJavaHomeSuccess', function() {
    it('should set java.home value receiced from server', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {}}});
      var test = {RootServiceComponents: {properties: {'java.home': '/root'}}};
      controller.onGetAmbariJavaHomeSuccess(test);
      expect(controller.content.installOptions.javaHome).to.equal('/root');
    });
  });

  describe('#onGetAmbariJavaHomeError', function() {
    it('should set default java.home value', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {}}});
      controller.onGetAmbariJavaHomeError();
      expect(controller.content.installOptions.javaHome).to.equal(App.get('defaultJavaHome'));
    });
  });

  describe('#saveHosts', function() {
    beforeEach(function() {
      sinon.stub(c, 'setAmbariJavaHome', Em.K);
      c.reopen({
        hostNameArr: ['h1'],
        content: {
          hosts: null
        }
      });
    });
    afterEach(function() {
      c.setAmbariJavaHome.restore();
    });
    it('should call setAmbariJavaHome', function() {
      c.saveHosts();
      expect(c.setAmbariJavaHome.calledOnce).to.equal(true);
    });
    it('should set content.hosts', function() {
      c.saveHosts();
      expect(Em.keys(c.get('content.hosts'))).to.eql(['h1']);
    });
  });

});

});

;require.register("test/controllers/wizard/step3_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var Ember = require('ember');
var App = require('app');
var c;
require('utils/http_client');
require('models/host');
require('controllers/wizard/step3_controller');

describe('App.WizardStep3Controller', function () {

  beforeEach(function() {
    c = App.WizardStep3Controller.create({
      wizardController: App.InstallerController.create(),
      disablePreviousSteps: Em.K
    });
  });

  describe('#getAllRegisteredHostsCallback', function () {
    it('One host is already in the cluster, one host is registered', function() {
      var controller = App.WizardStep3Controller.create({
        hostsInCluster: [{
          hostName: 'wst3_host1'
        }],
        bootHosts: [
          {name:'wst3_host1'},
          {name:'wst3_host2'}
        ]
      });
      var test_data = {
        items: [
          {
            Hosts: {
              host_name: 'wst3_host1'
            }
          },
          {
            Hosts: {
              host_name: 'wst3_host2'
            }
          },
          {
            Hosts: {
              host_name: 'wst3_host3'
            }
          }
        ]
      };
      controller.getAllRegisteredHostsCallback(test_data);
      expect(controller.get('hasMoreRegisteredHosts')).to.equal(true);
      expect(controller.get('registeredHosts').length).to.equal(1);
    });

    it('All hosts are new', function() {
      var controller = App.WizardStep3Controller.create({
        hostsInCluster: [{
          hostName: 'wst3_host1'
        }],
        bootHosts: [
          {name:'wst3_host3'},
          {name:'wst3_host4'}
        ]
      });
      var test_data = {
        items: [
          {
            Hosts: {
              host_name: 'wst3_host3'
            }
          },
          {
            Hosts: {
              host_name: 'wst3_host4'
            }
          }
        ]
      };
      controller.getAllRegisteredHostsCallback(test_data);
      expect(controller.get('hasMoreRegisteredHosts')).to.equal(false);
      expect(controller.get('registeredHosts')).to.equal('');
    });

    it('No new hosts', function() {
      var controller = App.WizardStep3Controller.create({
        hostsInCluster: [{
          hostName: 'wst3_host1'
        }],
        bootHosts: [
          {name:'wst3_host1'}
        ]
      });
      var test_data = {
        items: [
          {
            Hosts: {
              host_name: 'wst3_host1'
            }
          }
        ]
      };
      controller.getAllRegisteredHostsCallback(test_data);
      expect(controller.get('hasMoreRegisteredHosts')).to.equal(false);
      expect(controller.get('registeredHosts')).to.equal('');
    });

  });

  describe('#registrationTimeoutSecs', function() {
    it('Manual install', function() {
      var controller = App.WizardStep3Controller.create({
        content: {
          installOptions: {
            manualInstall: true
          }
        }
      });
      expect(controller.get('registrationTimeoutSecs')).to.equal(15);
    });
    it('Not manual install', function() {
      var controller = App.WizardStep3Controller.create({
        content: {
          installOptions: {
            manualInstall: false
          }
        }
      });
      expect(controller.get('registrationTimeoutSecs')).to.equal(120);
    });
  });

  describe('#isHostHaveWarnings', function() {
    var tests = [
      {
        warnings: [{},{}],
        m: 'Warnings exist',
        e: true
      },
      {
        warnings: [],
        m: 'Warnings don\'t exist',
        e: false
      }
    ];
    tests.forEach(function(test) {
      var controller = App.WizardStep3Controller.create();
      controller.set('warnings', test.warnings);
      it(test.m, function() {
        expect(controller.get('isHostHaveWarnings')).to.equal(test.e);
      });
    });
  });

  describe('#isWarningsBoxVisible', function() {
    it('for testMode should be always true', function() {
      App.testMode = true;
      expect(c.get('isWarningsBoxVisible')).to.equal(true);
      App.testMode = false;
    });
    it('for "real" mode should be based on isRegistrationInProgress', function() {
      c.set('disablePreviousSteps', Em.K);
      App.testMode = false;
      c.set('isRegistrationInProgress', false);
      expect(c.get('isWarningsBoxVisible')).to.equal(true);
      c.set('isRegistrationInProgress', true);
      expect(c.get('isWarningsBoxVisible')).to.equal(false);
      App.testMode = true;
    });
  });

  describe('#clearStep', function() {
    it('should clear hosts', function() {
      c.set('hosts', [{}, {}]);
      c.clearStep();
      expect(c.get('hosts')).to.eql([]);
    });
    it('should clear bootHosts', function() {
      c.set('bootHosts', [{}, {}]);
      c.clearStep();
      expect(c.get('bootHosts').length).to.equal(0);
    });
    it('should set stopBootstrap to false', function() {
      c.set('stopBootstrap', true);
      c.clearStep();
      expect(c.get('stopBootstrap')).to.equal(false);
    });
    it('should set wizardController DBProperty bootStatus to false', function() {
      c.get('wizardController').setDBProperty('bootStatus', true);
      c.clearStep();
      expect(c.get('wizardController').getDBProperty('bootStatus')).to.equal(false);
    });
    it('should set isSubmitDisabled to true', function() {
      c.set('isSubmitDisabled', false);
      c.clearStep();
      expect(c.get('isSubmitDisabled')).to.equal(true);
    });
    it('should set isSubmitDisabled to true', function() {
      c.set('isRetryDisabled', false);
      c.clearStep();
      expect(c.get('isRetryDisabled')).to.equal(true);
    });
  });

  describe('#loadStep', function() {
    it('should set registrationStartedAt to null', function() {
      c.set('disablePreviousSteps', Em.K);
      c.set('registrationStartedAt', {});
      c.loadStep();
      expect(c.get('registrationStartedAt')).to.be.null;
    });
    it('should set isLoaded to false', function() {
      c.set('disablePreviousSteps', Em.K);
      c.set('clearStep', Em.K);
      c.set('loadHosts', Em.K);
      c.set('isLoaded', true);
      c.loadStep();
      expect(c.get('isLoaded')).to.equal(false);
    });
    it('should call clearStep', function() {
      c.set('disablePreviousSteps', Em.K);
      c.set('loadHosts', Em.K);
      sinon.spy(c, 'clearStep');
      c.loadStep();
      expect(c.get('clearStep').calledOnce).to.equal(true);
      c.clearStep.restore();
    });
    it('should call loadHosts', function() {
      c.set('disablePreviousSteps', Em.K);
      c.set('loadHosts', Em.K);
      sinon.spy(c, 'loadHosts');
      c.loadStep();
      expect(c.get('loadHosts').calledOnce).to.equal(true);
      c.loadHosts.restore();
    });
    it('should call disablePreviousSteps', function() {
      c.set('disablePreviousSteps', Em.K);
      c.set('loadHosts', Em.K);
      sinon.spy(c, 'disablePreviousSteps');
      c.loadStep();
      expect(c.get('disablePreviousSteps').calledOnce).to.equal(true);
      c.disablePreviousSteps.restore();
    });
  });

  describe('#loadHosts', function() {
    it('should set isLoaded to true', function() {
      c.set('navigateStep', Em.K);
      c.set('content', {hosts: {}});
      c.loadHosts();
      expect(c.get('isLoaded')).to.equal(true);
    });
    it('should set bootStatus REGISTERED on testMode', function() {
      App.testMode = true;
      c.set('navigateStep', Em.K);
      c.set('content', {hosts: {c: {name: 'name'}}});
      c.loadHosts();
      expect(c.get('hosts').everyProperty('bootStatus', 'REGISTERED')).to.equal(true);
    });
    it('should set bootStatus DONE on "real" mode and when installOptions.manualInstall is selected', function() {
      App.testMode = false;
      c.set('navigateStep', Em.K);
      c.set('content', {installOptions:{manualInstall: true}, hosts: {c: {name: 'name'}}});
      c.loadHosts();
      expect(c.get('hosts').everyProperty('bootStatus', 'DONE')).to.equal(true);
      App.testMode = true;
    });
    it('should set bootStatus PENDING on "real" mode and when installOptions.manualInstall is not selected', function() {
      App.testMode = false;
      c.set('navigateStep', Em.K);
      c.set('content', {installOptions:{manualInstall: false}, hosts: {c: {name: 'name'}}});
      c.loadHosts();
      expect(c.get('hosts').everyProperty('bootStatus', 'PENDING')).to.equal(true);
      App.testMode = true;
    });
    it('should set bootStatus PENDING on "real" mode and when installOptions.manualInstall is not selected', function() {
      c.set('navigateStep', Em.K);
      c.set('content', {hosts: {c: {name: 'name'}, d: {name: 'name1'}}});
      c.loadHosts();
      expect(c.get('hosts').everyProperty('isChecked', false)).to.equal(true);
    });
  });

  describe('#parseHostInfo', function() {

    var tests = Em.A([
      {
        bootHosts: Em.A([
          Em.Object.create({name: 'c1', bootStatus: 'REGISTERED', bootLog: ''}),
          Em.Object.create({name: 'c2', bootStatus: 'REGISTERING', bootLog: ''}),
          Em.Object.create({name: 'c3', bootStatus: 'RUNNING', bootLog: ''})
        ]),
        hostsStatusFromServer: Em.A([
          {hostName: 'c1', status: 'REGISTERED', log: 'c1'},
          {hostName: 'c2', status: 'REGISTERED', log: 'c2'},
          {hostName: 'c3', status: 'RUNNING', log: 'c3'}
        ]),
        m: 'bootHosts not empty, hostsStatusFromServer not empty, one is RUNNING',
        e: {
          c: true,
          r: true
        }
      },
      {
        bootHosts: Em.A([]),
        hostsStatusFromServer: Em.A([
          {hostName: 'c1', status: 'REGISTERED', log: 'c1'},
          {hostName: 'c2', status: 'REGISTERED', log: 'c2'},
          {hostName: 'c3', status: 'RUNNING', log: 'c3'}
        ]),
        m: 'bootHosts is empty',
        e: {
          c: false,
          r: false
        }
      },
      {
        bootHosts: Em.A([
          Em.Object.create({name: 'c1', bootStatus: 'REGISTERED', bootLog: ''}),
          Em.Object.create({name: 'c2', bootStatus: 'REGISTERING', bootLog: ''}),
          Em.Object.create({name: 'c3', bootStatus: 'REGISTERED', bootLog: ''})
        ]),
        hostsStatusFromServer: Em.A([
          {hostName: 'c1', status: 'REGISTERED', log: 'c1'},
          {hostName: 'c2', status: 'REGISTERED', log: 'c2'},
          {hostName: 'c3', status: 'REGISTERED', log: 'c3'}
        ]),
        m: 'bootHosts not empty, hostsStatusFromServer not empty, no one is RUNNING',
        e: {
          c: true,
          r: false
        }
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        c.set('bootHosts', test.bootHosts);
        var r = c.parseHostInfo(test.hostsStatusFromServer);
        expect(r).to.equal(test.e.r);
        if (test.e.c) {
          test.hostsStatusFromServer.forEach(function(h) {
            var r = c.get('bootHosts').findProperty('name', h.hostName);
            if (!['REGISTERED', 'REGISTERING'].contains(r.get('bootStatus'))) {
              expect(r.get('bootStatus')).to.equal(h.status);
              expect(r.get('bootLog')).to.equal(h.log);
            }
          });
        }
      });
    });
  });

  describe('#removeHosts', function() {
    it('should call App.showConfirmationPopup', function() {
      sinon.spy(App, 'showConfirmationPopup');
      c.removeHosts(Em.A([]));
      expect(App.showConfirmationPopup.calledOnce).to.equal(true);
      App.showConfirmationPopup.restore();
    });
    it('primary should disable Submit if no more hosts', function() {
      var hosts = [{}];
      c.set('hosts', hosts);
      var popup = c.removeHosts(hosts);
      popup.onPrimary();
      expect(c.get('isSubmitDisabled')).to.equal(true);
    });
  });

  describe('#removeHost', function() {
    it('should call removeHosts with array as arg', function() {
      var host = {a:''};
      sinon.spy(c, 'removeHosts');
      c.removeHost(host);
      expect(c.removeHosts.calledWith([host]));
      c.removeHosts.restore();
    });
  });

  describe('#removeSelectedHosts', function() {
    it('should remove selected hosts', function() {
      c = App.WizardStep3Controller.create({
        wizardController: App.InstallerController.create(),
        hosts: [
          {isChecked: true, name: 'c1'},
          {isChecked: false, name: 'c2'}
        ]
      });
      c.removeSelectedHosts().onPrimary();
      expect(c.get('hosts').mapProperty('name')).to.eql(['c2']);
    });
  });

  describe('#selectedHostsPopup', function() {
    it('should show App.ModalPopup', function() {
      sinon.spy(App.ModalPopup, 'show');
      c.selectedHostsPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      App.ModalPopup.show.restore();
    });
  });

  describe('#retryHosts', function () {
    var s;
    var installer = {launchBootstrap: Em.K};

    beforeEach(function () {
      sinon.spy(installer, "launchBootstrap");
      s = sinon.stub(App.router, 'get', function () {
        return installer;
      });
      sinon.stub(c, 'doBootstrap', Em.K);
    });

    afterEach(function () {
      c.doBootstrap.restore();
      s.restore();
      installer.launchBootstrap.restore();
    });

    it('should set numPolls to 0', function () {
      c.set('content', {installOptions: {}});
      c.set('numPolls', 123);
      c.retryHosts(Em.A([]));
      expect(c.get('numPolls')).to.equal(0);
    });
    it('should set registrationStartedAt to null', function () {
      c.set('content', {installOptions: {}});
      c.retryHosts(Em.A([]));
      expect(c.get('registrationStartedAt')).to.be.null;
    });
    it('should startRegistration if installOptions.manualInstall is true', function () {
      sinon.spy(c, 'startRegistration');
      c.set('content', {installOptions: {manualInstall: true}});
      c.retryHosts(Em.A([]));
      expect(c.startRegistration.calledOnce).to.equal(true);
      c.startRegistration.restore();
    });
    it('should launchBootstrap if installOptions.manualInstall is false', function () {
      c.set('content', {installOptions: {manualInstall: false}});
      c.retryHosts(Em.A([]));
      expect(installer.launchBootstrap.calledOnce).to.be.true;
    });
  });

  describe('#retryHost', function() {
    it('should callretryHosts with array as arg', function() {
      var host = {n: 'c'}, s = sinon.stub(App.router, 'get', function() {
        return {launchBootstrap: Em.K}
      });
      sinon.spy(c, 'retryHosts');
      c.set('content', {installOptions: {}});
      c.set('doBootstrap', Em.K);
      c.retryHost(host);
      expect(c.retryHosts.calledWith([host])).to.equal(true);
      c.retryHosts.restore();
      s.restore();
    });
  });

  describe('#retrySelectedHosts', function() {
    it('shouldn\'t do nothing if isRetryDisabled is true', function() {
      c.set('isRetryDisabled', true);
      sinon.spy(c, 'retryHosts');
      c.retrySelectedHosts();
      expect(c.retryHosts.called).to.equal(false);
      c.retryHosts.restore();
    });
    it('should retry hosts with FAILED bootStatus and set isRetryDisabled to true', function() {
      var s = sinon.stub(App.router, 'get', function() {
        return {launchBootstrap: Em.K}
      });
      c = App.WizardStep3Controller.create({
        wizardController: App.InstallerController.create(),
        isRetryDisabled: false,
        bootHosts: Em.A([Em.Object.create({name: 'c1', bootStatus: 'FAILED'}), Em.Object.create({name: 'c2', bootStatus: 'REGISTERED'})]),
        content: {installOptions: {}},
        doBootstrap: Em.K
      });
      sinon.spy(c, 'retryHosts');
      c.retrySelectedHosts();
      expect(c.retryHosts.calledWith([{name: 'c1', bootStatus: 'RUNNING'}]));
      expect(c.get('isRetryDisabled')).to.equal(true);
      c.retryHosts.restore();
      s.restore();
    });
  });

  describe('#startBootstrap', function() {
    it('should drop numPolls and registrationStartedAt', function() {
      c.set('numPolls', 123);
      c.set('registrationStartedAt', 1234);
      c.set('doBootstrap', Em.K);
      c.startBootstrap();
      expect(c.get('numPolls')).to.equal(0);
      expect(c.get('registrationStartedAt')).to.be.null;
    });
    it('should drop numPolls and registrationStartedAt', function() {
      var hosts = Em.A([{name: 'c1'}, {name: 'c2'}]);
      c = App.WizardStep3Controller.create({
        wizardController: App.InstallerController.create(),
        doBootstrap: Em.K,
        setRegistrationInProgressOnce: Em.K,
        hosts: hosts
      });
      c.startBootstrap();
      expect(c.get('bootHosts').mapProperty('name')).to.eql(['c1','c2']);
    });
  });

  describe('#setRegistrationInProgressOnce', function() {
    it('should call Ember.run.once with "setRegistrationInProgress"', function() {
      sinon.spy(Em.run, 'once');
      c.setRegistrationInProgressOnce();
      expect(Em.run.once.firstCall.args[1]).to.equal('setRegistrationInProgress');
      Em.run.once.restore();
    });
  });

  describe('#setRegistrationInProgress', function() {
    var tests = Em.A([
      {
        bootHosts: [],
        isLoaded: false,
        e: true,
        m: 'no bootHosts and isLoaded is false'
      },
      {
        bootHosts: [],
        isLoaded: true,
        e: false,
        m: 'no bootHosts and isLoaded is true'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'RUNNING'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: true,
        e: false,
        m: 'bootHosts without REGISTERED/FAILED and isLoaded is true'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'RUNNING'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: false,
        e: true,
        m: 'bootHosts without REGISTERED/FAILED and isLoaded is false'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'REGISTERED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: false,
        e: true,
        m: 'bootHosts with one REGISTERED and isLoaded is false'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'FAILED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: false,
        e: true,
        m: 'bootHosts with one FAILED and isLoaded is false'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'REGISTERED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: true,
        e: false,
        m: 'bootHosts with one REGISTERED and isLoaded is true'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'FAILED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: true,
        e: false,
        m: 'bootHosts with one FAILED and isLoaded is true'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        sinon.stub(c, 'disablePreviousSteps', Em.K);
        c.set('bootHosts', test.bootHosts);
        c.set('isLoaded', test.isLoaded);
        c.setRegistrationInProgress();
        expect(c.get('isRegistrationInProgress')).to.equal(test.e);
        c.disablePreviousSteps.restore();
      });
    });
  });

  describe('#doBootstrap', function() {
    beforeEach(function() {
      sinon.spy(App.ajax, 'send');
    });
    afterEach(function() {
      App.ajax.send.restore();
    });
    it('shouldn\'t do nothing if stopBootstrap is true', function() {
      c.set('stopBootstrap', true);
      c.doBootstrap();
      expect(App.ajax.send.called).to.equal(false);
    });
    it('should increment numPolls if stopBootstrap is false', function() {
      c.set('stopBootstrap', false);
      c.set('numPolls', 0);
      c.doBootstrap();
      expect(c.get('numPolls')).to.equal(1);
    });
    it('should do ajax call if stopBootstrap is false', function() {
      c.set('stopBootstrap', false);
      c.doBootstrap();
      expect(App.ajax.send.called).to.equal(true);
    });
  });

  describe('#startRegistration', function() {
    it('shouldn\'t do nothing if registrationStartedAt isn\'t null', function() {
      c.set('registrationStartedAt', 1234);
      sinon.spy(c, 'isHostsRegistered');
      c.startRegistration();
      expect(c.isHostsRegistered.called).to.equal(false);
      expect(c.get('registrationStartedAt')).to.equal(1234);
      c.isHostsRegistered.restore();
    });
    it('shouldn\'t do nothing if registrationStartedAt isn\'t null', function() {
      c.set('registrationStartedAt', null);
      sinon.spy(c, 'isHostsRegistered');
      c.startRegistration();
      expect(c.isHostsRegistered.calledOnce).to.equal(true);
      c.isHostsRegistered.restore();
    });
  });

  describe('#isHostsRegistered', function() {
    beforeEach(function() {
      sinon.spy(App.ajax, 'send');
    });
    afterEach(function() {
      App.ajax.send.restore();
    });
    it('shouldn\'t do nothing if stopBootstrap is true', function() {
      c.set('stopBootstrap', true);
      c.isHostsRegistered();
      expect(App.ajax.send.called).to.equal(false);
    });
    it('should do ajax call if stopBootstrap is false', function() {
      c.set('stopBootstrap', false);
      c.isHostsRegistered();
      expect(App.ajax.send.called).to.equal(true);

    });
  });

  describe('#isHostsRegisteredSuccessCallback', function() {
    var tests = Em.A([
      {
        bootHosts: Em.A([
          Em.Object.create({bootStatus: 'DONE'})
        ]),
        data: {items:[]},
        m: 'one host DONE',
        e: {
          bs: 'REGISTERING',
          getHostInfoCalled: false
        }
      },
      {
        bootHosts: Em.A([
          Em.Object.create({bootStatus: 'REGISTERING', name: 'c1'})
        ]),
        data: {items:[{Hosts: {host_name: 'c1'}}]},
        m: ' one host REGISTERING',
        e: {
          bs: 'FAILED',
          getHostInfoCalled: false
        }
      },
      {
        bootHosts: Em.A([
          Em.Object.create({bootStatus: 'REGISTERING', name: 'c1'})
        ]),
        data: {items:[{Hosts: {host_name: 'c2'}}]},
        m: 'one host REGISTERING but data without info about it',
        e: {
          bs: 'FAILED',
          getHostInfoCalled: false
        }
      },
      {
        bootHosts: Em.A([
          Em.Object.create({bootStatus: 'RUNNING', name: 'c1'})
        ]),
        data: {items:[{Hosts: {host_name: 'c1'}}]},
        m: ' one host RUNNING',
        e: {
          bs: 'RUNNING',
          getHostInfoCalled: false
        }
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        sinon.spy(c, 'getHostInfo');
        c.set('bootHosts', test.bootHosts);
        c.isHostsRegisteredSuccessCallback(test.data);
        expect(c.get('bootHosts')[0].get('bootStatus')).to.equal(test.e.bs);
        expect(c.getHostInfo.called).to.equal(test.e.getHostInfoCalled);
        c.getHostInfo.restore();
      });
    });
  });

  describe('#getAllRegisteredHosts', function() {
    it('should call App.ajax.send', function() {
      sinon.spy(App.ajax, 'send');
      c.getAllRegisteredHosts();
      expect(App.ajax.send.calledOnce).to.equal(true);
      App.ajax.send.restore();
    });
  });

  describe('#getAllRegisteredHostsCallback', function() {
    var tests = Em.A([
      {
        hostsInCluster: ['c3'],
        bootHosts: [{name:'c1'},{name:'c2'}],
        hosts: Em.A([
          {Hosts: {host_name:'c1'}},
          {Hosts: {host_name:'c2'}}
        ]),
        m: 'No registered hosts',
        e: {
          hasMoreRegisteredHosts: false,
          registeredHosts: ''
        }
      },
      {
        hostsInCluster: ['c4'],
        bootHosts: [{name:'c3'},{name:'c5'}],
        hosts: Em.A([
          {Hosts: {host_name:'c1'}},
          {Hosts: {host_name:'c2'}}
        ]),
        m: '2 registered hosts',
        e: {
          hasMoreRegisteredHosts: true,
          registeredHosts: ['c1','c2']
        }
      },
      {
        hostsInCluster: ['c4'],
        bootHosts: [{name:'c1'},{name:'c5'}],
        hosts: Em.A([
          {Hosts: {host_name:'c1'}},
          {Hosts: {host_name:'c2'}}
        ]),
        m: '1 registered host',
        e: {
          hasMoreRegisteredHosts: true,
          registeredHosts: ['c2']
        }
      },
      {
        hostsInCluster: ['c1'],
        bootHosts: [{name:'c3'},{name:'c5'}],
        hosts: Em.A([
          {Hosts: {host_name:'c1'}},
          {Hosts: {host_name:'c2'}}
        ]),
        m: '1 registered host (2)',
        e: {
          hasMoreRegisteredHosts: true,
          registeredHosts: ['c2']
        }
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        c.reopen({hostsInCluster: test.hostsInCluster, setRegistrationInProgress: Em.K});
        c.set('bootHosts', test.bootHosts);
        c.getAllRegisteredHostsCallback({items:test.hosts});
        expect(c.get('hasMoreRegisteredHosts')).to.equal(test.e.hasMoreRegisteredHosts);
        expect(c.get('registeredHosts')).to.eql(test.e.registeredHosts);
      });
    });
  });

  describe('#registerErrPopup', function() {
    it('should call App.ModalPopup.show', function() {
      sinon.spy(App.ModalPopup, 'show');
      c.registerErrPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      App.ModalPopup.show.restore();
    });
  });

  describe('#getHostInfo', function() {
    it('should do ajax request', function() {
      sinon.spy(App.ajax, 'send');
      c.getHostInfo();
      expect(App.ajax.send.calledOnce).to.equal(true);
      App.ajax.send.restore();
    });
  });

  describe('#getHostInfoErrorCallback', function() {
    it('should call registerErrPopup', function() {
      sinon.spy(c, 'registerErrPopup');
      c.getHostInfoErrorCallback();
      expect(c.registerErrPopup.calledOnce).to.equal(true);
      c.registerErrPopup.restore();
    });
  });

  describe('#stopRegistration', function() {
    var tests = Em.A([
      {
        bootHosts: [{bootStatus: 'REGISTERED'}, {bootStatus: 'RUNNING'}],
        e: {isSubmitDisabled: false, isRetryDisabled: true}
      },
      {
        bootHosts: [{bootStatus: 'FAILED'}, {bootStatus: 'RUNNING'}],
        e: {isSubmitDisabled: true, isRetryDisabled: false}
      },
      {
        bootHosts: [{bootStatus: 'FAILED'}, {bootStatus: 'REGISTERED'}],
        e: {isSubmitDisabled: false, isRetryDisabled: false}
      },
      {
        bootHosts: [{bootStatus: 'RUNNING'}, {bootStatus: 'RUNNING'}],
        e: {isSubmitDisabled: true, isRetryDisabled: true}
      }
    ]);
    tests.forEach(function(test) {
      it(test.bootHosts.mapProperty('bootStatus').join(', '), function() {
        c.reopen({bootHosts: test.bootHosts});
        c.stopRegistration();
        expect(c.get('isSubmitDisabled')).to.equal(test.e.isSubmitDisabled);
        expect(c.get('isRetryDisabled')).to.equal(test.e.isRetryDisabled);
      });
    });
  });

  describe('#submit', function() {
    it('if isHostHaveWarnings should show confirmation popup', function() {
      c.reopen({isHostHaveWarnings: true});
      sinon.spy(App.ModalPopup, 'show');
      c.submit();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      App.ModalPopup.show.restore();
    });
    it('if isHostHaveWarnings should show confirmation popup. on Primary should set bootHosts to content.hosts', function() {
      var bootHosts = [{name: 'c1'}];
      c.reopen({isHostHaveWarnings: true, bootHosts: bootHosts, hosts: []});
      c.submit().onPrimary();
      expect(c.get('content.hosts')).to.eql(bootHosts);
    });
    it('if isHostHaveWarnings is false should set bootHosts to content.hosts', function() {
      var bootHosts = [{name: 'c1'}];
      c.reopen({isHostHaveWarnings: false, bootHosts: bootHosts, hosts: []});
      c.submit();
      expect(c.get('content.hosts')).to.eql(bootHosts);
    });
  });

  describe('#hostLogPopup', function() {
    it('should show App.ModalPopup', function() {
      sinon.spy(App.ModalPopup, 'show');
      c.hostLogPopup({context:Em.Object.create({})});
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      App.ModalPopup.show.restore();
    });
  });

  describe('#rerunChecksSuccessCallback', function() {
    beforeEach(function() {
      sinon.stub(c, 'parseWarnings', Em.K);
    });
    afterEach(function() {
      c.parseWarnings.restore();
    });
    it('should set checksUpdateProgress to 100', function() {
      c.set('checksUpdateProgress', 0);
      c.rerunChecksSuccessCallback({});
      expect(c.get('checksUpdateProgress')).to.equal(100);
    });
    it('should set checksUpdateStatus to SUCCESS', function() {
      c.set('checksUpdateStatus', '');
      c.rerunChecksSuccessCallback({});
      expect(c.get('checksUpdateStatus')).to.equal('SUCCESS');
    });
    it('should set call parseWarnings', function() {
      c.rerunChecksSuccessCallback({});
      expect(c.parseWarnings.calledOnce).to.equal(true);
    });
  });

  describe('#rerunChecksErrorCallback', function() {
    it('should set checksUpdateProgress to 100', function() {
      c.set('checksUpdateProgress', 0);
      c.rerunChecksErrorCallback({});
      expect(c.get('checksUpdateProgress')).to.equal(100);
    });
    it('should set checksUpdateStatus to FAILED', function() {
      c.set('checksUpdateStatus', '');
      c.rerunChecksErrorCallback({});
      expect(c.get('checksUpdateStatus')).to.equal('FAILED');
    });
  });

  describe('#filterBootHosts', function() {
    var tests = Em.A([
      {
        bootHosts: [
          Em.Object.create({name: 'c1'}),
          Em.Object.create({name: 'c2'})
        ],
        data: {
          items: [
            {Hosts: {host_name: 'c1'}}
          ]
        },
        m: 'one host',
        e: ['c1']
      },
      {
        bootHosts: [
          Em.Object.create({name: 'c1'}),
          Em.Object.create({name: 'c2'})
        ],
        data: {
          items: [
            {Hosts: {host_name: 'c3'}}
          ]
        },
        m: 'no hosts',
        e: []
      },
      {
      bootHosts: [
        Em.Object.create({name: 'c1'}),
        Em.Object.create({name: 'c2'})
      ],
        data: {
        items: [
          {Hosts: {host_name: 'c1'}},
          {Hosts: {host_name: 'c2'}}
        ]
      },
      m: 'many hosts',
        e: ['c1', 'c2']
    }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        c.reopen({bootHosts: test.bootHosts});
        var filteredData = c.filterBootHosts(test.data);
        expect(filteredData.items.mapProperty('Hosts.host_name')).to.eql(test.e);
      });
    });
  });

  describe('#hostWarningsPopup', function() {
    it('should show App.ModalPopup', function() {
      sinon.stub(App.ModalPopup, 'show', Em.K);
      c.hostWarningsPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      App.ModalPopup.show.restore();
    });
    it('should clear checksUpdateStatus on primary', function() {
      c.set('checksUpdateStatus', 'not null value');
      c.hostWarningsPopup().onPrimary();
      expect(c.get('checksUpdateStatus')).to.be.null;
    });
    it('should clear checksUpdateStatus on close', function() {
      c.set('checksUpdateStatus', 'not null value');
      c.hostWarningsPopup().onClose();
      expect(c.get('checksUpdateStatus')).to.be.null;
    });
    it('should rerunChecks onSecondary', function() {
      sinon.stub(c, 'rerunChecks', Em.K);
      c.hostWarningsPopup().onSecondary();
      expect(c.rerunChecks.calledOnce).to.equal(true);
    });
  });

  describe('#registeredHostsPopup', function() {
    it('should show App.ModalPopup', function() {
      sinon.spy(App.ModalPopup, 'show');
      c.registeredHostsPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      App.ModalPopup.show.restore();
    });
  });

  describe('#parseWarnings', function() {
    it('no warnings if last_agent_env isn\'t specified', function() {
      c.set('warnings', [{}]);
      c.set('warningsByHost', [{},{}]);
      c.parseWarnings({items:[{Hosts:{host_name:'c1'}}]});
      expect(c.get('warnings')).to.eql([]);
      expect(c.get('warningsByHost.length')).to.equal(1); // default group
      expect(c.get('isWarningsLoaded')).to.equal(true);
    });

    Em.A([
        {
          m: 'parse stackFoldersAndFiles',
          tests : Em.A([
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {stackFoldersAndFiles: []}}}],
              m: 'empty stackFoldersAndFiles',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {stackFoldersAndFiles: [{name: 'n1'}]}}}],
              m: 'not empty stackFoldersAndFiles',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1'],
                  onSingleHost: true,
                  category: 'fileFolders'
                }],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts:{host_name: 'c1', last_agent_env: {stackFoldersAndFiles: [{name: 'n1'}]}}},
                {Hosts:{host_name: 'c2', last_agent_env: {stackFoldersAndFiles: [{name: 'n1'}]}}}
              ],
              m: 'not empty stackFoldersAndFiles on two hosts',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1', 'c2'],
                  onSingleHost: false,
                  category: 'fileFolders'
                }],
                warningsByHost: [1]
              }
            }
          ])
        },
        {
          m: 'parse installedPackages',
          tests : Em.A([
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {installedPackages: []}}}],
              m: 'empty installedPackages',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {installedPackages: [{name: 'n1'}]}}}],
              m: 'not empty installedPackages',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1'],
                  onSingleHost: true,
                  category: 'packages'
                }],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts:{host_name: 'c1', last_agent_env: {installedPackages: [{name: 'n1'}]}}},
                {Hosts:{host_name: 'c2', last_agent_env: {installedPackages: [{name: 'n1'}]}}}
              ],
              m: 'not empty installedPackages on two hosts',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1', 'c2'],
                  onSingleHost: false,
                  category: 'packages'
                }],
                warningsByHost: [1]
              }
            }
          ])
        },
        {
          m: 'parse hostHealth.liveServices',
          tests : Em.A([
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {hostHealth: []}}}],
              m: 'empty hostHealth',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {hostHealth:{liveServices: []}}}}],
              m: 'empty liveServices',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {hostHealth:{liveServices: [{status: 'Unhealthy', name: 'n1'}]}}}}],
              m: 'not empty hostHealth.liveServices',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1'],
                  onSingleHost: true,
                  category: 'services'
                }],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts:{host_name: 'c1', last_agent_env: {hostHealth:{liveServices: [{status: 'Unhealthy', name: 'n1'}]}}}},
                {Hosts:{host_name: 'c2', last_agent_env: {hostHealth:{liveServices: [{status: 'Unhealthy', name: 'n1'}]}}}}
              ],
              m: 'not empty hostHealth.liveServices on two hosts',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1', 'c2'],
                  onSingleHost: false,
                  category: 'services'
                }],
                warningsByHost: [1, 1]
              }
            }
          ])
        },
        {
          m: 'parse existingUsers',
          tests : Em.A([
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {existingUsers: []}}}],
              m: 'empty existingUsers',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {existingUsers: [{userName: 'n1'}]}}}],
              m: 'not empty existingUsers',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1'],
                  onSingleHost: true,
                  category: 'users'
                }],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts:{host_name: 'c1', last_agent_env: {existingUsers: [{userName: 'n1'}]}}},
                {Hosts:{host_name: 'c2', last_agent_env: {existingUsers: [{userName: 'n1'}]}}}
              ],
              m: 'not empty existingUsers on two hosts',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1', 'c2'],
                  onSingleHost: false,
                  category: 'users'
                }],
                warningsByHost: [1, 1]
              }
            }
          ])
        },
        {
          m: 'parse alternatives',
          tests : Em.A([
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {alternatives: []}}}],
              m: 'empty alternatives',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {alternatives: [{name: 'n1'}]}}}],
              m: 'not empty alternatives',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1'],
                  onSingleHost: true,
                  category: 'alternatives'
                }],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts:{host_name: 'c1', last_agent_env: {alternatives: [{name: 'n1'}]}}},
                {Hosts:{host_name: 'c2', last_agent_env: {alternatives: [{name: 'n1'}]}}}
              ],
              m: 'not empty alternatives on two hosts',
              e: {
                warnings: [{
                  name: 'n1',
                  hosts: ['c1', 'c2'],
                  onSingleHost: false,
                  category: 'alternatives'
                }],
                warningsByHost: [1, 1]
              }
            }
          ])
        },
        {
          m: 'parse hostHealth.activeJavaProcs',
          tests : Em.A([
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {hostHealth: [], javaProcs: []}}}],
              m: 'empty hostHealth',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {hostHealth:{activeJavaProcs: []}}}}],
              m: 'empty activeJavaProcs',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [{Hosts:{host_name: 'c1', last_agent_env: {hostHealth:{activeJavaProcs: [{pid: 'n1', command: ''}]}}}}],
              m: 'not empty hostHealth.activeJavaProcs',
              e: {
                warnings: [{
                  pid: 'n1',
                  hosts: ['c1'],
                  onSingleHost: true,
                  category: 'processes'
                }],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts:{host_name: 'c1', last_agent_env: {hostHealth:{activeJavaProcs: [{pid: 'n1', command: ''}]}}}},
                {Hosts:{host_name: 'c2', last_agent_env: {hostHealth:{activeJavaProcs: [{pid: 'n1', command: ''}]}}}}
              ],
              m: 'not empty hostHealth.activeJavaProcs on two hosts',
              e: {
                warnings: [{
                  pid: 'n1',
                  hosts: ['c1', 'c2'],
                  onSingleHost: false,
                  category: 'processes'
                }],
                warningsByHost: [1, 1]
              }
            }
          ])
        }
    ]).forEach(function(category) {
      describe(category.m, function() {
        category.tests.forEach(function(test) {
          it(test.m, function() {
            c.parseWarnings({items: test.items});
            c.get('warnings').forEach(function(w, i) {
              Em.keys(test.e.warnings[i]).forEach(function(k) {
                expect(w[k]).to.eql(test.e.warnings[i][k]);
              });
            });
            for(var i in test.e.warningsByHost) {
              if(test.e.warningsByHost.hasOwnProperty(i)) {
                expect(c.get('warningsByHost')[i].warnings.length).to.equal(test.e.warningsByHost[i]);
              }
            }
          });
        });
      });
    });

  });

  describe('#hostsInCluster', function() {
    it('should load data from App.Host model', function() {
      var hosts = [
        Em.Object.create({hostName: 'h1'}),
        Em.Object.create({hostName: 'h2'}),
        Em.Object.create({hostName: 'h3'})
      ], expected = ['h1', 'h2', 'h3'];
      sinon.stub(App.Host, 'find', function() {
        return hosts;
      });
      expect(c.get('hostsInCluster')).to.eql(expected);
      App.Host.find.restore();
    });
  });

  describe('#navigateStep', function() {
    Em.A([
        {
          isLoaded: true,
          manualInstall: false,
          bootStatus: false,
          m: 'should call startBootstrap',
          e: true
        },
        {
          isLoaded: true,
          manualInstall: false,
          bootStatus: true,
          m: 'shouldn\'t call startBootstrap (1)',
          e: false
        },
        {
          isLoaded: false,
          manualInstall: false,
          bootStatus: false,
          m: 'shouldn\'t call startBootstrap (2)',
          e: false
        },
        {
          isLoaded: false,
          manualInstall: true,
          bootStatus: false,
          m: 'shouldn\'t call startBootstrap (3)',
          e: false
        }
    ]).forEach(function(test) {
        it(test.m, function() {
          c.reopen({
            isLoaded: test.isLoaded,
            content: {
              installOptions: {
                manualInstall: test.manualInstall
              }
            },
            wizardController: Em.Object.create({
              getDBProperty: function() {
                return test.bootStatus
              }
            })
          });
          sinon.stub(c, 'startBootstrap', Em.K);
          c.navigateStep();
          if(test.e) {
            expect(c.startBootstrap.calledOnce).to.equal(true);
          }
          else {
            expect(c.startBootstrap.called).to.equal(false);
          }
          c.startBootstrap.restore();
        });
      });

    it('should set test data if testMode is true', function() {
      c.reopen({
        isLoaded: true,
        hosts: [{}, {}, {}],
        content: {
          installOptions: {
            manualInstall: true
          }
        },
        setRegistrationInProgress: Em.K
      });
      sinon.stub(App, 'get', function(k) {
        if('testMode' === k) return true;
        return Em.get(App, k);
      });
      c.navigateStep();
      App.get.restore();
      expect(c.get('bootHosts.length')).to.equal(c.get('hosts.length'));
      expect(c.get('bootHosts').everyProperty('cpu', '2')).to.equal(true);
      expect(c.get('bootHosts').everyProperty('memory', '2000000')).to.equal(true);
      expect(c.get('isSubmitDisabled')).to.equal(false);
    });

    it('should start registration', function() {
      c.reopen({
        isLoaded: true,
        hosts: [{}, {}, {}],
        content: {
          installOptions: {
            manualInstall: true
          }
        },
        setRegistrationInProgress: Em.K,
        startRegistration: Em.K
      });
      sinon.spy(c, 'startRegistration');
      sinon.stub(App, 'get', function(k) {
        if('testMode' === k) return false;
        return Em.get(App, k);
      });
      c.navigateStep();
      App.get.restore();
      expect(c.startRegistration.calledOnce).to.equal(true);
      expect(c.get('bootHosts.length')).to.equal(c.get('hosts.length'));
      expect(c.get('registrationStartedAt')).to.be.null;
      c.startRegistration.restore();
    });

  });

  describe('#checkHostDiskSpace', function() {
    Em.A([
        {
          diskInfo: [
            {
              available: App.minDiskSpace * 1024 * 1024 - 1024,
              mountpoint: '/'
            }
          ],
          m: 'available less than App.minDiskSpace',
          e: false
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 - 1024,
              mountpoint: '/usr'
            }
          ],
          m: 'available less than App.minDiskSpaceUsrLib (1)',
          e: false
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 - 1024,
              mountpoint: '/usr/lib'
            }
          ],
          m: 'available less than App.minDiskSpaceUsrLib (2)',
          e: false
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpace * 1024 * 1024 + 1024,
              mountpoint: '/'
            }
          ],
          m: 'available greater than App.minDiskSpace',
          e: true
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 + 1024,
              mountpoint: '/usr'
            }
          ],
          m: 'available greater than App.minDiskSpaceUsrLib (1)',
          e: true
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 + 1024,
              mountpoint: '/usr/lib'
            }
          ],
          m: 'available greater than App.minDiskSpaceUsrLib (2)',
          e: true
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 + 1024,
              mountpoint: '/home/tdk'
            }
          ],
          m: 'mount point without free space checks',
          e: true
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          var r = c.checkHostDiskSpace('', test.diskInfo);
          expect(Em.isEmpty(r)).to.equal(test.e);
        });
      });
  });

  describe('#checkHostOSType', function() {
    it('should return empty string if no stacks provided', function() {
      c.reopen({content: {stacks: null}});
      expect(c.checkHostOSType()).to.equal('');
    });
    it('os type is valid', function() {
      var osType = 'redhat6';
      c.reopen({
        content: {
          stacks: [
            Em.Object.create({isSelected: true, operatingSystems: [{selected: true, osType: osType}]})
          ]
        }
      });
      expect(c.checkHostOSType(osType, '')).to.equal('');
    });
    it('os type is invalid', function() {
      var osType = 'os2';
      c.reopen({
        content: {
          stacks: [
            Em.Object.create({isSelected: true, operatingSystems: [{selected: true, osType: 'os1'}]})
          ]
        }
      });
      expect(Em.isEmpty(c.checkHostOSType(osType, ''))).to.equal(false);
    });
  });

  describe('#getHostInfoSuccessCallback', function() {

    beforeEach(function() {
      sinon.stub(c, 'parseWarnings', Em.K);
      sinon.stub(c, 'stopRegistration', Em.K);
    });

    afterEach(function() {
      c.parseWarnings.restore();
      c.stopRegistration.restore();
    });

    it('should call _setHostDataWithSkipBootstrap if skipBootstrap is true', function() {
      sinon.spy(c, '_setHostDataWithSkipBootstrap');
      sinon.stub(App, 'get', function(k) {
        if ('skipBootstrap' === k) return true;
        return Em.get(App, k);
      });
      c.reopen({
        bootHosts: [Em.Object.create({name: 'h1'})]
      });
      var jsonData = {items: [{Hosts: {host_name: 'h1'}}]};
      c.getHostInfoSuccessCallback(jsonData);
      expect(c._setHostDataWithSkipBootstrap.calledOnce).to.equal(true);
      App.get.restore();
      c._setHostDataWithSkipBootstrap.restore();
    });

    it('should add repo warnings', function() {

      var jsonData = {items: [{Hosts: {host_name: 'h1'}}]};

      sinon.stub(c, 'checkHostOSType', function() {return 'not_null_value';});
      sinon.stub(c, 'checkHostDiskSpace', Em.K);
      sinon.stub(c, '_setHostDataFromLoadedHostInfo', Em.K);

      sinon.stub(App, 'get', function(k) {
        if ('skipBootstrap' === k) return false;
        return Em.get(App, k);
      });

      c.reopen({
        bootHosts: [Em.Object.create({name: 'h1'})]
      });

      c.getHostInfoSuccessCallback(jsonData);
      expect(c.get('repoCategoryWarnings.length')).to.equal(1);
      expect(c.get('repoCategoryWarnings.firstObject.hostsNames').contains('h1')).to.equal(true);

      c.checkHostOSType.restore();
      c.checkHostDiskSpace.restore();
      c._setHostDataFromLoadedHostInfo.restore();
      App.get.restore();
    });

    it('should add disk warnings', function() {

      var jsonData = {items: [{Hosts: {host_name: 'h1'}}]};

      sinon.stub(c, 'checkHostDiskSpace', function() {return 'not_null_value';});
      sinon.stub(c, 'checkHostOSType', Em.K);
      sinon.stub(c, '_setHostDataFromLoadedHostInfo', Em.K);

      sinon.stub(App, 'get', function(k) {
        if ('skipBootstrap' === k) return false;
        return Em.get(App, k);
      });

      c.reopen({
        bootHosts: [Em.Object.create({name: 'h1'})]
      });

      c.getHostInfoSuccessCallback(jsonData);
      expect(c.get('diskCategoryWarnings.length')).to.equal(1);
      expect(c.get('diskCategoryWarnings.firstObject.hostsNames').contains('h1')).to.equal(true);

      c.checkHostOSType.restore();
      c.checkHostDiskSpace.restore();
      c._setHostDataFromLoadedHostInfo.restore();
      App.get.restore();
    });

  });

  describe('#_setHostDataWithSkipBootstrap', function() {
    it('should set mock-data', function() {
      var host = Em.Object.create({});
      c._setHostDataWithSkipBootstrap(host);
      expect(host.get('cpu')).to.equal(2);
      expect(host.get('memory')).to.equal('2000000.00');
      expect(host.get('disk_info.length')).to.equal(4);
    });
  });

  describe('#_setHostDataFromLoadedHostInfo', function() {
    it('should set data from hostInfo', function() {
      var host = Em.Object.create(),
        hostInfo = {
          Hosts: {
            cpu_count: 2,
            total_mem: 12345,
            os_type: 't1',
            os_arch: 'os1',
            ip: '0.0.0.0',
            disk_info: [
              {mountpoint: '/boot'},
              {mountpoint: '/usr'},
              {mountpoint: '/no-boot'},
              {mountpoint: '/boot'}
            ]
          }
        };
      c._setHostDataFromLoadedHostInfo(host, hostInfo);
      expect(host.get('cpu')).to.equal(2);
      expect(host.get('os_type')).to.equal('t1');
      expect(host.get('os_arch')).to.equal('os1');
      expect(host.get('ip')).to.equal('0.0.0.0');
      expect(host.get('memory')).to.equal('12345.00');
      expect(host.get('disk_info.length')).to.equal(2);
    });
  });

});

});

;require.register("test/controllers/wizard/step4_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');
require('controllers/wizard/step4_controller');

describe('App.WizardStep4Controller', function () {

  var services = [
    'HDFS', 'MAPREDUCE', 'NAGIOS', 'GANGLIA', 'OOZIE', 'HIVE', 'HBASE', 'PIG', 'SCOOP', 'ZOOKEEPER', 'HCATALOG',
    'WEBHCAT', 'YARN', 'MAPREDUCE2', 'FALCON', 'TEZ', 'STORM'
  ];

  var controller = App.WizardStep4Controller.create();
  services.forEach(function(serviceName, index){
    controller.pushObject(Ember.Object.create({
      'serviceName':serviceName, 'isSelected': true, 'canBeSelected': true, 'isInstalled': false, 'isDisabled': 'HDFS' === serviceName
    }));
  });

  describe('#isSubmitDisabled', function () {
    it('should return false if at least one selected service is not installed', function () {
      expect(controller.get('isSubmitDisabled')).to.equal(false);
    });
    it('should return true if all selected services are already installed', function () {
      controller.setEach('isInstalled', true);
      controller.findProperty('serviceName', 'HDFS').set('isSelected', false);
      expect(controller.get('isSubmitDisabled')).to.equal(true);
    });
  });

  describe('#isAll', function () {
    it('should return true if all services are selected', function () {
      controller.findProperty('serviceName', 'HDFS').set('isSelected', true);
      expect(controller.get('isAll')).to.equal(true);
    });

    it('should return false if at least one service is not selected', function () {
      controller.findProperty('serviceName', 'HDFS').set('isSelected', false);
      expect(controller.get('isAll')).to.equal(false);
    });
  });

  describe('#isMinimum', function () {
    it('should return true if there are no services selected, except disabled', function () {
      controller.setEach('isSelected', false);
      expect(controller.get('isMinimum')).to.equal(true);
    });

    it('should return false if at least one service is selected, except disabled', function () {
      controller.findProperty('serviceName', 'MAPREDUCE').set('isSelected', true);
      expect(controller.get('isMinimum')).to.equal(false);
    });
  });

  describe('#selectAll()', function () {
    it('should select all services', function () {
      controller.setEach('isSelected', false);
      controller.selectAll();
      expect(controller.filterProperty('canBeSelected', true).everyProperty('isSelected', true)).to.equal(true);
    });
  });

  describe('#selectMinimum()', function () {
    it('should set isSelected false for all not disabled services', function () {
      controller.setEach('isSelected', true);
      controller.selectMinimum();
      expect(controller.findProperty('serviceName', 'HDFS').get('isSelected')).to.equal(true);
      expect(controller.filterProperty('isDisabled', false).everyProperty('isSelected', false)).to.equal(true);
    });
  });

  describe('#needToAddMapReduce()', function () {
    it('should return true if Pig is selected and MapReduce is not selected', function () {
      controller.setEach('isSelected', false);
      controller.findProperty('serviceName', 'PIG').set('isSelected', true);
      expect(controller.needToAddMapReduce()).to.equal(true);
    });

    it('should return true if Oozie is selected and MapReduce is not selected', function () {
      controller.setEach('isSelected', false);
      controller.findProperty('serviceName', 'OOZIE').set('isSelected', true);
      expect(controller.needToAddMapReduce()).to.equal(true);
    });

    it('should return true if Hive is selected and MapReduce is not selected', function () {
      controller.setEach('isSelected', false);
      controller.findProperty('serviceName', 'HIVE').set('isSelected', true);
      expect(controller.needToAddMapReduce()).to.equal(true);
    });

    it('should return false if MapReduce is selected or Pig, Oozie and Hive are not selected', function () {
      controller.findProperty('serviceName', 'MAPREDUCE').set('isSelected', true);
      expect(controller.needToAddMapReduce()).to.equal(false);
      controller.setEach('isSelected', false);
      expect(controller.needToAddMapReduce()).to.equal(false);
    });
  });

  describe('#needToAddYarnMapReduce2()', function () {
    it('should return true if Pig is selected and YARN+MapReduce2 is not selected', function () {
      controller.setEach('isSelected', false);
      controller.findProperty('serviceName', 'PIG').set('isSelected', true);
      expect(controller.needToAddYarnMapReduce2()).to.equal(true);
    });

    it('should return true if Oozie is selected and YARN+MapReduce2 is not selected', function () {
      controller.setEach('isSelected', false);
      controller.findProperty('serviceName', 'OOZIE').set('isSelected', true);
      expect(controller.needToAddYarnMapReduce2()).to.equal(true);
    });

    it('should return true if Hive is selected and YARN+MapReduce2 is not selected', function () {
      controller.setEach('isSelected', false);
      controller.findProperty('serviceName', 'HIVE').set('isSelected', true);
      expect(controller.needToAddYarnMapReduce2()).to.equal(true);
    });

    it('should return false if YARN+MapReduce2 is selected or Pig, Oozie and Hive are not selected', function () {
      controller.findProperty('serviceName', 'YARN').set('isSelected', true);
      expect(controller.needToAddYarnMapReduce2()).to.equal(false);
      controller.setEach('isSelected', false);
      expect(controller.needToAddYarnMapReduce2()).to.equal(false);
    });
  });

  describe('#needToAddZooKeeper()', function () {
    beforeEach(function() {
      ajax_send = App.ajax.send;
      App.ajax.send = function() {};
    });

    afterEach(function() {
      App.ajax.send = ajax_send;
    });
    var originalStackVersion = App.get('currentStackVersion');

    it('should return false if ZOOKEEPER is selected and Hadoop version above 2', function () {
      App.set('currentStackVersion', 'HDP-2.1.1');
      controller.findProperty('serviceName', 'ZOOKEEPER').set('isSelected', true);
      expect(controller.needToAddZooKeeper()).to.equal(false);
    });
    it('should return true if ZOOKEEPER is not selected and Hadoop version above 2', function () {
      controller.findProperty('serviceName', 'ZOOKEEPER').set('isSelected', false);
      expect(controller.needToAddZooKeeper()).to.equal(true);
    });
    it('should return false if none of the HBASE, HIVE, WEBHCAT, STORM is selected and Hadoop version below 2', function () {
      App.set('currentStackVersion', 'HDP-1.3.0');
      expect(controller.needToAddZooKeeper()).to.equal(false);
    });
    it('should return true if HBASE is not selected and Hadoop version below 2', function () {
      controller.findProperty('serviceName', 'HBASE').set('isSelected', true);
      expect(controller.needToAddZooKeeper()).to.equal(true);
    });
    it('should return true if HBASE, HIVE, WEBHCAT, STORM are selected and Hadoop version below 2', function () {
      controller.findProperty('serviceName', 'HIVE').set('isSelected', true);
      controller.findProperty('serviceName', 'WEBHCAT').set('isSelected', true);
      controller.findProperty('serviceName', 'STORM').set('isSelected', true);
      expect(controller.needToAddZooKeeper()).to.equal(true);
      App.set('currentStackVersion', originalStackVersion);
    });
  });

  describe('#gangliaOrNagiosNotSelected()', function () {
    it('should return true if Nagios or Ganglia is not selected', function () {
      controller.setEach('isSelected', true);
      controller.findProperty('serviceName', 'NAGIOS').set('isSelected', false);
      expect(controller.gangliaOrNagiosNotSelected()).to.equal(true);
      controller.setEach('isSelected', true);
      controller.findProperty('serviceName', 'GANGLIA').set('isSelected', false);
      expect(controller.gangliaOrNagiosNotSelected()).to.equal(true);
    });

    it('should return false if Nagios and Ganglia is selected', function () {
      controller.setEach('isSelected', false);
      controller.findProperty('serviceName', 'GANGLIA').set('isSelected', true);
      controller.findProperty('serviceName', 'NAGIOS').set('isSelected', true);
      expect(controller.gangliaOrNagiosNotSelected()).to.equal(false);
    });
  });

  describe('#needToAddTez()', function () {
    it('should return false if YARN is present, but not selected', function () {
      controller.findProperty('serviceName', 'YARN').set('isSelected', false);
      expect(controller.needToAddTez()).to.equal(false);
    });
    it('should return true if YARN is selected', function () {
      controller.findProperty('serviceName', 'YARN').set('isSelected', true);
      expect(controller.needToAddTez()).to.equal(true);
    });
  });

  describe('#needToAddOozie()', function () {
    it('should return false if FALCON is present, but not selected', function () {
      controller.findProperty('serviceName', 'FALCON').set('isSelected', false);
      expect(controller.needToAddOozie()).to.equal(false);
    });
    it('should return true if FALCON is selected', function () {
      controller.findProperty('serviceName', 'FALCON').set('isSelected', true);
      expect(controller.needToAddOozie()).to.equal(true);
    });
  });

  describe('#noDFSs()', function () {
    it('should return true if HDFS is not selected and GLUSTERFS is absent', function () {
      controller.findProperty('serviceName', 'HDFS').set('isSelected', false);
      expect(controller.noDFSs()).to.equal(true);
    });
    it('should return false if HDFS is selected and GLUSTERFS is absent', function () {
      controller.findProperty('serviceName', 'HDFS').set('isSelected', true);
      expect(controller.noDFSs()).to.equal(false);
    });
    it('should return true if HDFS is not selected and GLUSTERFS is not selected, but present', function () {
      controller.pushObject(Ember.Object.create({
        'serviceName':'GLUSTERFS', 'isSelected': false, 'canBeSelected': true, 'isInstalled': false, 'isDisabled': false
      }));
      controller.findProperty('serviceName', 'HDFS').set('isSelected', false);
      expect(controller.noDFSs()).to.equal(true);
    });
    it('should return false if HDFS is not selected and GLUSTERFS is selected', function () {
      controller.findProperty('serviceName', 'GLUSTERFS').set('isSelected', true);
      expect(controller.noDFSs()).to.equal(false);
    });
  });

  describe('#multipleDFSs()', function () {
    it('should return true if HDFS is selected and GLUSTERFS is selected', function () {
      controller.findProperty('serviceName', 'HDFS').set('isSelected', true);
      controller.findProperty('serviceName', 'GLUSTERFS').set('isSelected', true);
      expect(controller.multipleDFSs()).to.equal(true);
    });
    it('should return false if HDFS is not selected and GLUSTERFS is selected', function () {
      controller.findProperty('serviceName', 'HDFS').set('isSelected', false);
      expect(controller.multipleDFSs()).to.equal(false);
    });
    it('should return false if HDFS is selected and GLUSTERFS is not selected', function () {
      controller.findProperty('serviceName', 'HDFS').set('isSelected', true);
      controller.findProperty('serviceName', 'GLUSTERFS').set('isSelected', false);
      expect(controller.multipleDFSs()).to.equal(false);
    });
  });

  describe('#checkDependencies()', function () {
    var testCases = [
      {
        title: 'should set HCATALOG and WEBHCAT isSelected to true when HIVE is selected',
        condition: {
          'HBASE': true,
          'ZOOKEEPER': true,
          'HIVE': true,
          'HCATALOG': true,
          'WEBHCAT': true
        },
        result: {
          'HCATALOG': true,
          'WEBHCAT': true
        }
      },
      {
        title: 'should set HCATALOG and WEBHCAT isSelected to false when HIVE is not selected',
        condition: {
          'HBASE': true,
          'ZOOKEEPER': true,
          'HIVE': false,
          'HCATALOG': true,
          'WEBHCAT': true
        },
        result: {
          'HCATALOG': false,
          'WEBHCAT': false
        }
      },
      {
        title: 'should set MAPREDUCE2 isSelected to true when YARN is selected',
        condition: {
          'HBASE': true,
          'ZOOKEEPER': true,
          'HIVE': false,
          'HCATALOG': true,
          'WEBHCAT': true,
          'YARN': true,
          'MAPREDUCE2': true
        },
        result: {
          'MAPREDUCE2': true,
          'HCATALOG': false,
          'WEBHCAT': false
        }
      },
      {
        title: 'should set MAPREDUCE2 isSelected to false when YARN is not selected',
        condition: {
          'HBASE': true,
          'ZOOKEEPER': true,
          'HIVE': true,
          'HCATALOG': true,
          'WEBHCAT': true,
          'YARN': false,
          'MAPREDUCE2': true
        },
        result: {
          'MAPREDUCE2': false,
          'HCATALOG': true,
          'WEBHCAT': true
        }
      }
    ];

    testCases.forEach(function(testCase){
      it(testCase.title, function () {
        controller.clear();
        for(var id in testCase.condition) {
          controller.pushObject(Ember.Object.create({
            'serviceName':id, 'isSelected': testCase.condition[id], 'canBeSelected': true, 'isInstalled': false
          }));
        }
        controller.checkDependencies();
        for(var service in testCase.result) {
          expect(controller.findProperty('serviceName', service).get('isSelected')).to.equal(testCase.result[service]);
        }
      });
    }, this);
  });

  describe('#monitoringCheckPopup', function() {
    it('should show App.ModalPopup', function() {
      sinon.spy(App.ModalPopup, 'show');
      controller.monitoringCheckPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      App.ModalPopup.show.restore();
    });
    it('onPrimary should proceed to next step', function() {
      sinon.stub(App.router, 'send', Em.K);
      controller.monitoringCheckPopup().onPrimary();
      expect(App.router.send.calledWith('next')).to.equal(true);
      App.router.send.restore();
    });
  });

  describe('#needToAddServicePopup', function() {
    Em.A([
        {
          m: 'one service',
          services: {selected: true, serviceName: 's1'},
          content: [Em.Object.create({serviceName: 's1', isSelected: false})],
          e: [true]
        },
        {
          m: 'many services',
          services: [{selected: true, serviceName: 's1'}, {selected: false, serviceName: 's2'}],
          content: [Em.Object.create({serviceName: 's1', isSelected: false}),
            Em.Object.create({serviceName: 's2', isSelected: true})],
          e: [true, false]
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          sinon.stub(controller, 'submit', Em.K);
          controller.set('content', test.content);
          controller.needToAddServicePopup(test.services, '').onPrimary();
          expect(controller.submit.calledOnce).to.equal(true);
          expect(controller.mapProperty('isSelected')).to.eql(test.e);
          controller.submit.restore();
        });
      });
  });

  describe('#validateMonitoring', function() {
    Em.A([
        {
          gangliaOrNagiosNotSelected: true,
          e: {
            monitoringCheckPopup: true,
            send: false
          }
        },
        {
          gangliaOrNagiosNotSelected: false,
          e: {
            monitoringCheckPopup: false,
            send: true
          }
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          sinon.stub(controller, 'monitoringCheckPopup', Em.K);
          sinon.stub(App.router, 'send', Em.K);
          sinon.stub(controller, 'gangliaOrNagiosNotSelected', function() {
            return test.gangliaOrNagiosNotSelected;
          });
          controller.validateMonitoring();
          if (test.e.monitoringCheckPopup) {
           expect(controller.monitoringCheckPopup.calledOnce).to.equal(true);
          }
          else {
            expect(controller.monitoringCheckPopup.called).to.equal(false);
          }
          if (test.e.send) {
            expect(App.router.send.calledWith('next')).to.equal(true);
          }
          else {
            expect(App.router.send.called).to.equal(false);
          }
          controller.gangliaOrNagiosNotSelected.restore();
          controller.monitoringCheckPopup.restore();
          App.router.send.restore();
        });
      });
  });

  describe('#submit', function() {
    beforeEach(function() {
      sinon.stub(controller, 'validateMonitoring', Em.K);
    });
    afterEach(function() {
      controller.validateMonitoring.restore();
    });
    it('if not isSubmitDisabled shound\'t do nothing', function() {
      controller.reopen({isSubmitDisabled: true});
      controller.submit();
      expect(controller.validateMonitoring.called).to.equal(false);
    });
    it('if isSubmitDisabled and not submitChecks should call validateMonitoring', function() {
      controller.reopen({
        isSubmitDisabled: false,
        submitChecks: []
      });
      controller.submit();
      expect(controller.validateMonitoring.calledOnce).to.equal(true);
    });
    it('if isSubmitDisabled and some submitChecks true shouldn\'t call validateMonitoring', function() {
      controller.reopen({
        isSubmitDisabled: false,
        submitChecks: [
          {
            checkCallback: 'needToAddMapReduce',
            popupParams: [
              {serviceName: 'MAPREDUCE', selected: true},
              'mapreduceCheck'
            ]
          }
        ]
      });
      sinon.stub(controller, 'needToAddMapReduce', function() {return true;});
      controller.submit();
      expect(controller.validateMonitoring.called).to.equal(false);
      controller.needToAddMapReduce.restore();
    });
    it('if isSubmitDisabled and some submitChecks false should call validateMonitoring', function() {
      controller.reopen({
        isSubmitDisabled: false,
        submitChecks: [
          {
            checkCallback: 'needToAddMapReduce',
            popupParams: [
              {serviceName: 'MAPREDUCE', selected: true},
              'mapreduceCheck'
            ]
          }
        ]
      });
      sinon.stub(controller, 'needToAddMapReduce', function() {return false;});
      controller.submit();
      expect(controller.validateMonitoring.calledOnce).to.equal(true);
      controller.needToAddMapReduce.restore();
    });
  });

});
});

;require.register("test/controllers/wizard/step5_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');
require('controllers/wizard/step5_controller');
var c;
describe('App.WizardStep5Controller', function () {
  beforeEach(function() {
    c = App.WizardStep5Controller.create();
  });
  var controller = App.WizardStep5Controller.create();
  controller.set('content', {});
  var cpu = 2, memory = 4;

  var schemes = Em.A([
    {'description': 'empty condition'},
    {
      'description': 'second host if amount more than 1',
      "else": 1
    },
    {
      'description': 'first host if amount less than 3, third host if amount less than 6, fourth host if amount more than 5',
      "3": 0,
      "6": 2,
      "else": 3
    },
    {
      'description': 'second host if amount less than 3, second host if amount less than 6, third host if amount less than 31, sixth host if amount more than 30',
      "3": 1,
      "6": 1,
      "31": 2,
      "else": 5
    }
  ]);

  var test_config = [
    {
      title: '1 host',
      hosts: ['host0'],
      equals: [0, 0, 0, 0]
    },
    {
      title: '2 hosts',
      hosts: ['host0', 'host1'],
      equals: [0, 1, 0, 1]
    },
    {
      title: '3 hosts',
      hosts: ['host0', 'host1', 'host2'],
      equals: [0, 1, 2, 1]
    },
    {
      title: '5 hosts',
      hosts: ['host0', 'host1', 'host2', 'host3', 'host4'],
      equals: [0, 1, 2, 1]
    },
    {
      title: '6 hosts',
      hosts: ['host0', 'host1', 'host2', 'host3', 'host4', 'host6'],
      equals: [0, 1, 3, 2]
    },
    {
      title: '10 hosts',
      hosts: ['host0', 'host1', 'host2', 'host3', 'host4', 'host5', 'host6', 'host7', 'host8', 'host9'],
      equals: [0, 1, 3, 2]
    },
    {
      title: '31 hosts',
      hosts: ['host0', 'host1', 'host2', 'host3', 'host4', 'host5', 'host6', 'host7', 'host8', 'host9', 'host10', 'host11', 'host12', 'host13', 'host14', 'host15', 'host16', 'host17', 'host18', 'host19', 'host20', 'host21', 'host22', 'host23', 'host24', 'host25', 'host26', 'host27', 'host28', 'host29', 'host30'],
      equals: [0, 1, 3, 5]
    }
  ];

  schemes.forEach(function(scheme, index) {
    describe('#getHostForComponent() condition: ' + scheme.description, function() {

      delete scheme['description'];

      test_config.forEach(function(test) {
        it(test.title, function () {
          controller.get('hosts').clear();
          test.hosts.forEach(function(_host) {
            controller.get('hosts').pushObject(Em.Object.create({
              host_name: _host,
              cpu: cpu,
              memory: memory
            }));
          });
          expect(controller.getHostForComponent(test.hosts.length, scheme).host_name).to.equal(test.hosts[test.equals[index]]);
        });
      });
    });
  });

  describe('#getZooKeeperServer', function() {
    it('should be array with three host names if hosts number more than three', function() {
      var hosts = [
        {host_name: 'host1'},
        {host_name: 'host2'},
        {host_name: 'host3'}
      ];

      controller.set('hosts', hosts);
      expect(controller.getZooKeeperServer(hosts.length)).to.eql(['host1', 'host2', 'host3']);
    });

    it('should be array with one host names if hosts number less than three', function() {
      var hosts = [
        {host_name: 'host1'},
        {host_name: 'host2'}
      ];

      controller.set('hosts', hosts);
      expect(controller.getZooKeeperServer(hosts.length)).to.eql(['host1']);
    });
  });

  describe('#getServerHost', function() {
    it('should be host name if one host ', function() {
      var hosts = [
        {host_name: 'host1'}
      ];

      controller.set('hosts', hosts);
      expect(controller.getServerHost(hosts.length)).to.eql('host1');
    });

    it('should be host name if hosts number more than one', function() {
      var hosts = [
        {host_name: 'host1'},
        {host_name: 'host2'}
      ];

      controller.set('hosts', hosts);
      expect(controller.getServerHost(hosts.length)).to.eql('host1');
    });

    it('should be host name different from localhost if hosts number more than one', function() {
      var hosts = [
        {host_name: location.hostname},
        {host_name: 'host2'}
      ];
      //first host_name is empty string, because of location.hostname = "" in console,
      //to implement current test case

      controller.set('hosts', hosts);
      expect(controller.getServerHost(hosts.length)).to.eql('host2');
    });
  });


  controller.set('content', {});

  describe('#isReassignWizard', function() {
    it('true if content.controllerName is reassignMasterController', function() {
      controller.set('content.controllerName', 'reassignMasterController');
      expect(controller.get('isReassignWizard')).to.equal(true);
    });
    it('false if content.controllerName is not reassignMasterController', function() {
      controller.set('content.controllerName', 'mainController');
      expect(controller.get('isReassignWizard')).to.equal(false);
    });
  });

  describe('#isAddServiceWizard', function() {
    it('true if content.controllerName is addServiceController', function() {
      controller.set('content.controllerName', 'addServiceController');
      expect(controller.get('isAddServiceWizard')).to.equal(true);
    });
    it('false if content.controllerName is not addServiceController', function() {
      controller.set('content.controllerName', 'mainController');
      expect(controller.get('isAddServiceWizard')).to.equal(false);
    });
  });

  describe('#isReassignHive', function() {

    var tests = Em.A([
      {
        servicesMasters: Em.A([{component_name: 'HIVE_SERVER'}]),
        controllerName: 'reassignMasterController',
        e: true
      },
      {
        servicesMasters: Em.A([{component_name: 'HIVE_SERVER'}]),
        controllerName: 'addServiceController',
        e: false
      },
      {
        servicesMasters: Em.A([{component_name: 'ZOOKEEPER_SERVER'}]),
        controllerName: 'reassignMasterController',
        e: false
      },
      {
        servicesMasters: Em.A([{component_name: 'ZOOKEEPER_SERVER'}]),
        controllerName: 'addServiceController',
        e: false
      }
    ]);

    tests.forEach(function(test) {
      it(test.controllerName + ' ' + test.servicesMasters.mapProperty('component_name').join(','), function() {
        controller.set('content.controllerName', test.controllerName);
        controller.set('servicesMasters', test.servicesMasters);
        expect(controller.get('isReassignHive')).to.equal(test.e);
      });
    });

  });

  describe('#sortHosts', function() {

    var tests = Em.A([
      {
        hosts: [
          Em.Object.create({memory: 4, cpu: 1, host_name: 'host1', id: 1}),
          Em.Object.create({memory: 3, cpu: 1, host_name: 'host2', id: 2}),
          Em.Object.create({memory: 2, cpu: 1, host_name: 'host3', id: 3}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host4', id: 4})
        ],
        m: 'memory',
        e: [1,2,3,4]
      },
      {
        hosts: [
          Em.Object.create({memory: 1, cpu: 4, host_name: 'host1', id: 1}),
          Em.Object.create({memory: 1, cpu: 3, host_name: 'host2', id: 2}),
          Em.Object.create({memory: 1, cpu: 2, host_name: 'host3', id: 3}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host4', id: 4})
        ],
        m: 'cpu',
        e: [1,2,3,4]
      },
      {
        hosts: [
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host4', id: 1}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host2', id: 2}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host3', id: 3}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host1', id: 4})
        ],
        m: 'host_name',
        e: [4,2,3,1]
      },
      {
        hosts: [
          Em.Object.create({memory: 2, cpu: 1, host_name: 'host1', id: 1}),
          Em.Object.create({memory: 1, cpu: 2, host_name: 'host3', id: 2}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host4', id: 3}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host2', id: 4})
        ],
        m: 'mix',
        e: [1,2,4,3]
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        var hosts = Em.copy(test.hosts);
        controller.sortHosts(hosts);
        expect(Em.A(hosts).mapProperty('id')).to.eql(test.e);
      });
    });

  });

  describe('#renderHostInfo', function() {

    var tests = Em.A([
      {
        hosts: {
          h1: {memory: 4, cpu: 1, name: 'host1', bootStatus: 'INIT'},
          h2: {memory: 3, cpu: 1, name: 'host2', bootStatus: 'INIT'},
          h3: {memory: 2, cpu: 1, name: 'host3', bootStatus: 'INIT'},
          h4: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'INIT'}
        },
        m: 'no one host is REGISTERED',
        e: []
      },
      {
        hosts: {
          h1: {memory: 4, cpu: 1, name: 'host1', bootStatus: 'REGISTERED'},
          h2: {memory: 3, cpu: 1, name: 'host2', bootStatus: 'REGISTERED'},
          h3: {memory: 2, cpu: 1, name: 'host3', bootStatus: 'REGISTERED'},
          h4: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'REGISTERED'}
        },
        m: 'all hosts are REGISTERED, memory',
        e: ['host1', 'host2', 'host3', 'host4']
      },
      {
        hosts: {
          h1: {memory: 1, cpu: 4, name: 'host1', bootStatus: 'REGISTERED'},
          h2: {memory: 1, cpu: 3, name: 'host2', bootStatus: 'REGISTERED'},
          h3: {memory: 1, cpu: 2, name: 'host3', bootStatus: 'REGISTERED'},
          h4: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'REGISTERED'}
        },
        m: 'all hosts are REGISTERED, cpu',
        e: ['host1', 'host2', 'host3', 'host4']
      },
      {
        hosts: {
          h1: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'REGISTERED'},
          h2: {memory: 1, cpu: 1, name: 'host2', bootStatus: 'REGISTERED'},
          h3: {memory: 1, cpu: 1, name: 'host3', bootStatus: 'REGISTERED'},
          h4: {memory: 1, cpu: 1, name: 'host1', bootStatus: 'REGISTERED'}
        },
        m: 'all hosts are REGISTERED, host_name',
        e: ['host1', 'host2', 'host3', 'host4']
      },
      {
        hosts: {
          h1: {memory: 2, cpu: 1, name: 'host1', bootStatus: 'REGISTERED'},
          h2: {memory: 1, cpu: 2, name: 'host3', bootStatus: 'INIT'},
          h3: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'REGISTERED'},
          h4: {memory: 1, cpu: 1, name: 'host2', bootStatus: 'INIT'}
        },
        m: 'mix',
        e: ['host1', 'host4']
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        controller.set('content', {hosts: test.hosts});
        controller.renderHostInfo();
        var r = controller.get('hosts');
        expect(Em.A(r).mapProperty('host_name')).to.eql(test.e);
      });
    });

  });

  describe('#hasHiveServer', function() {

    var tests = Em.A([
      {
        selectedServicesMasters: Em.A([{component_name: 'HIVE_SERVER'}]),
        controllerName: 'reassignMasterController',
        e: false
      },
      {
        selectedServicesMasters: Em.A([{component_name: 'HIVE_SERVER'}]),
        controllerName: 'addServiceController',
        e: true
      },
      {
        selectedServicesMasters: Em.A([{component_name: 'ANOTHER'}]),
        controllerName: 'addServiceController',
        e: false
      },
      {
        selectedServicesMasters: Em.A([{component_name: 'ANOTHER'}]),
        controllerName: 'reassignMasterController',
        e: false
      }
    ]);

    tests.forEach(function(test) {
      it(test.controllerName + ' ' + test.selectedServicesMasters.mapProperty('component_name').join(','), function() {
        controller.set('content.controllerName', test.controllerName);
        controller.set('selectedServicesMasters', test.selectedServicesMasters);
        expect(controller.get('hasHiveServer')).to.equal(test.e);
      });
    });

  });

  describe('#selectHost', function() {

    var tests = Em.A([
      {componentName: 'KERBEROS_SERVER', hostsCount: 1, e: 'host1'},
      {componentName: 'KERBEROS_SERVER', hostsCount: 3, e: 'host2'},
      {componentName: 'KERBEROS_SERVER', hostsCount: 6, e: 'host4'},
      {componentName: 'KERBEROS_SERVER', hostsCount: 31, e: 'host6'},
      {componentName: 'KERBEROS_SERVER', hostsCount: 32, e: 'host6'},
      {componentName: 'NAMENODE', hostsCount: 1, e: 'host1'},
      {componentName: 'NAMENODE', hostsCount: 2, e: 'host1'},
      {componentName: 'SECONDARY_NAMENODE', hostsCount: 1, e: 'host1'},
      {componentName: 'SECONDARY_NAMENODE', hostsCount: 2, e: 'host2'},
      {componentName: 'JOBTRACKER', hostsCount: 1, e: 'host1'},
      {componentName: 'JOBTRACKER', hostsCount: 3, e: 'host2'},
      {componentName: 'JOBTRACKER', hostsCount: 6, e: 'host2'},
      {componentName: 'JOBTRACKER', hostsCount: 31, e: 'host3'},
      {componentName: 'JOBTRACKER', hostsCount: 32, e: 'host3'},
      {componentName: 'HISTORYSERVER', hostsCount: 1, e: 'host1'},
      {componentName: 'HISTORYSERVER', hostsCount: 3, e: 'host2'},
      {componentName: 'HISTORYSERVER', hostsCount: 6, e: 'host2'},
      {componentName: 'HISTORYSERVER', hostsCount: 31, e: 'host3'},
      {componentName: 'HISTORYSERVER', hostsCount: 32, e: 'host3'},
      {componentName: 'RESOURCEMANAGER', hostsCount: 1, e: 'host1'},
      {componentName: 'RESOURCEMANAGER', hostsCount: 3, e: 'host2'},
      {componentName: 'RESOURCEMANAGER', hostsCount: 6, e: 'host2'},
      {componentName: 'RESOURCEMANAGER', hostsCount: 31, e: 'host3'},
      {componentName: 'RESOURCEMANAGER', hostsCount: 32, e: 'host3'},
      {componentName: 'HBASE_MASTER', hostsCount: 1, e: ['host1']},
      {componentName: 'HBASE_MASTER', hostsCount: 3, e: ['host1']},
      {componentName: 'HBASE_MASTER', hostsCount: 6, e: ['host3']},
      {componentName: 'HBASE_MASTER', hostsCount: 31, e: ['host4']},
      {componentName: 'HBASE_MASTER', hostsCount: 32, e: ['host4']},
      {componentName: 'OOZIE_SERVER', hostsCount: 1, e: 'host1'},
      {componentName: 'OOZIE_SERVER', hostsCount: 3, e: 'host2'},
      {componentName: 'OOZIE_SERVER', hostsCount: 6, e: 'host3'},
      {componentName: 'OOZIE_SERVER', hostsCount: 31, e: 'host4'},
      {componentName: 'OOZIE_SERVER', hostsCount: 32, e: 'host4'},
      {componentName: 'HIVE_SERVER', hostsCount: 1, e: 'host1'},
      {componentName: 'HIVE_SERVER', hostsCount: 3, e: 'host2'},
      {componentName: 'HIVE_SERVER', hostsCount: 6, e: 'host3'},
      {componentName: 'HIVE_SERVER', hostsCount: 31, e: 'host5'},
      {componentName: 'HIVE_SERVER', hostsCount: 32, e: 'host5'},
      {componentName: 'HIVE_METASTORE', hostsCount: 1, e: 'host1'},
      {componentName: 'HIVE_METASTORE', hostsCount: 3, e: 'host2'},
      {componentName: 'HIVE_METASTORE', hostsCount: 6, e: 'host3'},
      {componentName: 'HIVE_METASTORE', hostsCount: 31, e: 'host5'},
      {componentName: 'HIVE_METASTORE', hostsCount: 32, e: 'host5'},
      {componentName: 'WEBHCAT_SERVER', hostsCount: 1, e: 'host1'},
      {componentName: 'WEBHCAT_SERVER', hostsCount: 3, e: 'host2'},
      {componentName: 'WEBHCAT_SERVER', hostsCount: 6, e: 'host3'},
      {componentName: 'WEBHCAT_SERVER', hostsCount: 31, e: 'host5'},
      {componentName: 'WEBHCAT_SERVER', hostsCount: 32, e: 'host5'},
      {componentName: 'APP_TIMELINE_SERVER', hostsCount: 1, e: 'host1'},
      {componentName: 'APP_TIMELINE_SERVER', hostsCount: 3, e: 'host2'},
      {componentName: 'APP_TIMELINE_SERVER', hostsCount: 6, e: 'host2'},
      {componentName: 'APP_TIMELINE_SERVER', hostsCount: 31, e: 'host3'},
      {componentName: 'APP_TIMELINE_SERVER', hostsCount: 32, e: 'host3'},
      {componentName: 'FALCON_SERVER', hostsCount: 1, e: 'host1'},
      {componentName: 'FALCON_SERVER', hostsCount: 3, e: 'host2'},
      {componentName: 'FALCON_SERVER', hostsCount: 6, e: 'host3'},
      {componentName: 'FALCON_SERVER', hostsCount: 31, e: 'host4'},
      {componentName: 'FALCON_SERVER', hostsCount: 32, e: 'host4'}
    ]);

    tests.forEach(function(test) {
      it(test.componentName + ' ' + test.hostsCount, function() {
        controller.set('hosts', d3.range(1, test.hostsCount + 1).map(function(i) { return {host_name: 'host' + i.toString()};}));
        expect(controller.selectHost(test.componentName)).to.eql(test.e);
      });
    });

    describe('getServerHost should be called for', function() {
      Em.A(['STORM_UI_SERVER','DRPC_SERVER','STORM_REST_API','NIMBUS','GANGLIA_SERVER','NAGIOS_SERVER','HUE_SERVER']).forEach(function(componentName) {
        it(componentName, function() {
          sinon.spy(controller, 'getServerHost');
          controller.selectHost(componentName);
          expect(controller.getServerHost.calledOnce).to.equal(true);
          controller.getServerHost.restore();
        });
      });
    });

  });

  describe('#last', function() {

    var tests = Em.A([
      {
        selectedServicesMasters: Em.A([
          {component_name: 'c1', indx: 1},
          {component_name: 'c2', indx: 2},
          {component_name: 'c1', indx: 2}
        ]),
        m: 'Components exists',
        c: 'c1',
        e: 2
      },
      {
        selectedServicesMasters: Em.A([
          {component_name: 'c1', indx: 1},
          {component_name: 'c2', indx: 2},
          {component_name: 'c1', indx: 2}
        ]),
        m: 'Components don\'t exists',
        c: 'c3',
        e: null
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        controller.set('selectedServicesMasters', test.selectedServicesMasters);
        if (!Em.isNone(test.e)) {
          expect(controller.last(test.c).indx).to.equal(test.e);
        }
        else {
          expect(Em.isNone(controller.last(test.c))).to.equal(true);
        }
      })
    });

  });

  describe('#isSubmitDisabled', function() {
    it('should be false if it\'s not a isReassignWizard', function() {
      c.set('controllerName', 'addServiceController');
      expect(c.get('isSubmitDisabled')).to.equal(false);
    });
  });

  describe('#remainingHosts', function() {
    it('should show count of hosts without masters', function() {
      c.reopen({masterHostMapping: [{}]});
      c.set('hosts', [{},{},{}]);
      expect(c.get('remainingHosts')).to.equal(2);
    });
  });

  describe('#clearStep', function() {
    var tests = Em.A([
      {p: 'hosts'},
      {p: 'selectedServicesMasters'},
      {p: 'servicesMasters'}
    ]);
    tests.forEach(function(test) {
      it('should cleanup ' + test.p, function() {
        c.set(test.p, [Em.Object.create({}),Em.Object.create({})]);
        c.clearStep();
        expect(c.get(test.p).length).to.equal(0);
      });
    });
  });

  describe('#updateComponent', function() {
    var tests = Em.A([
      {
        componentName: 'HBASE_SERVER',
        services: Em.A([
          Em.Object.create({isInstalled: true, serviceName: 'HBASE'})
        ]),
        selectedServicesMasters: Em.A([
          Em.Object.create({showAddControl: false, showRemoveControl: true, component_name: 'HBASE_SERVER'}),
          Em.Object.create({showAddControl: true, showRemoveControl: false, component_name: 'HBASE_SERVER'})
        ]),
        hosts: Em.A([
          Em.Object.create({})
        ]),
        controllerName: 'addServiceController',
        m: 'service is installed',
        e: {
          showAddControl: true,
          showRemoveControl: false
        }
      },
      {
        componentName: 'HBASE_SERVER',
        services: Em.A([
          Em.Object.create({isInstalled: false, serviceName: 'HBASE'})
        ]),
        selectedServicesMasters: Em.A([
          Em.Object.create({showAddControl: true, showRemoveControl: false, component_name: 'HBASE_SERVER'})
        ]),
        hosts: Em.A([
          Em.Object.create({})
        ]),
        controllerName: 'addServiceController',
        m: 'service not installed, but all host already have provided component',
        e: {
          showAddControl: true,
          showRemoveControl: false
        }
      },
      {
        componentName: 'HBASE_SERVER',
        services: Em.A([
          Em.Object.create({isInstalled: false, serviceName: 'HBASE'})
        ]),
        selectedServicesMasters: Em.A([
          Em.Object.create({showAddControl: false, showRemoveControl: true, component_name: 'HBASE_SERVER'})
        ]),
        hosts: Em.A([
          Em.Object.create({}),
          Em.Object.create({})
        ]),
        controllerName: 'addServiceController',
        m: 'service not installed, not all host already have provided component',
        e: {
          showAddControl: true,
          showRemoveControl: true
        }
      },
      {
        componentName: 'HBASE_SERVER',
        services: Em.A([
          Em.Object.create({isInstalled: false, serviceName: 'HBASE'})
        ]),
        selectedServicesMasters: Em.A([
          Em.Object.create({showAddControl: false, showRemoveControl: true, component_name: 'HBASE_SERVER'})
        ]),
        hosts: Em.A([
          Em.Object.create({}),
          Em.Object.create({})
        ]),
        controllerName: 'reassignMasterController',
        m: 'service not installed, not all host already have provided component, but is reassignMasterController',
        e: {
          showAddControl: false,
          showRemoveControl: false
        }
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        c.reopen({
          content: Em.Object.create({
            services: test.services,
            controllerName: test.controllerName
          }),
          selectedServicesMasters: test.selectedServicesMasters
        });
        c.updateComponent(test.componentName);
        Em.keys(test.e).forEach(function(k) {
          expect(c.last(test.componentName).get(k)).to.equal(test.e[k]);
        });
      });
    });
  });

  describe('#renderComponents', function() {
    var tests = Em.A([
      {
        masterComponents: Em.A([
          {component_name: 'ZOOKEEPER_SERVER'}
        ]),
        services: Em.A([]),
        controllerName: 'reassignMasterController',
        m: 'One component',
        isHaEnabled: false,
        component_name: 'ZOOKEEPER_SERVER',
        e: {
          selectedServicesMasters: ['ZOOKEEPER_SERVER'],
          servicesMasters: ['ZOOKEEPER_SERVER'],
          showRemoveControl: [false],
          isInstalled: [false],
          zId: [1]
        }
      },
      {
        masterComponents: Em.A([
          {component_name: 'ZOOKEEPER_SERVER'},
          {component_name: 'SECONDARY_NAMENODE'}
        ]),
        services: Em.A([]),
        controllerName: 'addServiceController',
        m: 'One component',
        isHaEnabled: true,
        component_name: 'ZOOKEEPER_SERVER',
        e: {
          selectedServicesMasters: ['ZOOKEEPER_SERVER'],
          servicesMasters: ['ZOOKEEPER_SERVER'],
          showRemoveControl: [false],
          zId: [1]
        }
      },
      {
        masterComponents: Em.A([
          {component_name: 'ZOOKEEPER_SERVER'},
          {component_name: 'ZOOKEEPER_SERVER'}
        ]),
        services: Em.A([
          Em.Object.create({serviceName:'ZOOKEEPER', isInstalled: true})
        ]),
        controllerName: 'addServiceController',
        m: 'Two components, but service is installed',
        isHaEnabled: false,
        component_name: 'ZOOKEEPER_SERVER',
        e: {
          selectedServicesMasters: ['ZOOKEEPER_SERVER', 'ZOOKEEPER_SERVER'],
          servicesMasters: ['ZOOKEEPER_SERVER', 'ZOOKEEPER_SERVER'],
          showRemoveControl: [false, false],
          zId: [1, 2]
        }
      },
      {
        masterComponents: Em.A([
          {component_name: 'ZOOKEEPER_SERVER'},
          {component_name: 'ZOOKEEPER_SERVER'},
          {component_name: 'NAMENODE'}
        ]),
        services: Em.A([
        ]),
        controllerName: 'addServiceController',
        m: 'Two components, but service is installed',
        isHaEnabled: false,
        component_name: 'ZOOKEEPER_SERVER',
        e: {
          selectedServicesMasters: ['ZOOKEEPER_SERVER', 'ZOOKEEPER_SERVER', 'NAMENODE'],
          servicesMasters: ['ZOOKEEPER_SERVER', 'ZOOKEEPER_SERVER', 'NAMENODE'],
          showRemoveControl: [true, true, undefined],
          zId: [1, 2, 1]
        }
      }
    ]);
    tests.forEach(function(test) {
      beforeEach(function() {
        App.reopen({isHaEnabled: test.isHaEnabled});
      });
      it(test.m, function() {
        App.set('isHaEnabled', test.isHaEnabled);
        c.reopen({
          content: Em.Object.create({
            services: test.services,
            controllerName: test.controllerName,
            reassign: {component_name: test.component_name}
          })
        });
        c.renderComponents(test.masterComponents);
        expect(c.get('selectedServicesMasters').mapProperty('component_name')).to.eql(test.e.selectedServicesMasters);
        expect(c.get('servicesMasters').mapProperty('component_name')).to.eql(test.e.servicesMasters);
        expect(c.get('selectedServicesMasters').mapProperty('showRemoveControl')).to.eql(test.e.showRemoveControl);
        expect(c.get('selectedServicesMasters').mapProperty('zId')).to.eql(test.e.zId);
        if (c.get('isReasignController')) {
          expect(c.get('servicesMasters').mapProperty('isInstalled')).to.eql(test.e.isInstalled);
        }
      });
    });
  });

  describe('#updateHiveCoHosts', function() {
    var tests = Em.A([
      {
        selectedServicesMasters: Em.A([
          Em.Object.create({component_name: 'HIVE_SERVER', selectedHost: 'h1'}),
          Em.Object.create({component_name: 'HIVE_METASTORE', selectedHost: 'h2'}),
          Em.Object.create({component_name: 'WEBHCAT_SERVER', selectedHost: 'h3'})
        ]),
        servicesMasters: Em.A([
          Em.Object.create({component_name: 'HIVE_SERVER', selectedHost: 'h1'})
        ]),
        isReassignHive: false,
        m: 'should set new host for both',
        e: ['h1','h1','h1']
      },
      {
        selectedServicesMasters: Em.A([
          Em.Object.create({component_name: 'HIVE_SERVER', selectedHost: 'h1'}),
          Em.Object.create({component_name: 'HIVE_METASTORE', selectedHost: 'h2'}),
          Em.Object.create({component_name: 'WEBHCAT_SERVER', selectedHost: 'h3'})
        ]),
        servicesMasters: Em.A([
          Em.Object.create({component_name: 'HIVE_METASTORE', selectedHost: 'h1'})
        ]),
        isReassignHive: false,
        m: 'should set new host for WEBHCAT_SERVER',
        e: ['h1','h2','h1']
      },
      {
        selectedServicesMasters: Em.A([
          Em.Object.create({component_name: 'HIVE_METASTORE', selectedHost: 'h2'}),
          Em.Object.create({component_name: 'WEBHCAT_SERVER', selectedHost: 'h3'})
        ]),
        servicesMasters: Em.A([
          Em.Object.create({component_name: 'HIVE_METASTORE', selectedHost: 'h1'})
        ]),
        isReassignHive: false,
        m: 'missing HIVE_SERVER',
        e: ['h2','h3']
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        c.set('selectedServicesMasters', test.selectedServicesMasters);
        c.set('servicesMasters', test.servicesMasters);
        c.reopen({isReassignHive: test.isReassignHive});
        c.updateHiveCoHosts();
        expect(c.get('selectedServicesMasters').mapProperty('selectedHost')).to.eql(test.e);
      });
    });

  });

  describe('#assignHostToMaster', function() {
    var tests = Em.A([
      {
        componentName: 'c1',
        selectedHost: 'h2',
        zId: '1',
        e: {
          indx: 0
        }
      },
      {
        componentName: 'c2',
        selectedHost: 'h3',
        zId: '2',
        e: {
          indx: 3
        }
      },
      {
        componentName: 'c3',
        selectedHost: 'h1',
        e: {
          indx: 2
        }
      },
      {
        componentName: 'c2',
        selectedHost: 'h4',
        e: {
          indx: 1
        }
      }
    ]),
    selectedServicesMasters = Em.A([
      Em.Object.create({component_name: 'c1', zId: '1', selectedHost: 'h1'}),
      Em.Object.create({component_name: 'c2', zId: '1', selectedHost: 'h1'}),
      Em.Object.create({component_name: 'c3', zId: '1', selectedHost: 'h3'}),
      Em.Object.create({component_name: 'c2', zId: '2', selectedHost: 'h2'})
    ]);

    tests.forEach(function(test) {
      it(test.componentName + ' ' + test.selectedHost + ' ' + test.zId, function() {
        c.set('selectedServicesMasters', selectedServicesMasters);
        c.assignHostToMaster(test.componentName, test.selectedHost, test.zId);
        expect(c.get('selectedServicesMasters').objectAt(test.e.indx).get('selectedHost')).to.equal(test.selectedHost);
      })
    });
  });

  describe('#submit', function() {
    beforeEach(function() {
      sinon.spy(App.router, 'send');
    });
    afterEach(function() {
      App.router.send.restore();
    });
    it('should go next if not isSubmitDisabled', function() {
      c.reopen({isSubmitDisabled: false});
      c.submit();
      expect(App.router.send.calledWith('next')).to.equal(true);
    });
    it('shouldn\'t go next if isSubmitDisabled', function() {
      c.reopen({isSubmitDisabled: true});
      c.submit();
      expect(App.router.send.called).to.equal(false);
    });
  });

  describe('#removeComponent', function() {
    var tests = Em.A([
      {
        componentName: 'c1',
        zId: 1,
        selectedServicesMasters: Em.A([]),
        hosts: [],
        m: 'empty selectedServicesMasters',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        zId: 1,
        selectedServicesMasters: Em.A([
          Em.Object.create({zId: 1, component_name: 'HBASE_SERVER'})
        ]),
        hosts: [],
        m: 'no such components',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        zId: 1,
        selectedServicesMasters: Em.A([
          Em.Object.create({zId: 1, component_name: 'ZOOKEPEER_SERVER'})
        ]),
        hosts: [],
        m: 'component is only 1',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        zId: 2,
        selectedServicesMasters: Em.A([
          Em.Object.create({zId: 1, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({zId: 2, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false})
        ]),
        hosts: [{},{}],
        m: 'two components, add allowed, remove not allowed',
        e: true,
        showAddControl: true,
        showRemoveControl: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        zId: 2,
        selectedServicesMasters: Em.A([
          Em.Object.create({zId: 1, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({zId: 2, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false})
        ]),
        hosts: [{}],
        m: 'two components, add not allowed, remove not allowed',
        e: true,
        showAddControl: false,
        showRemoveControl: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        zId: 2,
        selectedServicesMasters: Em.A([
          Em.Object.create({zId: 1, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({zId: 2, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({zId: 3, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: true})
        ]),
        hosts: [{},{}],
        m: 'three components, add not allowed, remove allowed',
        e: true,
        showAddControl: false,
        showRemoveControl: true
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        zId: 2,
        selectedServicesMasters: Em.A([
          Em.Object.create({zId: 1, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({zId: 2, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({zId: 3, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: true})
        ]),
        hosts: [{},{}, {}],
        m: 'three components, add allowed, remove allowed',
        e: true,
        showAddControl: true,
        showRemoveControl: true
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        c.set('selectedServicesMasters', test.selectedServicesMasters);
        c.set('hosts', test.hosts);
        expect(c.removeComponent(test.componentName, test.zId)).to.equal(test.e);
        if(test.e) {
          expect(c.get('selectedServicesMasters.lastObject.showRemoveControl')).to.equal(test.showRemoveControl);
          expect(c.get('selectedServicesMasters.lastObject.showAddControl')).to.equal(test.showAddControl);
        }
      })
    });
  });

  describe('#addComponent', function() {
    var tests = Em.A([
      {
        componentName: 'c1',
        selectedServicesMasters: Em.A([]),
        hosts: [],
        m: 'empty selectedServicesMasters',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({zId: 1, component_name: 'HBASE_SERVER'})
        ]),
        hosts: [],
        m: 'no such components',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({zId: 1, component_name: 'ZOOKEPEER_SERVER'})
        ]),
        hosts: [],
        m: 'one component, 0 hosts',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({zId: 1, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({zId: 2, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false})
        ]),
        hosts: [Em.Object.create({}), Em.Object.create({})],
        m: 'two components, two hosts',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({zId: 1, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({zId: 2, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false})
        ]),
        hosts: [Em.Object.create({}), Em.Object.create({}), Em.Object.create({})],
        m: 'two components, 3 hosts',
        e: true
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        c.set('selectedServicesMasters', test.selectedServicesMasters);
        c.set('hosts', test.hosts);
        expect(c.addComponent(test.componentName)).to.equal(test.e);
      });
    });
  });

  describe('#loadStep', function() {
    var methods = Em.A(['clearStep', 'renderHostInfo', 'renderComponents', 'loadComponents']);
    describe('should call several methods', function() {
      beforeEach(function() {
        methods.forEach(function(m) {
          sinon.spy(c, m);
        });
        c.reopen({content: {services: Em.A([])}});
      });
      afterEach(function() {
        methods.forEach(function(m) {
          c[m].restore();
        });
      });
      methods.forEach(function(m) {
        it(m, function() {
          c.loadStep();
          expect(c[m].calledOnce).to.equal(true);
        });
      });
    });
    it('should update HBASE if App.supports.multipleHBaseMasters is true', function() {
      App.set('supports.multipleHBaseMasters', true);
      sinon.spy(c, 'updateComponent');
      c.reopen({content: {services: Em.A([])}});
      c.loadStep();
      expect(c.updateComponent.calledTwice).to.equal(true);
      c.updateComponent.restore();
    });
  });

  describe('#title', function() {
    it('should be custom title for reassignMasterController', function() {
      c.set('content', {controllerName: 'reassignMasterController'});
      expect(c.get('title')).to.equal(Em.I18n.t('installer.step5.reassign.header'));
    });
    it('should be default for other', function() {
      c.set('content', {controllerName: 'notReassignMasterController'});
      expect(c.get('title')).to.equal(Em.I18n.t('installer.step5.header'));
    });
  });

  describe('#isSubmitDisabled', function() {
    it('should be false if no isReassignWizard', function() {
      c.reopen({isReassignWizard: false});
      expect(c.get('isSubmitDisabled')).to.equal(false);
    });
    it('should be true if isReassignWizard', function() {
      var hostComponents = Em.A([
        Em.Object.create({componentName: 'c1', host: Em.Object.create({hostName: 'h1'})}),
        Em.Object.create({componentName: 'c1', host: Em.Object.create({hostName: 'h2'})})
      ]);
      sinon.stub(App.HostComponent, 'find', function() {
        return hostComponents;
      });
      c.reopen({
        isReassignWizard: true,
        content:{
          reassign:{
            component_name: 'c1'
          }
        },
        servicesMasters: [
          {selectedHost: 'h5'},
          {selectedHost: 'h4'},
          {selectedHost: 'h3'}
        ]
      });
      expect(c.get('isSubmitDisabled')).to.equal(true);
      App.HostComponent.find.restore();
    });

    it('should be false if isReassignWizard', function() {
      var hostComponents = Em.A([
        Em.Object.create({componentName: 'c1', host: Em.Object.create({hostName: 'h1'})}),
        Em.Object.create({componentName: 'c1', host: Em.Object.create({hostName: 'h2'})}),
        Em.Object.create({componentName: 'c1', host: Em.Object.create({hostName: 'h3'})})
      ]);
      sinon.stub(App.HostComponent, 'find', function() {
        return hostComponents;
      });
      c.reopen({
        isReassignWizard: true,
        content:{
          reassign:{
            component_name: 'c1'
          }
        },
        servicesMasters: [
          {selectedHost: 'h1'},
          {selectedHost: 'h2'}
        ]
      });
      expect(c.get('isSubmitDisabled')).to.equal(false);
      App.HostComponent.find.restore();
    });

  });

  describe('#masterHostMapping', function() {
    Em.A([
        {
          selectedServicesMasters: [
            Em.Object.create({selectedHost: 'h1'}),
            Em.Object.create({selectedHost: 'h2'}),
            Em.Object.create({selectedHost: 'h1'})
          ],
          hosts: [
            Em.Object.create({host_name: 'h1', host_info: {}}),
            Em.Object.create({host_name: 'h2', host_info: {}})
          ],
          m: 'Two hosts',
          e: [
            {host_name: 'h1', hostInfo: {}, masterServices: [{}, {}]},
            {host_name: 'h2', hostInfo: {}, masterServices: [{}]}
          ]
        },
        {
          selectedServicesMasters: [],
          hosts: [],
          m: 'No hosts',
          e: []
        },
        {
          selectedServicesMasters: [
            Em.Object.create({selectedHost: 'h1'}),
            Em.Object.create({selectedHost: 'h1'})
          ],
          hosts: [
            Em.Object.create({host_name: 'h1', host_info: {}})
          ],
          m: 'One host',
          e: [
            {host_name: 'h1', hostInfo: {}, masterServices: [{}, {}]}
          ]
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          c.reopen({
            selectedServicesMasters: test.selectedServicesMasters,
            hosts: test.hosts
          });
          var result = c.get('masterHostMapping');
          expect(result.length).to.equal(test.e.length);
          result.forEach(function(r, i) {
            expect(r.get('host_name')).to.equal(test.e[i].host_name);
            expect(r.get('masterServices.length')).to.equal(test.e[i].masterServices.length);
            expect(r.get('hostInfo')).to.be.an.object;
          });
        });
      });
  });

  describe('#loadComponents', function() {
    Em.A([
        {
          services: [
            Em.Object.create({isSelected: true, serviceName: 's1'})
          ],
          masterComponents: Em.A([
            Em.Object.create({displayName: 'c1d', serviceName: 's1', componentName: 'c1', isShownOnInstallerAssignMasterPage: true})
          ]),
          masterComponentHosts: Em.A([
            {component: 'c1', hostName: 'h2', isInstalled: true}
          ]),
          selectHost: 'h3',
          m: 'savedComponent exists',
          e: {
            component_name: 'c1',
            display_name: 'c1d',
            selectedHost: 'h2',
            isInstalled: true,
            serviceId: 's1'
          }
        },
        {
          services: [
            Em.Object.create({isSelected: true, serviceName: 's1'})
          ],
          masterComponents: Em.A([
            Em.Object.create({displayName: 'c1d', serviceName: 's1', componentName: 'c1', isShownOnInstallerAssignMasterPage: true})
          ]),
          masterComponentHosts: Em.A([
            {component: 'c2', hostName: 'h2', isInstalled: true}
          ]),
          selectHost: 'h3',
          m: 'savedComponent doesn\'t exist',
          e: {
            component_name: 'c1',
            display_name: 'c1d',
            selectedHost: 'h3',
            isInstalled: false,
            serviceId: 's1'
          }
        },
        {
          services: [
            Em.Object.create({isSelected: true, serviceName: 's1'})
          ],
          masterComponents: Em.A([
            Em.Object.create({displayName: 'c1d', serviceName: 's1', componentName: 'ZOOKEEPER_SERVER', isShownOnInstallerAssignMasterPage: true})
          ]),
          masterComponentHosts: Em.A([
            {component: 'c1', hostName: 'h2', isInstalled: true}
          ]),
          selectHost: ['h3'],
          m: 'component ZOOKEEPER_SERVER',
          e: {
            component_name: 'ZOOKEEPER_SERVER',
            display_name: 'c1d',
            selectedHost: 'h3',
            isInstalled: false,
            serviceId: 's1',
            isHiveCoHost: false
          }
        },
        {
          services: [
            Em.Object.create({isSelected: true, serviceName: 's1'})
          ],
          masterComponents: Em.A([
            Em.Object.create({displayName: 'c1d', serviceName: 's1', componentName: 'HBASE_MASTER', isShownOnInstallerAssignMasterPage: true})
          ]),
          masterComponentHosts: Em.A([
            {component: 'c1', hostName: 'h2', isInstalled: true}
          ]),
          selectHost: ['h3'],
          m: 'component HBASE_MASTER',
          e: {
            component_name: 'HBASE_MASTER',
            display_name: 'c1d',
            selectedHost: 'h3',
            isInstalled: false,
            serviceId: 's1',
            isHiveCoHost: false
          }
        },
        {
          services: [
            Em.Object.create({isSelected: true, serviceName: 's1'})
          ],
          masterComponents: Em.A([
            Em.Object.create({displayName: 'c1d', serviceName: 's1', componentName: 'ZOOKEEPER_SERVER', isShownOnInstallerAssignMasterPage: true})
          ]),
          masterComponentHosts: Em.A([
            {component: 'ZOOKEEPER_SERVER', hostName: 'h2', isInstalled: true}
          ]),
          selectHost: ['h3'],
          m: 'component ZOOKEEPER_SERVER(2)',
          e: {
            component_name: 'ZOOKEEPER_SERVER',
            display_name: 'c1d',
            selectedHost: 'h2',
            isInstalled: true,
            serviceId: 's1',
            isHiveCoHost: false
          }
        },
        {
          services: [
            Em.Object.create({isSelected: true, serviceName: 's1'})
          ],
          masterComponents: Em.A([
            Em.Object.create({displayName: 'c1d', serviceName: 's1', componentName: 'HBASE_MASTER', isShownOnInstallerAssignMasterPage: true})
          ]),
          masterComponentHosts: Em.A([
            {component: 'HBASE_MASTER', hostName: 'h2', isInstalled: true}
          ]),
          selectHost: ['h3'],
          m: 'component HBASE_MASTER (2)',
          e: {
            component_name: 'HBASE_MASTER',
            display_name: 'c1d',
            selectedHost: 'h2',
            isInstalled: true,
            serviceId: 's1',
            isHiveCoHost: false
          }
        }
      ]).forEach(function (test) {
        it(test.m, function() {
          c.reopen({
            content: {
              services: test.services,
              masterComponentHosts: test.masterComponentHosts
            }
          });
          sinon.stub(App.StackServiceComponent, 'find', function() {
            return test.masterComponents;
          });
          sinon.stub(c, 'selectHost', function() {
            return test.selectHost;
          });
          var r = c.loadComponents();
          App.StackServiceComponent.find.restore();
          c.selectHost.restore();
          expect(r.length).to.equal(1);
          Em.keys(test.e).forEach(function(k) {
            expect(r[0][k]).to.equal(test.e[k]);
          });
        });
      });
  });

  describe('#_isHiveCoHost', function() {
    Em.A([
        {
          componentName: 'HIVE_METASTORE',
          isReassignWizard: false,
          e: true
        },
        {
          componentName: 'WEBHCAT_SERVER',
          isReassignWizard: false,
          e: true
        },
        {
          componentName: 'HIVE_METASTORE',
          isReassignWizard: true,
          e: false
        },
        {
          componentName: 'WEBHCAT_SERVER',
          isReassignWizard: true,
          e: false
        },
        {
          componentName: 'C1',
          isReassignWizard: false,
          e: false
        },
        {
          componentName: 'C1',
          isReassignWizard: true,
          e: false
        }
      ]).forEach(function (test) {
        it(test.componentName.toString() + ' ' + test.isReassignWizard.toString(), function () {
          c.reopen({
            isReassignWizard: test.isReassignWizard
          });
          var r = c._isHiveCoHost(test.componentName);
          expect(r).to.equal(test.e);
        });
      });
  });

});
});

;require.register("test/controllers/wizard/step6_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');
require('utils/helper');
require('controllers/wizard/step6_controller');
var controller,
  services = [
    Em.Object.create({
      serviceName: 'MAPREDUCE',
      isSelected: true
    }),
    Em.Object.create({
      serviceName: 'YARN',
      isSelected: true
    }),
    Em.Object.create({
      serviceName: 'HBASE',
      isSelected: true
    }),
    Em.Object.create({
      serviceName: 'HDFS',
      isSelected: true
    }),
    Em.Object.create({
      serviceName: 'STORM',
      isSelected: true
    }),
    Em.Object.create({
      serviceName: 'FLUME',
      isSelected: true
    })
  ];
describe('App.WizardStep6Controller', function () {

  beforeEach(function () {
    controller = App.WizardStep6Controller.create();
    controller.set('content', {
      hosts: {},
      masterComponentHosts: {},
      services: services
    });
    sinon.stub(controller, 'getComponentDisplayName', function (c) {
      return App.format.components[c];
    });

    var h = {}, m = [];
    Em.A(['host0', 'host1', 'host2', 'host3']).forEach(function (hostName) {
      var obj = Em.Object.create({
        name: hostName,
        hostName: hostName,
        bootStatus: 'REGISTERED'
      });
      h[hostName] = obj;
      m.push(obj);
    });

    controller.set('content.hosts', h);
    controller.set('content.masterComponentHosts', m);
    controller.set('isMasters', false);

  });

  afterEach(function () {
    controller.getComponentDisplayName.restore();
  });

  describe('#loadStep', function () {
    Em.A([
        {
          isMasters: false,
          services: [
            Em.Object.create({
              serviceName: 'MAPREDUCE',
              isSelected: true
            })
          ],
          e: {
            l: 2,
            allChecked: false,
            noChecked: true
          }
        },
        {
          isMasters: false,
          services: [
            Em.Object.create({
              serviceName: 'MAPREDUCE',
              isSelected: true
            }),
            Em.Object.create({
              serviceName: 'YARN',
              isSelected: true
            })
          ],
          e: {
            l: 3,
            allChecked: false,
            noChecked: true
          }
        },
        {
          isMasters: false,
          services: [
            Em.Object.create({
              serviceName: 'MAPREDUCE',
              isSelected: true
            }),
            Em.Object.create({
              serviceName: 'YARN',
              isSelected: true
            }),
            Em.Object.create({
              serviceName: 'HBASE',
              isSelected: true
            })
          ],
          e: {
            l: 4,
            allChecked: false,
            noChecked: true
          }
        },
        {
          isMasters: false,
          services: [
            Em.Object.create({
              serviceName: 'MAPREDUCE',
              isSelected: true
            }),
            Em.Object.create({
              serviceName: 'YARN',
              isSelected: true
            }),
            Em.Object.create({
              serviceName: 'HBASE',
              isSelected: true
            }),
            Em.Object.create({
              serviceName: 'HDFS',
              isSelected: true
            })
          ],
          e: {
            l: 5,
            allChecked: false,
            noChecked: true
          }
        },
        {
          isMasters: false,
          services: [
            Em.Object.create({
              serviceName: 'MAPREDUCE',
              isSelected: true
            }),
            Em.Object.create({
              serviceName: 'YARN',
              isSelected: true
            }),
            Em.Object.create({
              serviceName: 'HBASE',
              isSelected: true
            }),
            Em.Object.create({
              serviceName: 'HDFS',
              isSelected: true
            }),
            Em.Object.create({
              serviceName: 'STORM',
              isSelected: true
            })
          ],
          e: {
            l: 6,
            allChecked: false,
            noChecked: true
          }
        },
        {
          isMasters: false,
          services: [
            Em.Object.create({
              serviceName: 'MAPREDUCE',
              isSelected: true
            }),
            Em.Object.create({
              serviceName: 'YARN',
              isSelected: true
            }),
            Em.Object.create({
              serviceName: 'HBASE',
              isSelected: true
            }),
            Em.Object.create({
              serviceName: 'HDFS',
              isSelected: true
            }),
            Em.Object.create({
              serviceName: 'STORM',
              isSelected: true
            }),
            Em.Object.create({
              serviceName: 'FLUME',
              isSelected: true
            })
          ],
          e: {
            l: 7,
            allChecked: false,
            noChecked: true
          }
        },
        {
          isMasters: true,
          multipleHBaseMasters: true,
          services: [
            Em.Object.create({
              serviceName: 'HBASE',
              isSelected: true
            })
          ],
          e: {
            l: 1,
            allChecked: false,
            noChecked: true
          }
        },
        {
          isMasters: true,
          multipleHBaseMasters: false,
          services: [
            Em.Object.create({
              serviceName: 'HBASE',
              isSelected: true
            })
          ],
          e: {
            l: 0,
            allChecked: false,
            noChecked: true
          }
        },
        {
          isMasters: true,
          services: [
            Em.Object.create({
              serviceName: 'ZOOKEEPER',
              isSelected: true
            })
          ],
          e: {
            l: 1,
            allChecked: false,
            noChecked: true
          }
        }
      ]).forEach(function (test) {
        it(test.isMasters.toString() + ' ' + test.services.mapProperty('serviceName').join(', '), function () {
          if (test.hasOwnProperty('multipleHBaseMasters')) {
            App.set('supports.multipleHBaseMasters', test.multipleHBaseMasters);
          }
          controller.set('content.services', test.services);
          controller.set('isMasters', test.isMasters);
          sinon.stub(controller, 'render', Em.K);
          controller.loadStep();
          expect(controller.get('headers.length')).to.equal(test.e.l);
          expect(controller.get('headers').everyProperty('allChecked', test.e.allChecked)).to.equal(true);
          expect(controller.get('headers').everyProperty('noChecked', test.e.noChecked)).to.equal(true);
          controller.clearStep();
          controller.render.restore();
        });
      });

    Em.A([
        {
          p: {
            isMasters: true,
            skipMasterStep: true
          },
          e: true
        },
        {
          p: {
            isMasters: false,
            skipMasterStep: true
          },
          e: false
        },
        {
          p: {
            isMasters: true,
            skipMasterStep: false
          },
          e: false
        },
        {
          p: {
            isMasters: false,
            skipMasterStep: false
          },
          e: false
        }
      ]).forEach(function (test) {
        it('should skip this step if isMasters is ' + test.p.isMasters + ' and content.skipMasterStep is ' + test.p.skipMasterStep, function () {
          controller.set('isMasters', test.p.isMasters);
          controller.set('content.skipMasterStep', test.p.skipMasterStep);
          sinon.stub(App.router, 'send', Em.K);
          controller.loadStep();
          expect(App.router.send.calledWith('next')).to.equal(test.e);
          App.router.send.restore();
        });
      });

    Em.A([
        {
          p: {
            isMasters: true,
            skipSlavesStep: true
          },
          e: false
        },
        {
          p: {
            isMasters: false,
            skipSlavesStep: true
          },
          e: true
        },
        {
          p: {
            isMasters: true,
            skipSlavesStep: false
          },
          e: false
        },
        {
          p: {
            isMasters: false,
            skipSlavesStep: false
          },
          e: false
        }
      ]).forEach(function (test) {
        it('should skip this step if isMasters is ' + test.p.isMasters + ' and content.skipSlavesStep is ' + test.p.skipSlavesStep, function () {
          controller.set('isMasters', test.p.isMasters);
          controller.set('content.skipSlavesStep', test.p.skipSlavesStep);
          sinon.stub(App.router, 'send', Em.K);
          controller.loadStep();
          expect(App.router.send.calledWith('next')).to.equal(test.e);
          App.router.send.restore();
        });
      });

  });

  describe('#isAddHostWizard', function () {
    it('true if content.controllerName is addHostController', function () {
      controller.set('content.controllerName', 'addHostController');
      expect(controller.get('isAddHostWizard')).to.equal(true);
    });
    it('false if content.controllerName is not addHostController', function () {
      controller.set('content.controllerName', 'mainController');
      expect(controller.get('isAddHostWizard')).to.equal(false);
    });
  });

  describe('#isInstallerWizard', function () {
    it('true if content.controllerName is addHostController', function () {
      controller.set('content.controllerName', 'installerController');
      expect(controller.get('isInstallerWizard')).to.equal(true);
    });
    it('false if content.controllerName is not addHostController', function () {
      controller.set('content.controllerName', 'mainController');
      expect(controller.get('isInstallerWizard')).to.equal(false);
    });
  });

  describe('#isAddServiceWizard', function () {
    it('true if content.controllerName is addServiceController', function () {
      controller.set('content.controllerName', 'addServiceController');
      expect(controller.get('isAddServiceWizard')).to.equal(true);
    });
    it('false if content.controllerName is not addServiceController', function () {
      controller.set('content.controllerName', 'mainController');
      expect(controller.get('isAddServiceWizard')).to.equal(false);
    });
  });

  describe('#setAllNodes', function () {

    var test_config = Em.A([
      {
        title: 'DataNode',
        name: 'DATANODE',
        state: false
      },
      {
        title: 'DataNode',
        name: 'DATANODE',
        state: true
      },
      {
        title: 'TaskTracker',
        name: 'TASKTRACKER',
        state: false
      },
      {
        title: 'TaskTracker',
        name: 'TASKTRACKER',
        state: true
      }
    ]);

    test_config.forEach(function (test) {
      it((test.state ? 'Select' : 'Deselect') + ' all ' + test.title, function () {
        controller.loadStep();
        controller.setAllNodes(test.name, test.state);
        var hosts = controller.get('hosts');
        hosts.forEach(function (host) {
          var cb = host.get('checkboxes').filterProperty('isInstalled', false).findProperty('component', test.name);
          if (cb) {
            expect(cb.get('checked')).to.equal(test.state);
          }
        });
      });
    });


  });

  describe('#isServiceSelected', function () {
    describe('selected', function () {
      services.forEach(function (service) {
        it(service.serviceName + ' is selected', function () {
          expect(controller.isServiceSelected(service.serviceName)).to.equal(true);
        });
      });
    });
    var unselectedService = 'FAKESERVICE';
    it(unselectedService + ' is not selected', function () {
      expect(controller.isServiceSelected(unselectedService)).to.equal(false);
    });
  });

  describe('#validateEachComponent', function () {
    beforeEach(function () {
      controller.loadStep();
    });
    it('Nothing checked', function () {
      controller.get('hosts').forEach(function (host) {
        host.get('checkboxes').setEach('checked', false);
      });
      expect(controller.validateEachComponent('')).to.equal(false);
    });
    it('One slave is not selected for no one host', function () {
      controller.get('hosts').forEach(function (host) {
        host.get('checkboxes').forEach(function (checkbox, index) {
          checkbox.set('checked', index === 0);
        });
      });
      expect(controller.validateEachComponent('')).to.equal(false);
    });
    it('All checked', function () {
      controller.get('hosts').forEach(function (host) {
        host.get('checkboxes').forEach(function (checkbox) {
          checkbox.set('checked', true);
        });
      });
      expect(controller.validateEachComponent('')).to.equal(true);
    });
  });

  describe('#validateEachHost', function () {
    beforeEach(function () {
      controller.loadStep();
    });
    it('Nothing checked', function () {
      controller.get('hosts').forEach(function (host) {
        host.get('checkboxes').setEach('checked', false);
      });
      expect(controller.validateEachHost('')).to.equal(false);
    });
    it('One host doesn\'t have assigned slaves', function () {
      controller.get('hosts').forEach(function (host, index) {
        host.get('checkboxes').setEach('checked', index === 0);
      });
      expect(controller.validateEachHost('')).to.equal(false);
    });
    it('All checked', function () {
      controller.get('hosts').forEach(function (host) {
        host.get('checkboxes').setEach('checked', true);
      });
      expect(controller.validateEachHost('')).to.equal(true);
    });
  });

  describe('#clearStep', function () {
    beforeEach(function () {
      sinon.stub(controller, 'clearError', Em.K);
    });
    afterEach(function () {
      controller.clearError.restore();
    });
    it('should call clearError', function () {
      controller.clearStep();
      expect(controller.clearError.calledOnce).to.equal(true);
    });
    it('should clear hosts', function () {
      controller.set('hosts', [
        {},
        {}
      ]);
      controller.clearStep();
      expect(controller.get('hosts')).to.eql([]);
    });
    it('should clear headers', function () {
      controller.set('headers', [
        {},
        {}
      ]);
      controller.clearStep();
      expect(controller.get('headers')).to.eql([]);
    });
    it('should set isLoaded to false', function () {
      controller.set('isLoaded', true);
      controller.clearStep();
      expect(controller.get('isLoaded')).to.equal(false);
    });
  });

  describe('#selectAllNodes', function () {
    beforeEach(function () {
      sinon.stub(controller, 'setAllNodes', Em.K);
    });
    afterEach(function () {
      controller.setAllNodes.restore();
    });
    it('should call setAllNodes', function () {
      controller.selectAllNodes({context: {name: 'name'}});
      expect(controller.setAllNodes.calledWith('name', true)).to.equal(true);
    });
    it('shouldn\'t call setAllNodes', function () {
      controller.selectAllNodes();
      expect(controller.setAllNodes.called).to.equal(false);
    });
  });

  describe('#deselectAllNodes', function () {
    beforeEach(function () {
      sinon.stub(controller, 'setAllNodes', Em.K);
    });
    afterEach(function () {
      controller.setAllNodes.restore();
    });
    it('should call setAllNodes', function () {
      controller.deselectAllNodes({context: {name: 'name'}});
      expect(controller.setAllNodes.calledWith('name', false)).to.equal(true);
    });
    it('shouldn\'t call setAllNodes', function () {
      controller.deselectAllNodes();
      expect(controller.setAllNodes.called).to.equal(false);
    });
  });

  describe('#checkCallback', function () {
    beforeEach(function () {
      sinon.stub(controller, 'clearError', Em.K);
    });
    afterEach(function () {
      controller.clearError.restore();
    });
    it('should call clearError', function () {
      controller.checkCallback('');
      expect(controller.clearError.calledOnce).to.equal(true);
    });
    Em.A([
        {
          m: 'all checked, isInstalled false',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: true
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: true,
            noChecked: false
          }
        },
        {
          m: 'all checked, isInstalled true',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: true,
                  checked: true
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: true,
            noChecked: true
          }
        },
        {
          m: 'no one checked',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: false
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: false,
            noChecked: true
          }
        },
        {
          m: 'some checked',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: true
                }),
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: false
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: false,
            noChecked: false
          }
        },
        {
          m: 'some checked, some isInstalled true',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: true,
                  checked: true
                }),
                Em.Object.create({
                  component: 'c1',
                  isInstalled: true,
                  checked: true
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: true,
            noChecked: true
          }
        },
        {
          m: 'some checked, some isInstalled true (2)',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: false
                }),
                Em.Object.create({
                  component: 'c1',
                  isInstalled: true,
                  checked: true
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: false,
            noChecked: true
          }
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          controller.clearStep();
          controller.set('headers', test.headers);
          controller.set('hosts', test.hosts);
          controller.checkCallback(test.component);
          var header = controller.get('headers').findProperty('name', test.component);
          expect(header.get('allChecked')).to.equal(test.e.allChecked);
          expect(header.get('noChecked')).to.equal(test.e.noChecked);
        });
      });
  });

  describe('#getHostNames', function () {
    var tests = Em.A([
      {
        hosts: {
          h1: {bootStatus: 'REGISTERED', name: 'h1'},
          h2: {bootStatus: 'REGISTERED', name: 'h2'},
          h3: {bootStatus: 'REGISTERED', name: 'h3'}
        },
        m: 'All REGISTERED',
        e: ['h1', 'h2', 'h3']
      },
      {
        hosts: {
          h1: {bootStatus: 'REGISTERED', name: 'h1'},
          h2: {bootStatus: 'FAILED', name: 'h2'},
          h3: {bootStatus: 'REGISTERED', name: 'h3'}
        },
        m: 'Some REGISTERED',
        e: ['h1', 'h3']
      },
      {
        hosts: {
          h1: {bootStatus: 'FAILED', name: 'h1'},
          h2: {bootStatus: 'FAILED', name: 'h2'},
          h3: {bootStatus: 'FAILED', name: 'h3'}
        },
        m: 'No one REGISTERED',
        e: []
      },
      {
        hosts: {},
        m: 'Empty hosts',
        e: []
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content.hosts', test.hosts);
        var r = controller.getHostNames();
        expect(r).to.eql(test.e);
      });
    });
  });

  describe('#validate', function () {
    var tests = Em.A([
      {
        controllerName: 'addHostController',
        method: 'validateEachHost',
        r: true,
        e: true
      },
      {
        controllerName: 'addHostController',
        method: 'validateEachHost',
        r: false,
        e: false
      },
      {
        controllerName: 'addServiceController',
        method: 'validateEachComponent',
        r: true,
        e: true
      },
      {
        controllerName: 'addServiceController',
        method: 'validateEachComponent',
        r: false,
        e: false
      },
      {
        controllerName: 'installerController',
        method: 'validateEachComponent',
        r: true,
        e: true
      },
      {
        controllerName: 'installerController',
        method: 'validateEachComponent',
        r: false,
        e: false
      }
    ]);
    tests.forEach(function (test) {
      it(test.controllerName + ' ' + test.method + ' returns ' + test.r.toString(), function () {
        sinon.stub(controller, test.method, function () {
          return test.r
        });
        controller.set('content.controllerName', test.controllerName);
        expect(controller.validate()).to.equal(test.e);
        controller[test.method].restore();
      });
    });
  });

  describe('#getMasterComponentsForHost', function () {
    var tests = Em.A([
      {
        masterComponentHosts: Em.A([
          {hostName: 'h1', component: 'c1'}
        ]),
        hostName: 'h1',
        m: 'host exists',
        e: ['c1']
      },
      {
        masterComponentHosts: Em.A([
          {hostName: 'h1', component: 'c1'}
        ]),
        hostName: 'h2',
        m: 'host donesn\'t exists',
        e: []
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content.masterComponentHosts', test.masterComponentHosts);
        var r = controller.getMasterComponentsForHost(test.hostName);
        expect(r).to.eql(test.e);
      });
    });
  });

  describe('#selectMasterComponents', function () {
    var tests = Em.A([
      {
        masterComponentHosts: Em.A([
          {
            hostName: 'h1',
            component: 'c1'
          }
        ]),
        hostsObj: [
          Em.Object.create({
            hostName: 'h1',
            checkboxes: [
              Em.Object.create({
                component: 'c1',
                checked: false
              })
            ]
          })
        ],
        e: true,
        m: 'host and component exist'
      },
      {
        masterComponentHosts: Em.A([
          {
            hostName: 'h1',
            component: 'c2'
          }
        ]),
        hostsObj: [
          Em.Object.create({
            hostName: 'h1',
            checkboxes: [
              Em.Object.create({
                component: 'c1',
                checked: false
              })
            ]
          })
        ],
        e: false,
        m: 'host exists'
      },
      {
        masterComponentHosts: Em.A([
          {
            hostName: 'h2',
            component: 'c2'
          }
        ]),
        hostsObj: [
          Em.Object.create({
            hostName: 'h1',
            checkboxes: [
              Em.Object.create({
                component: 'c1',
                checked: false
              })
            ]
          })
        ],
        e: false,
        m: 'host and component don\'t exist'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content.masterComponentHosts', test.masterComponentHosts);
        var r = controller.selectMasterComponents(test.hostsObj);
        expect(r.findProperty('hostName', 'h1').get('checkboxes').findProperty('component', 'c1').get('checked')).to.equal(test.e);
      });
    });
  });

  describe('#render', function () {
    beforeEach(function () {
      sinon.stub(controller, 'selectMasterComponents', Em.K);
      sinon.stub(controller, 'renderSlaves', Em.K);
    });
    afterEach(function () {
      controller.selectMasterComponents.restore();
      controller.renderSlaves.restore();
    });
    it('should call selectMasterComponents if isMasters is true', function () {
      controller.set('isMasters', true);
      controller.render();
      expect(controller.selectMasterComponents.calledOnce).to.equal(true);
      expect(controller.renderSlaves.called).to.equal(false);
    });
    it('should call renderSlaves if isMasters is false', function () {
      controller.set('isMasters', false);
      controller.render();
      expect(controller.selectMasterComponents.called).to.equal(false);
      expect(controller.renderSlaves.calledOnce).to.equal(true);
    });
    it('should set isLoaded to true', function () {
      controller.set('isLoaded', false);
      controller.render();
      expect(controller.get('isLoaded')).to.equal(true);
    });
  });

  describe('#renderSlaves', function () {
    Em.A([
        {
          controllerName: 'addServiceController',
          slaveComponents: [],
          hostsObj: [
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({isInstalled: false, title: 'Client'}),
                Em.Object.create({isInstalled: false, title: ''}),
                Em.Object.create({isInstalled: false, title: ''})
              ]),
              hasMaster: true
            })
          ],
          m: 'host with masters, empty slaveComponents, controllerName - addServiceController',
          e: [
            [false, false, false]
          ]
        },
        {
          controllerName: 'addServiceController',
          slaveComponents: [],
          hostsObj: [
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({isInstalled: false, title: 'Client'}),
                Em.Object.create({isInstalled: false, title: ''}),
                Em.Object.create({isInstalled: false, title: ''})
              ]),
              hasMaster: false
            })
          ],
          m: 'host without masters, empty slaveComponents, controllerName - addServiceController',
          e: [
            [false, true, true]
          ]
        },
        {
          controllerName: 'addServiceController',
          slaveComponents: [],
          services: [
            Em.Object.create({serviceName: 'HDFS', isSelected: true})
          ],
          hostsObj: [
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({isInstalled: false, title: 'Client'}),
                Em.Object.create({isInstalled: false, title: 'DataNode', checked: true}),
                Em.Object.create({isInstalled: false, title: ''})
              ]),
              hasMaster: false
            })
          ],
          m: 'host without masters, empty slaveComponents, controllerName - addServiceController, one datanode checked',
          e: [
            [true, true, true]
          ]
        },
        {
          controllerName: 'addServiceController',
          slaveComponents: [],
          services: [
            Em.Object.create({serviceName: 'HDFS', isSelected: true})
          ],
          hostsObj: [
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({isInstalled: false, title: 'Client'}),
                Em.Object.create({isInstalled: false, title: 'DataNode', checked: false}),
                Em.Object.create({isInstalled: false, title: ''})
              ]),
              hasMaster: true
            })
          ],
          m: 'host with masters, empty slaveComponents, controllerName - addServiceController, one datanode not checked',
          e: [
            [false, false, false]
          ]
        },
        {
          controllerName: 'installerController',
          slaveComponents: [],
          services: [
            Em.Object.create({serviceName: 'HDFS', isSelected: true})
          ],
          hostsObj: [
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({isInstalled: false, title: 'Client'}),
                Em.Object.create({isInstalled: false, title: 'DataNode', checked: true}),
                Em.Object.create({isInstalled: false, title: ''})
              ]),
              hasMaster: true
            })
          ],
          m: 'host with masters, empty slaveComponents, controllerName - installerController, one datanode checked',
          e: [
            [true, true, true]
          ]
        },
        {
          controllerName: 'installerController',
          slaveComponents: [],
          services: [
            Em.Object.create({serviceName: 'HDFS', isSelected: true})
          ],
          hostsObj: [
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({isInstalled: false, title: 'Client'}),
                Em.Object.create({isInstalled: false, title: 'DataNode', checked: false}),
                Em.Object.create({isInstalled: false, title: ''})
              ]),
              hasMaster: true
            }),
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({isInstalled: false, title: 'Client'}),
                Em.Object.create({isInstalled: false, title: 'DataNode', checked: true}),
                Em.Object.create({isInstalled: false, title: ''})
              ]),
              hasMaster: true
            })
          ],
          m: 'hosts with masters, empty slaveComponents, controllerName - installerController, one datanode checked',
          e: [
            [false, false, false],
            [true, true, true]
          ]
        },
        {
          controllerName: 'installerController',
          slaveComponents: [],
          services: [
            Em.Object.create({serviceName: 'HDFS', isSelected: true})
          ],
          hostsObj: [
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({isInstalled: false, title: 'Client'}),
                Em.Object.create({isInstalled: false, title: 'DataNode', checked: false}),
                Em.Object.create({isInstalled: false, title: ''})
              ]),
              hasMaster: true
            }),
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({isInstalled: false, title: 'Client'}),
                Em.Object.create({isInstalled: false, title: 'DataNode', checked: true}),
                Em.Object.create({isInstalled: false, title: ''})
              ]),
              hasMaster: false
            })
          ],
          m: 'some hosts with masters, empty slaveComponents, controllerName - installerController, one datanode checked',
          e: [
            [false, false, false],
            [true, true, true]
          ]
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          controller.set('content.slaveComponents', test.slaveComponents);
          controller.set('content.controllerName', test.controllerName);
          if (test.services) {
            controller.set('content.services', test.services);
          }
          controller.set('isMasters', false);
          controller.loadStep();
          var r = controller.renderSlaves(test.hostsObj);
          expect(r.map(function (i) {
            return i.get('checkboxes').map(function (j) {
              return j.get('checked');
            });
          })).to.eql(test.e);
        });
      });

    Em.A([
        {
          slaveComponents: [
            {componentName: 'c1', hosts: [
              {hostName: 'h1', isInstalled: false},
              {hostName: 'h2', isInstalled: false}
            ]},
            {componentName: 'c2', hosts: [
              {hostName: 'h1', isInstalled: false},
              {hostName: 'h2', isInstalled: false}
            ]}
          ],
          headers: [
            Em.Object.create({name: 'c1', label: 'C1'}),
            Em.Object.create({name: 'c2', label: 'C2'})
          ],
          hostsObj: [
            Em.Object.create({
              hostName: 'h1',
              checkboxes: [
                Em.Object.create({
                  title: 'C1',
                  checked: false,
                  isInstalled: false
                }),
                Em.Object.create({
                  title: 'C2',
                  checked: false,
                  isInstalled: false
                })
              ]
            }),
            Em.Object.create({
              hostName: 'h2',
              checkboxes: [
                Em.Object.create({
                  title: 'C1',
                  checked: false,
                  isInstalled: false
                }),
                Em.Object.create({
                  title: 'C2',
                  checked: false,
                  isInstalled: false
                })
              ]
            })
          ],
          m: 'all Checked, nothing installed before',
          e: {
            checked: [
              [true, true],
              [true, true]
            ],
            isInstalled: [
              [false, false],
              [false, false]
            ]
          }
        },
        {
          slaveComponents: [
            {componentName: 'c1', hosts: [
              {hostName: 'h1', isInstalled: true},
              {hostName: 'h2', isInstalled: true}
            ]},
            {componentName: 'c2', hosts: [
              {hostName: 'h1', isInstalled: true},
              {hostName: 'h2', isInstalled: true}
            ]}
          ],
          headers: [
            Em.Object.create({name: 'c1', label: 'C1'}),
            Em.Object.create({name: 'c2', label: 'C2'})
          ],
          hostsObj: [
            Em.Object.create({
              hostName: 'h1',
              checkboxes: [
                Em.Object.create({
                  title: 'C1',
                  checked: false,
                  isInstalled: false
                }),
                Em.Object.create({
                  title: 'C2',
                  checked: false,
                  isInstalled: false
                })
              ]
            }),
            Em.Object.create({
              hostName: 'h2',
              checkboxes: [
                Em.Object.create({
                  title: 'C1',
                  checked: false,
                  isInstalled: false
                }),
                Em.Object.create({
                  title: 'C2',
                  checked: false,
                  isInstalled: false
                })
              ]
            })
          ],
          m: 'all Checked, all installed before',
          e: {
            checked: [
              [true, true],
              [true, true]
            ],
            isInstalled: [
              [true, true],
              [true, true]
            ]
          }
        },
        {
          slaveComponents: [
            {componentName: 'c1', hosts: [
              {hostName: 'h1', isInstalled: true}
            ]},
            {componentName: 'c2', hosts: [
              {hostName: 'h2', isInstalled: true}
            ]}
          ],
          headers: [
            Em.Object.create({name: 'c1', label: 'C1'}),
            Em.Object.create({name: 'c2', label: 'C2'})
          ],
          hostsObj: [
            Em.Object.create({
              hostName: 'h1',
              checkboxes: [
                Em.Object.create({
                  title: 'C1',
                  checked: false,
                  isInstalled: false
                }),
                Em.Object.create({
                  title: 'C2',
                  checked: false,
                  isInstalled: false
                })
              ]
            }),
            Em.Object.create({
              hostName: 'h2',
              checkboxes: [
                Em.Object.create({
                  title: 'C1',
                  checked: false,
                  isInstalled: false
                }),
                Em.Object.create({
                  title: 'C2',
                  checked: false,
                  isInstalled: false
                })
              ]
            })
          ],
          m: 'some Checked, some installed before',
          e: {
            checked: [
              [true, false],
              [false, true]
            ],
            isInstalled: [
              [true, false],
              [false, true]
            ]
          }
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          controller.set('content.slaveComponentHosts', test.slaveComponents);
          controller.set('headers', test.headers);
          var r = controller.renderSlaves(test.hostsObj);
          var checked = r.map(function (i) {
            return i.get('checkboxes').map(function (j) {
              return j.get('checked')
            })
          });
          var isInstalled = r.map(function (i) {
            return i.get('checkboxes').map(function (j) {
              return j.get('isInstalled')
            })
          });
          expect(checked).to.eql(test.e.checked);
          expect(isInstalled).to.eql(test.e.isInstalled);
        });
      });
  });

});
});

;require.register("test/controllers/wizard/step7_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var numberUtils = require('utils/number_utils');
require('mixins/common/localStorage');
require('models/config_group');
require('controllers/wizard/step7_controller');

var installerStep7Controller;

describe('App.InstallerStep7Controller', function () {

  beforeEach(function () {
    installerStep7Controller = App.WizardStep7Controller.create();
  });

  describe('#installedServiceNames', function () {

    var tests = Em.A([
      {
        content: Em.Object.create({
          controllerName: 'installerController',
          services: Em.A([
            Em.Object.create({
              isInstalled: true,
              serviceName: 'SQOOP'
            }),
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HDFS'
            })
          ])
        }),
        e: ['SQOOP', 'HDFS'],
        m: 'installerController with SQOOP'
      },
      {
        content: Em.Object.create({
          controllerName: 'installerController',
          services: Em.A([
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HIVE'
            }),
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HDFS'
            })
          ])
        }),
        e: ['HIVE', 'HDFS'],
        m: 'installerController without SQOOP'
      },
      {
        content: Em.Object.create({
          controllerName: 'addServiceController',
          services: Em.A([
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HIVE'
            }),
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HDFS'
            })
          ])
        }),
        e: ['HIVE', 'HDFS'],
        m: 'addServiceController without SQOOP'
      },
      {
        content: Em.Object.create({
          controllerName: 'addServiceController',
          services: Em.A([
            Em.Object.create({
              isInstalled: true,
              serviceName: 'SQOOP'
            }),
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HIVE'
            }),
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HDFS'
            })
          ])
        }),
        e: ['HIVE', 'HDFS'],
        m: 'addServiceController with SQOOP'
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        installerStep7Controller.set('content', test.content);
        expect(installerStep7Controller.get('installedServiceNames')).to.include.members(test.e);
        expect(test.e).to.include.members(installerStep7Controller.get('installedServiceNames'));
      });
    });

  });

  describe('#isSubmitDisabled', function () {
    it('should be true if miscModalVisible', function () {
      installerStep7Controller.reopen({miscModalVisible: true});
      expect(installerStep7Controller.get('isSubmitDisabled')).to.equal(true);
    });
    it('should be true if some of stepConfigs has errors', function () {
      installerStep7Controller.reopen({
        miscModalVisible: false,
        stepConfigs: [
          {
            showConfig: true,
            errorCount: 1
          }
        ]
      });
      expect(installerStep7Controller.get('isSubmitDisabled')).to.equal(true);
    });
    it('should be false if all of stepConfigs don\'t have errors and miscModalVisible is false', function () {
      installerStep7Controller.reopen({
        miscModalVisible: false,
        stepConfigs: [
          {
            showConfig: true,
            errorCount: 0
          }
        ]
      });
      expect(installerStep7Controller.get('isSubmitDisabled')).to.equal(false);
    });
  });

  describe('#selectedServiceNames', function () {
    it('should use content.services as source of data', function () {
      installerStep7Controller.set('content', {
        services: [
          {isSelected: true, isInstalled: false, serviceName: 's1'},
          {isSelected: false, isInstalled: false, serviceName: 's2'},
          {isSelected: true, isInstalled: true, serviceName: 's3'},
          {isSelected: false, isInstalled: false, serviceName: 's4'},
          {isSelected: true, isInstalled: false, serviceName: 's5'},
          {isSelected: false, isInstalled: false, serviceName: 's6'},
          {isSelected: true, isInstalled: true, serviceName: 's7'},
          {isSelected: false, isInstalled: false, serviceName: 's8'}
        ]
      });
      var expected = ['s1', 's5'];
      expect(installerStep7Controller.get('selectedServiceNames')).to.eql(expected);
    });
  });

  describe('#allSelectedServiceNames', function () {
    it('should use content.services as source of data', function () {
      installerStep7Controller.set('content', {
        services: [
          {isSelected: true, isInstalled: false, serviceName: 's1'},
          {isSelected: false, isInstalled: false, serviceName: 's2'},
          {isSelected: true, isInstalled: true, serviceName: 's3'},
          {isSelected: false, isInstalled: false, serviceName: 's4'},
          {isSelected: true, isInstalled: false, serviceName: 's5'},
          {isSelected: false, isInstalled: false, serviceName: 's6'},
          {isSelected: true, isInstalled: true, serviceName: 's7'},
          {isSelected: false, isInstalled: false, serviceName: 's8'}
        ]
      });
      var expected = ['s1', 's3', 's5', 's7'];
      expect(installerStep7Controller.get('allSelectedServiceNames')).to.eql(expected);
    });
  });

  describe('#masterComponentHosts', function () {
    it('should be equal to content.masterComponentHosts', function () {
      var masterComponentHosts = [
        {},
        {},
        {}
      ];
      installerStep7Controller.reopen({content: {masterComponentHosts: masterComponentHosts}});
      expect(installerStep7Controller.get('masterComponentHosts')).to.eql(masterComponentHosts);
    });
  });

  describe('#slaveComponentHosts', function () {
    it('should be equal to content.slaveGroupProperties', function () {
      var slaveGroupProperties = [
        {},
        {},
        {}
      ];
      installerStep7Controller.reopen({content: {slaveGroupProperties: slaveGroupProperties}});
      expect(installerStep7Controller.get('slaveComponentHosts')).to.eql(slaveGroupProperties);
    });
  });

  describe('#clearStep', function () {
    it('should clear serviceConfigTags', function () {
      installerStep7Controller.set('serviceConfigTags', [
        {},
        {}
      ]);
      installerStep7Controller.clearStep();
      expect(installerStep7Controller.get('serviceConfigTags.length')).to.equal(0);
    });
    it('should clear stepConfigs', function () {
      installerStep7Controller.set('stepConfigs', [
        {},
        {}
      ]);
      installerStep7Controller.clearStep();
      expect(installerStep7Controller.get('stepConfigs.length')).to.equal(0);
    });
    it('should clear filter', function () {
      installerStep7Controller.set('filter', 'filter');
      installerStep7Controller.clearStep();
      expect(installerStep7Controller.get('filter')).to.equal('');
    });
    it('should set for each filterColumns "selected" false', function () {
      installerStep7Controller.set('filterColumns', [
        {selected: true},
        {selected: false},
        {selected: true}
      ]);
      installerStep7Controller.clearStep();
      expect(installerStep7Controller.get('filterColumns').everyProperty('selected', false)).to.equal(true);
    });
  });

  describe('#loadInstalledServicesConfigGroups', function () {
    before(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    after(function () {
      App.ajax.send.restore();
    });
    it('should do ajax request for each received service name', function () {
      var serviceNames = ['s1', 's2', 's3'];
      installerStep7Controller.loadInstalledServicesConfigGroups(serviceNames);
      expect(App.ajax.send.callCount).to.equal(serviceNames.length);
    });
  });

  describe('#getConfigTags', function () {
    before(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    after(function () {
      App.ajax.send.restore();
    });
    it('should do ajax-request', function () {
      installerStep7Controller.getConfigTags();
      expect(App.ajax.send.calledOnce).to.equal(true);
    });
  });

  describe('#setGroupsToDelete', function () {
    beforeEach(function () {
      installerStep7Controller.set('wizardController', Em.Object.create(App.LocalStorage, {name: 'tdk'}));
    });
    it('should add new groups to groupsToDelete', function () {
      var groupsToDelete = [
          {id: '1'},
          {id: '2'}
        ],
        groups = [
          Em.Object.create({id: '3'}),
          Em.Object.create(),
          Em.Object.create({id: '5'})
        ],
        expected = [
          {id: "1"},
          {id: "2"},
          {id: "3"},
          {id: "5"}
        ];
      installerStep7Controller.set('groupsToDelete', groupsToDelete);
      installerStep7Controller.setGroupsToDelete(groups);
      expect(installerStep7Controller.get('groupsToDelete')).to.eql(expected);
      expect(installerStep7Controller.get('wizardController').getDBProperty('groupsToDelete')).to.eql(expected);
    });
  });

  describe('#selectConfigGroup', function () {
    beforeEach(function () {
      installerStep7Controller.reopen({content: {services: []}});
      sinon.stub(installerStep7Controller, 'switchConfigGroupConfigs', Em.K);
    });
    afterEach(function () {
      installerStep7Controller.switchConfigGroupConfigs.restore();
    });
    it('should set selectedConfigGroup', function () {
      var group = {':': []};
      installerStep7Controller.selectConfigGroup({context: group});
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(group);
    });
  });

  describe('#submit', function () {
    beforeEach(function () {
      sinon.stub(App.router, 'send', Em.K);
    });
    afterEach(function () {
      App.router.send.restore();
    });
    it('should proceed if submit is not disabled', function () {
      installerStep7Controller.reopen({isSubmitDisabled: false});
      installerStep7Controller.submit();
      expect(App.router.send.calledOnce).to.equal(true);
    });
    it('should not proceed if submit is disabled', function () {
      installerStep7Controller.reopen({isSubmitDisabled: true});
      installerStep7Controller.submit();
      expect(App.router.send.called).to.equal(false);
    });
  });

  describe('#addOverrideProperty', function () {
    it('should add override property', function () {
      var groupName = 'groupName',
        selectedService = {configGroups: [Em.Object.create({name: groupName, properties: []})]},
        selectedConfigGroup = {name: groupName},
        serviceConfigProperty = Em.Object.create({overrides: []}),
        expected = Em.Object.create({
          value: '',
          isOriginalSCP: false,
          isEditable: true
        });
      installerStep7Controller.reopen({selectedService: selectedService, selectedConfigGroup: selectedConfigGroup});
      var newSCP = installerStep7Controller.addOverrideProperty(serviceConfigProperty);
      Em.keys(expected).forEach(function (k) {
        expect(newSCP.get(k)).to.equal(expected.get(k));
      });
      var group = installerStep7Controller.get('selectedService.configGroups').findProperty('name', groupName);
      expect(newSCP.get('group')).to.eql(group);
      expect(newSCP.get('parentSCP')).to.eql(serviceConfigProperty);
      expect(group.get('properties.length')).to.equal(1);
    });
  });

  describe('#getConfigTagsSuccess', function () {
    it('should update serviceConfigTags', function () {
      var installedServiceNames = ['s1', 's2'],
        serviceConfigsData = [
          {serviceName: 's1', sites: ['s1-site', 's1-log']},
          {serviceName: 's2', sites: ['s2-site', 'core-site']},
          {serviceName: 's3', sites: ['s3-site']}
        ],
        data = {
          Clusters: {
            desired_configs: {
              "core-site": {
                "user": "admin",
                "tag": "version1398780546992"
              },
              "global": {
                "user": "admin",
                "tag": "version1398780546992"
              },
              "s1-site": {
                "user": "admin",
                "tag": "version1"
              },
              "s1-log": {
                "user": "admin",
                "tag": "version1"
              },
              "s2-site": {
                "user": "admin",
                "tag": "version1"
              },
              "s3-site": {
                "user": "admin",
                "tag": "version1"
              }
            }
          }
        },
        serviceConfigTags = [
          {siteName: 'core-site', tagName: 'version1398780546992', newTagName: null},
          {siteName: 's1-site', tagName: 'version1', newTagName: null},
          {siteName: 's1-log', tagName: 'version1', newTagName: null},
          {siteName: 's2-site', tagName: 'version1', newTagName: null}
        ];
      installerStep7Controller.reopen({serviceConfigsData: serviceConfigsData, installedServiceNames: installedServiceNames});
      installerStep7Controller.getConfigTagsSuccess(data);
      expect(installerStep7Controller.get('serviceConfigTags')).to.eql(serviceConfigTags);
    });
  });

  describe('#resolveStormConfigs', function () {
    beforeEach(function () {
      installerStep7Controller.reopen({
        content: {services: []},
        wizardController: Em.Object.create({
          getDBProperty: function () {
            return [
              {component: 'GANGLIA_SERVER', hostName: 'h1'}
            ];
          }
        })
      });
    });
    it('shouldn\'t do nothing if Ganglia and Storm are installed', function () {
      var installedServiceNames = ['GANGLIA', 'STORM'],
        configs = [
          {name: 'nimbus.childopts', value: '.jar=host=', defaultValue: ''},
          {name: 'supervisor.childopts', value: '.jar=host=', defaultValue: ''},
          {name: 'worker.childopts', value: '.jar=host=', defaultValue: ''}
        ],
        expected = [
          {name: 'nimbus.childopts', value: '.jar=host=', defaultValue: ''},
          {name: 'supervisor.childopts', value: '.jar=host=', defaultValue: ''},
          {name: 'worker.childopts', value: '.jar=host=', defaultValue: ''}
        ];
      installerStep7Controller.reopen({installedServiceNames: installedServiceNames});
      installerStep7Controller.resolveStormConfigs(configs);
      expect(configs).to.eql(expected);
    });
    it('shouldn\'t do nothing if Ganglia is in allSelectedServiceNames', function () {
      var allSelectedServiceNames = ['GANGLIA'],
        configs = [
          {name: 'nimbus.childopts', value: '.jar=host=', defaultValue: ''},
          {name: 'supervisor.childopts', value: '.jar=host=', defaultValue: ''},
          {name: 'worker.childopts', value: '.jar=host=', defaultValue: ''}
        ],
        expected = [
          {name: 'nimbus.childopts', value: '.jar=host=h1', defaultValue: '.jar=host=h1', forceUpdate: true},
          {name: 'supervisor.childopts', value: '.jar=host=h1', defaultValue: '.jar=host=h1', forceUpdate: true},
          {name: 'worker.childopts', value: '.jar=host=h1', defaultValue: '.jar=host=h1', forceUpdate: true}
        ];
      installerStep7Controller.reopen({allSelectedServiceNames: allSelectedServiceNames});
      installerStep7Controller.resolveStormConfigs(configs);
      Em.keys(expected[0]).forEach(function (k) {
        expect(configs.mapProperty(k)).to.eql(expected.mapProperty(k));
      });
    });
    it('shouldn\'t do nothing if Ganglia is in installedServiceNames', function () {
      var installedServiceNames = ['GANGLIA'],
        configs = [
          {name: 'nimbus.childopts', value: '.jar=host=', defaultValue: ''},
          {name: 'supervisor.childopts', value: '.jar=host=', defaultValue: ''},
          {name: 'worker.childopts', value: '.jar=host=', defaultValue: ''}
        ],
        expected = [
          {name: 'nimbus.childopts', value: '.jar=host=h1', defaultValue: '.jar=host=h1', forceUpdate: true},
          {name: 'supervisor.childopts', value: '.jar=host=h1', defaultValue: '.jar=host=h1', forceUpdate: true},
          {name: 'worker.childopts', value: '.jar=host=h1', defaultValue: '.jar=host=h1', forceUpdate: true}
        ];
      installerStep7Controller.reopen({installedServiceNames: installedServiceNames});
      installerStep7Controller.resolveStormConfigs(configs);
      Em.keys(expected[0]).forEach(function (k) {
        expect(configs.mapProperty(k)).to.eql(expected.mapProperty(k));
      });
    });
  });

  describe('#resolveServiceDependencyConfigs', function () {
    beforeEach(function () {
      sinon.stub(installerStep7Controller, 'resolveStormConfigs', Em.K);
    });
    afterEach(function () {
      installerStep7Controller.resolveStormConfigs.restore();
    });
    it('should call resolveStormConfigs if serviceName is STORM', function () {
      var serviceName = 'STORM', configs = [
        {},
        {},
        {}
      ];
      installerStep7Controller.resolveServiceDependencyConfigs(serviceName, configs);
      expect(installerStep7Controller.resolveStormConfigs.calledWith(configs)).to.equal(true);
    });
  });

  describe('#selectedServiceObserver', function () {
    beforeEach(function () {
      installerStep7Controller.reopen({content: {services: []}});
      sinon.stub(installerStep7Controller, 'switchConfigGroupConfigs', Em.K);
    });
    afterEach(function () {
      installerStep7Controller.switchConfigGroupConfigs.restore();
    });
    it('shouldn\'t do nothing if App.supports.hostOverridesInstaller is false', function () {
      App.set('supports.hostOverridesInstaller', false);
      var configGroups = [
          {},
          {}
        ],
        selectedConfigGroup = {};
      installerStep7Controller.reopen({configGroups: configGroups, selectedConfigGroup: selectedConfigGroup});
      installerStep7Controller.selectedServiceObserver();
      expect(installerStep7Controller.get('configGroups')).to.eql(configGroups);
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(selectedConfigGroup);
    });
    it('shouldn\'t do nothing if selectedService is null', function () {
      App.set('supports.hostOverridesInstaller', true);
      var configGroups = [
          {},
          {}
        ],
        selectedConfigGroup = {};
      installerStep7Controller.reopen({selectedService: null, configGroups: configGroups, selectedConfigGroup: selectedConfigGroup});
      installerStep7Controller.selectedServiceObserver();
      expect(installerStep7Controller.get('configGroups')).to.eql(configGroups);
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(selectedConfigGroup);
    });
    it('shouldn\'t do nothing if selectedService.serviceName is MISC', function () {
      App.set('supports.hostOverridesInstaller', true);
      var configGroups = [
          {},
          {}
        ],
        selectedConfigGroup = {};
      installerStep7Controller.reopen({selectedService: {serviceName: 'MISC'}, configGroups: configGroups, selectedConfigGroup: selectedConfigGroup});
      installerStep7Controller.selectedServiceObserver();
      expect(installerStep7Controller.get('configGroups')).to.eql(configGroups);
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(selectedConfigGroup);
    });
    it('should update configGroups and selectedConfigGroup', function () {
      App.set('supports.hostOverridesInstaller', true);
      var defaultGroup = {isDefault: true, n: 'n2'},
        configGroups = [
          {isDefault: false, n: 'n1'},
          defaultGroup,
          {n: 'n3'}
        ],
        selectedConfigGroup = {};
      installerStep7Controller.reopen({selectedService: {serviceName: 's1', configGroups: configGroups}});
      installerStep7Controller.selectedServiceObserver();
      expect(installerStep7Controller.get('configGroups').mapProperty('n')).to.eql(['n2', 'n1', 'n3']);
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(defaultGroup);
    });
  });

  describe('#loadConfigGroups', function () {
    beforeEach(function () {
      installerStep7Controller.reopen({
        wizardController: Em.Object.create({
          allHosts: [
            {hostName: 'h1'},
            {hostName: 'h2'},
            {hostName: 'h3'}
          ]
        })
      });
    });
    it('shouldn\'t do nothing if only MISC available', function () {
      var configGroups = [
        {}
      ];
      installerStep7Controller.reopen({
        stepConfigs: [Em.Object.create({serviceName: 'MISC', configGroups: configGroups})]
      });
      installerStep7Controller.loadConfigGroups([]);
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups')).to.eql(configGroups);
    });
    it('should set configGroups for service if they don\'t exist', function () {
      var configGroups = [],
        serviceName = 'HDFS',
        serviceConfigGroups = [
          {service: {id: 's1'}}
        ];
      installerStep7Controller.reopen({
        stepConfigs: [Em.Object.create({serviceName: serviceName, configGroups: configGroups})]
      });
      installerStep7Controller.loadConfigGroups(serviceConfigGroups);
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups.length')).to.equal(1);
      var group = installerStep7Controller.get('stepConfigs.firstObject.configGroups.firstObject');
      expect(group.get('name')).to.equal(serviceName + ' Default');
      expect(group.get('description').contains(serviceName)).to.equal(true);
      expect(group.get('isDefault')).to.equal(true);
      expect(group.get('hosts')).to.eql(['h1', 'h2', 'h3']);
      expect(group.get('service.id')).to.equal(serviceName);
      expect(group.get('serviceName')).to.equal(serviceName);
    });
    it('should update configGroups for service (only default group)', function () {
      var configGroups = [],
        serviceName = 'HDFS',
        serviceConfigGroups = [
          {service: {id: 'HDFS'}, isDefault: true, n: 'n1'}
        ];
      installerStep7Controller.reopen({
        stepConfigs: [Em.Object.create({serviceName: serviceName, configGroups: configGroups})]
      });
      installerStep7Controller.loadConfigGroups(serviceConfigGroups);
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups').findProperty('isDefault').get('n')).to.equal('n1');
    });
    it('should update configGroups for service', function () {
      var configGroups = [],
        serviceName = 'HDFS',
        serviceConfigGroups = [
          {service: {id: 'HDFS'}, properties: [
            {},
            {}
          ], isDefault: true, n: 'n1'},
          {service: {id: 'HDFS'}, properties: [
            {},
            {}
          ], isDefault: false, n: 'n2'}
        ];
      installerStep7Controller.reopen({
        stepConfigs: [Em.Object.create({serviceName: serviceName, configGroups: configGroups})]
      });
      installerStep7Controller.loadConfigGroups(serviceConfigGroups);
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups.length')).to.equal(2);
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups').findProperty('isDefault').get('n')).to.equal('n1');
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups').findProperty('isDefault', false).get('properties').everyProperty('group.n', 'n2')).to.equal(true);
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups').findProperty('isDefault', false).get('parentConfigGroup.n')).to.equal('n1');
    });
  });

  describe('#_getDisplayedConfigGroups', function () {
    it('should return [] if no selected group', function () {
      installerStep7Controller.reopen({
        content: {services: []},
        selectedConfigGroup: null
      });
      expect(installerStep7Controller._getDisplayedConfigGroups()).to.eql([]);
    });
    it('should return default config group if another selected', function () {
      var defaultGroup = Em.Object.create({isDefault: false});
      installerStep7Controller.reopen({
        content: {services: []},
        selectedConfigGroup: defaultGroup
      });
      expect(installerStep7Controller._getDisplayedConfigGroups()).to.eql([defaultGroup]);
    });
    it('should return other groups if default selected', function () {
      var defaultGroup = Em.Object.create({isDefault: true}),
        cfgG = Em.Object.create({isDefault: true}),
        configGroups = Em.A([
          Em.Object.create({isDefault: false}),
          Em.Object.create({isDefault: false}),
          cfgG,
          Em.Object.create({isDefault: false})
        ]);
      installerStep7Controller.reopen({
        content: {services: []},
        selectedConfigGroup: defaultGroup,
        selectedService: {configGroups: configGroups}
      });
      expect(installerStep7Controller._getDisplayedConfigGroups()).to.eql(configGroups.without(cfgG));
    });
  });

  describe('#_setEditableValue', function () {
    it('shouldn\'t update config if no selectedConfigGroup', function () {
      installerStep7Controller.reopen({
        selectedConfigGroup: null
      });
      var config = Em.Object.create({isEditable: null});
      var updatedConfig = installerStep7Controller._setEditableValue(config);
      expect(updatedConfig.get('isEditable')).to.be.null;
    });
    it('should set isEditable equal to selectedGroup.isDefault if service not installed', function () {
      var isDefault = true;
      installerStep7Controller.reopen({
        installedServiceNames: [],
        selectedService: {serviceName: 'abc'},
        selectedConfigGroup: Em.Object.create({isDefault: isDefault})
      });
      var config = Em.Object.create({isEditable: null});
      var updatedConfig = installerStep7Controller._setEditableValue(config);
      expect(updatedConfig.get('isEditable')).to.equal(isDefault);
      installerStep7Controller.toggleProperty('selectedConfigGroup.isDefault');
      updatedConfig = installerStep7Controller._setEditableValue(config);
      expect(updatedConfig.get('isEditable')).to.equal(!isDefault);
    });
    Em.A([
        {
          isEditable: false,
          isReconfigurable: false,
          isDefault: true,
          e: false
        },
        {
          isEditable: true,
          isReconfigurable: true,
          isDefault: true,
          e: true
        },
        {
          isEditable: false,
          isReconfigurable: true,
          isDefault: false,
          e: false
        },
        {
          isEditable: true,
          isReconfigurable: false,
          isDefault: false,
          e: false
        }
      ]).forEach(function (test) {
        it('service installed, isEditable = ' + test.isEditable.toString() + ', isReconfigurable = ' + test.isReconfigurable.toString(), function () {
          var config = Em.Object.create({
            isReconfigurable: test.isReconfigurable,
            isEditable: test.isEditable
          });
          installerStep7Controller.reopen({
            installedServiceNames: Em.A(['a']),
            selectedService: Em.Object.create({serviceName: 'a'}),
            selectedConfigGroup: Em.Object.create({isDefault: test.isDefault})
          });
          var updateConfig = installerStep7Controller._setEditableValue(config);
          expect(updateConfig.get('isEditable')).to.equal(test.e);
        });
      });
  });

  describe('#_setOverrides', function () {
    it('shouldn\'t update config if no selectedConfigGroup', function () {
      installerStep7Controller.reopen({
        selectedConfigGroup: null
      });
      var config = Em.Object.create({overrides: null});
      var updatedConfig = installerStep7Controller._setOverrides(config, []);
      expect(updatedConfig.get('overrides')).to.be.null;
    });
    it('no overrideToAdd', function () {
      var isDefault = true,
        name = 'n1',
        config = Em.Object.create({overrides: null, name: name, flag: 'flag'}),
        overrides = Em.A([
          Em.Object.create({name: name, value: 'v1'}),
          Em.Object.create({name: name, value: 'v2'}),
          Em.Object.create({name: 'n2', value: 'v3'})
        ]);
      installerStep7Controller.reopen({
        overrideToAdd: null,
        selectedConfigGroup: Em.Object.create({
          isDefault: isDefault
        })
      });
      var updatedConfig = installerStep7Controller._setOverrides(config, overrides);
      expect(updatedConfig.get('overrides.length')).to.equal(2);
      expect(updatedConfig.get('overrides').everyProperty('isEditable', !isDefault)).to.equal(true);
      expect(updatedConfig.get('overrides').everyProperty('parentSCP.flag', 'flag')).to.equal(true);
    });
    it('overrideToAdd exists', function () {
      var isDefault = true,
        name = 'n1',
        config = Em.Object.create({overrides: null, name: name, flag: 'flag'}),
        overrides = Em.A([
          Em.Object.create({name: name, value: 'v1'}),
          Em.Object.create({name: name, value: 'v2'}),
          Em.Object.create({name: 'n2', value: 'v3'})
        ]);
      installerStep7Controller.reopen({
        overrideToAdd: Em.Object.create({name: name}),
        selectedService: {configGroups: [Em.Object.create({name: 'n', properties: []})]},
        selectedConfigGroup: Em.Object.create({
          isDefault: isDefault,
          name: 'n'
        })
      });
      var updatedConfig = installerStep7Controller._setOverrides(config, overrides);
      expect(updatedConfig.get('overrides.length')).to.equal(3);
      expect(updatedConfig.get('overrides').everyProperty('isEditable', !isDefault)).to.equal(true);
      expect(updatedConfig.get('overrides').everyProperty('parentSCP.flag', 'flag')).to.equal(true);
    });
  });

  describe('#switchConfigGroupConfigs', function () {
    it('if selectedConfigGroup is null, serviceConfigs shouldn\'t be changed', function () {
      installerStep7Controller.reopen({
        selectedConfigGroup: null,
        content: {services: []},
        serviceConfigs: {configs: [
          {overrides: []},
          {overrides: []}
        ]}
      });
      installerStep7Controller.switchConfigGroupConfigs();
      expect(installerStep7Controller.get('serviceConfigs.configs').everyProperty('overrides.length', 0)).to.equal(true);
    });
    it('should set configs for serviceConfigs', function () {
      var configGroups = [
        Em.Object.create({
          properties: [
            {name: 'g1', value: 'v1'},
            {name: 'g2', value: 'v2'}
          ]
        })
      ];
      sinon.stub(installerStep7Controller, '_getDisplayedConfigGroups', function () {
        return configGroups;
      });
      sinon.stub(installerStep7Controller, '_setEditableValue', function (config) {
        config.set('isEditable', true);
        return config;
      });
      installerStep7Controller.reopen({
        selectedConfigGroup: Em.Object.create({isDefault: true, name: 'g1'}),
        content: {services: []},
        selectedService: {configs: Em.A([Em.Object.create({name: 'g1', overrides: [], properties: []}), Em.Object.create({name: 'g2', overrides: []})])},
        serviceConfigs: {configs: [Em.Object.create({name: 'g1'})]}
      });
      installerStep7Controller.switchConfigGroupConfigs();
      var configs = installerStep7Controller.get('selectedService.configs');
      expect(configs.findProperty('name', 'g1').get('overrides').length).to.equal(1);
      expect(configs.findProperty('name', 'g2').get('overrides').length).to.equal(1);
      expect(configs.everyProperty('isEditable', true)).to.equal(true);
      installerStep7Controller._getDisplayedConfigGroups.restore();
      installerStep7Controller._setEditableValue.restore();
    });
  });

  describe('#selectProperService', function () {
    Em.A([
        {
          name: 'addServiceController',
          stepConfigs: [
            {selected: false, name: 'n1'},
            {selected: true, name: 'n2'},
            {selected: true, name: 'n3'}
          ],
          e: 'n2'
        },
        {
          name: 'installerController',
          stepConfigs: [
            {showConfig: false, name: 'n1'},
            {showConfig: false, name: 'n2'},
            {showConfig: true, name: 'n3'}
          ],
          e: 'n3'
        }
      ]).forEach(function (test) {
        it(test.name, function () {
          sinon.stub(installerStep7Controller, 'selectedServiceObserver', Em.K);
          installerStep7Controller.reopen({
            wizardController: Em.Object.create({
              name: test.name
            }),
            stepConfigs: test.stepConfigs
          });
          installerStep7Controller.selectProperService();
          expect(installerStep7Controller.get('selectedService.name')).to.equal(test.e);
          installerStep7Controller.selectedServiceObserver.restore();
        });
      });
  });

  describe('#setStepConfigs', function () {
    beforeEach(function () {
      installerStep7Controller.reopen({
        content: {services: []},
        wizardController: Em.Object.create({
          getDBProperty: function (key) {
            return this.get(key);
          }
        })
      });
    });
    afterEach(function () {
      App.config.renderConfigs.restore();
    });
    it('if wizard isn\'t addService, should set output of App.config.renderConfigs', function () {
      var serviceConfigs = Em.A([
        {},
        {}
      ]);
      sinon.stub(App.config, 'renderConfigs', function () {
        return serviceConfigs;
      });
      installerStep7Controller.set('wizardController.name', 'installerController');
      installerStep7Controller.setStepConfigs([], []);
      expect(installerStep7Controller.get('stepConfigs')).to.eql(serviceConfigs);
    });
    it('addServiceWizard used', function () {
      var serviceConfigs = Em.A([Em.Object.create({serviceName: 's1'}), Em.Object.create({serviceName: 's2'})]);
      installerStep7Controller.set('wizardController.name', 'addServiceController');
      installerStep7Controller.reopen({selectedServiceNames: ['s2']});
      sinon.stub(App.config, 'renderConfigs', function () {
        return serviceConfigs;
      });
      installerStep7Controller.setStepConfigs([], []);
      expect(installerStep7Controller.get('stepConfigs').everyProperty('showConfig', true)).to.equal(true);
      expect(installerStep7Controller.get('stepConfigs').findProperty('serviceName', 's2').get('selected')).to.equal(true);
    });
    it('addServiceWizard used, HA enabled', function () {
      sinon.stub(App, 'get', function (k) {
        if (k === 'isHaEnabled') {
          return true;
        }
        return Em.get(App, k);
      });
      var serviceConfigs = Em.A([
        Em.Object.create({
          serviceName: 'HDFS',
          configs: [
            {category: 'SNameNode'},
            {category: 'SNameNode'},
            {category: 'NameNode'},
            {category: 'NameNode'},
            {category: 'SNameNode'}
          ]
        }),
        Em.Object.create({serviceName: 's2'})]
      );
      installerStep7Controller.set('wizardController.name', 'addServiceController');
      installerStep7Controller.reopen({selectedServiceNames: ['HDFS', 's2']});
      sinon.stub(App.config, 'renderConfigs', function () {
        return serviceConfigs;
      });
      installerStep7Controller.setStepConfigs([], []);
      expect(installerStep7Controller.get('stepConfigs').everyProperty('showConfig', true)).to.equal(true);
      expect(installerStep7Controller.get('stepConfigs').findProperty('serviceName', 'HDFS').get('selected')).to.equal(true);
      expect(installerStep7Controller.get('stepConfigs').findProperty('serviceName', 'HDFS').get('configs').length).to.equal(2);
      App.get.restore();
    });
  });

  describe('#checkHostOverrideInstaller', function () {
    beforeEach(function () {
      sinon.stub(installerStep7Controller, 'loadConfigGroups', Em.K);
      sinon.stub(installerStep7Controller, 'loadInstalledServicesConfigGroups', Em.K);
    });
    afterEach(function () {
      installerStep7Controller.loadConfigGroups.restore();
      installerStep7Controller.loadInstalledServicesConfigGroups.restore();
      App.get.restore();
    });
    Em.A([
        {
          hostOverridesInstaller: false,
          installedServiceNames: [],
          m: 'hostOverridesInstaller is false, installedServiceNames is empty',
          e: {
            loadConfigGroups: false,
            loadInstalledServicesConfigGroups: false
          }
        },
        {
          hostOverridesInstaller: false,
          installedServiceNames: ['s1', 's2'],
          m: 'hostOverridesInstaller is false, installedServiceNames is n\'t empty',
          e: {
            loadConfigGroups: false,
            loadInstalledServicesConfigGroups: false
          }
        },
        {
          hostOverridesInstaller: true,
          installedServiceNames: [],
          m: 'hostOverridesInstaller is true, installedServiceNames is empty',
          e: {
            loadConfigGroups: true,
            loadInstalledServicesConfigGroups: false
          }
        },
        {
          hostOverridesInstaller: true,
          installedServiceNames: ['s1', 's2', 's3'],
          m: 'hostOverridesInstaller is true, installedServiceNames isn\'t empty',
          e: {
            loadConfigGroups: true,
            loadInstalledServicesConfigGroups: true
          }
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          sinon.stub(App, 'get', function (k) {
            if (k === 'supports.hostOverridesInstaller') return test.hostOverridesInstaller;
            return Em.get(App, k);
          });
          installerStep7Controller.reopen({installedServiceNames: test.installedServiceNames});
          installerStep7Controller.checkHostOverrideInstaller();
          if (test.e.loadConfigGroups) {
            expect(installerStep7Controller.loadConfigGroups.calledOnce).to.equal(true);
          }
          else {
            expect(installerStep7Controller.loadConfigGroups.called).to.equal(false);
          }
          if (test.e.loadInstalledServicesConfigGroups) {
            expect(installerStep7Controller.loadInstalledServicesConfigGroups.calledOnce).to.equal(true);
          }
          else {
            expect(installerStep7Controller.loadInstalledServicesConfigGroups.called).to.equal(false);
          }
        });
      });
  });

  describe('#loadStep', function () {
    beforeEach(function () {
      installerStep7Controller.reopen({
        content: {services: []},
        wizardController: Em.Object.create({
          getDBProperty: function (k) {
            return this.get(k);
          }
        })
      });
      sinon.stub(App.config, 'mergePreDefinedWithStored', Em.K);
      sinon.stub(App.config, 'addAdvancedConfigs', Em.K);
      sinon.stub(App.config, 'addCustomConfigs', Em.K);
      sinon.stub(App.config, 'fileConfigsIntoTextarea', Em.K);
      sinon.stub(installerStep7Controller, 'clearStep', Em.K);
      sinon.stub(installerStep7Controller, 'getConfigTags', Em.K);
      sinon.stub(installerStep7Controller, 'setInstalledServiceConfigs', Em.K);
      sinon.stub(installerStep7Controller, 'resolveServiceDependencyConfigs', Em.K);
      sinon.stub(installerStep7Controller, 'setStepConfigs', Em.K);
      sinon.stub(installerStep7Controller, 'checkHostOverrideInstaller', Em.K);
      sinon.stub(installerStep7Controller, 'activateSpecialConfigs', Em.K);
      sinon.stub(installerStep7Controller, 'selectProperService', Em.K);
      sinon.stub(App.router, 'send', Em.K);
    });
    afterEach(function () {
      App.config.mergePreDefinedWithStored.restore();
      App.config.addAdvancedConfigs.restore();
      App.config.addCustomConfigs.restore();
      App.config.fileConfigsIntoTextarea.restore();
      installerStep7Controller.clearStep.restore();
      installerStep7Controller.getConfigTags.restore();
      installerStep7Controller.setInstalledServiceConfigs.restore();
      installerStep7Controller.resolveServiceDependencyConfigs.restore();
      installerStep7Controller.setStepConfigs.restore();
      installerStep7Controller.checkHostOverrideInstaller.restore();
      installerStep7Controller.activateSpecialConfigs.restore();
      installerStep7Controller.selectProperService.restore();
      App.router.send.restore();
    });
    it('should call clearStep', function () {
      installerStep7Controller.loadStep();
      expect(installerStep7Controller.clearStep.calledOnce).to.equal(true);
    });
    it('shouldn\'t do nothing if isAdvancedConfigLoaded is false', function () {
      installerStep7Controller.set('isAdvancedConfigLoaded', false);
      installerStep7Controller.loadStep();
      expect(installerStep7Controller.clearStep.called).to.equal(false);
    });
    it('should use App.config to map configs', function () {
      installerStep7Controller.loadStep();
      expect(App.config.mergePreDefinedWithStored.calledOnce).to.equal(true);
      expect(App.config.addAdvancedConfigs.calledOnce).to.equal(true);
      expect(App.config.addCustomConfigs.calledOnce).to.equal(true);
    });
    Em.A([
        {
          allSelectedServiceNames: ['YARN'],
          capacitySchedulerUi: false,
          e: true
        },
        {
          allSelectedServiceNames: ['YARN'],
          capacitySchedulerUi: true,
          e: false
        },
        {
          allSelectedServiceNames: ['HDFS'],
          capacitySchedulerUi: false,
          e: false
        },
        {
          allSelectedServiceNames: ['HDFS'],
          capacitySchedulerUi: true,
          e: false
        }
      ]).forEach(function (test) {
        it('allSelectedServiceNames = ' + JSON.stringify(test.allSelectedServiceNames) + ', capacitySchedulerUi = ' + test.capacitySchedulerUi.toString(), function () {
          sinon.stub(App, 'get', function (k) {
            if (k === 'supports.capacitySchedulerUi') return test.capacitySchedulerUi;
            return Em.get(App, k);
          });
          installerStep7Controller.reopen({allSelectedServiceNames: test.allSelectedServiceNames});
          installerStep7Controller.loadStep();
          if (test.e) {
            expect(App.config.fileConfigsIntoTextarea.calledOnce).to.equal(true);
          }
          else {
            expect(App.config.fileConfigsIntoTextarea.called).to.equal(false);
          }
          App.get.restore();
        });
      });
    it('should call getConfigTags, setInstalledServiceConfigs for addServiceController', function () {
      installerStep7Controller.set('wizardController.name', 'addServiceController');
      installerStep7Controller.loadStep();
      expect(installerStep7Controller.getConfigTags.calledOnce).to.equal(true);
      expect(installerStep7Controller.setInstalledServiceConfigs.calledOnce).to.equal(true);
    });
    Em.A([
        {
          allSelectedServiceNames: ['STORM'],
          installedServiceNames: ['STORM'],
          m: 'allSelectedServiceNames contains STORM, installedServiceNames contains STORM',
          e: true
        },
        {
          allSelectedServiceNames: [],
          installedServiceNames: ['STORM'],
          m: 'allSelectedServiceNames doesn\'t contain STORM, installedServiceNames contains STORM',
          e: true
        },
        {
          allSelectedServiceNames: ['STORM'],
          installedServiceNames: [],
          m: 'allSelectedServiceNames contains STORM, installedServiceNames doesn\'t contain STORM',
          e: true
        },
        {
          allSelectedServiceNames: [],
          installedServiceNames: [],
          m: 'allSelectedServiceNames doesn\'t contain STORM, installedServiceNames doesn\'t contain STORM',
          e: false
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          installerStep7Controller.reopen({
            allSelectedServiceNames: test.allSelectedServiceNames,
            installedServiceNames: test.installedServiceNames
          });
          installerStep7Controller.loadStep();
          if (test.e) {
            expect(installerStep7Controller.resolveServiceDependencyConfigs.calledOnce).to.equal(true);
          }
          else {
            expect(installerStep7Controller.resolveServiceDependencyConfigs.called).to.equal(false);
          }
        });
      });
    it('should call setStepConfigs', function () {
      installerStep7Controller.loadStep();
      expect(installerStep7Controller.setStepConfigs.calledOnce).to.equal(true);
    });
    it('should call checkHostOverrideInstaller', function () {
      installerStep7Controller.loadStep();
      expect(installerStep7Controller.checkHostOverrideInstaller.calledOnce).to.equal(true);
    });
    it('should call activateSpecialConfigs', function () {
      installerStep7Controller.loadStep();
      expect(installerStep7Controller.activateSpecialConfigs.calledOnce).to.equal(true);
    });
    it('should call selectProperService', function () {
      installerStep7Controller.loadStep();
      expect(installerStep7Controller.selectProperService.calledOnce).to.equal(true);
    });
    Em.A([
        {
          m: 'should skip config step',
          skipConfigStep: true,
          e: true
        },
        {
          m: 'shouldn\'t skip config step',
          skipConfigStep: false,
          e: false
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          installerStep7Controller.set('content.skipConfigStep', test.skipConfigStep);
          installerStep7Controller.loadStep();
          if (test.e) {
            expect(App.router.send.calledWith('next')).to.equal(true);
          }
          else {
            expect(App.router.send.called).to.equal(false);
          }
        });
      });
  });

  describe('#_updateValueForCheckBoxConfig', function () {
    Em.A([
        {
          v: 'true',
          e: true
        },
        {
          v: 'false',
          e: false
        }
      ]).forEach(function (test) {
        it(test.v, function () {
          var serviceConfigProperty = Em.Object.create({value: test.v});
          installerStep7Controller._updateValueForCheckBoxConfig(serviceConfigProperty);
          expect(serviceConfigProperty.get('value')).to.equal(test.e);
          expect(serviceConfigProperty.get('defaultValue')).to.equal(test.e);
        });
      });
  });

  describe('#_updateIsEditableFlagForConfig', function () {
    Em.A([
        {
          isAdmin: false,
          isReconfigurable: false,
          isHostsConfigsPage: true,
          defaultGroupSelected: false,
          m: 'false for non-admin users',
          e: false
        },
        {
          isAdmin: true,
          isReconfigurable: false,
          isHostsConfigsPage: true,
          defaultGroupSelected: false,
          m: 'false if defaultGroupSelected is false and isHostsConfigsPage is true',
          e: false
        },
        {
          isAdmin: true,
          isReconfigurable: false,
          isHostsConfigsPage: true,
          defaultGroupSelected: true,
          m: 'false if defaultGroupSelected is true and isHostsConfigsPage is true',
          e: false
        },
        {
          isAdmin: true,
          isReconfigurable: false,
          isHostsConfigsPage: false,
          defaultGroupSelected: false,
          m: 'false if defaultGroupSelected is false and isHostsConfigsPage is false',
          e: false
        },
        {
          isAdmin: true,
          isReconfigurable: true,
          isHostsConfigsPage: false,
          defaultGroupSelected: true,
          m: 'equal to isReconfigurable if defaultGroupSelected is true and isHostsConfigsPage is false',
          e: true
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          sinon.stub(App, 'get', function (k) {
            if (k === 'isAdmin') return test.isAdmin;
            return Em.get(App, k);
          });
          installerStep7Controller.reopen({isHostsConfigsPage: test.isHostsConfigsPage});
          var serviceConfigProperty = Em.Object.create({
            isReconfigurable: test.isReconfigurable
          });
          installerStep7Controller._updateIsEditableFlagForConfig(serviceConfigProperty, test.defaultGroupSelected);
          App.get.restore();
          expect(serviceConfigProperty.get('isEditable')).to.equal(test.e);
        });
      });
  });

  describe('#_updateOverridesForConfig', function () {

    it('should set empty array', function () {
      var serviceConfigProperty = Em.Object.create({
        overrides: null
      }), component = Em.Object.create();
      installerStep7Controller._updateOverridesForConfig(serviceConfigProperty, component);
      expect(serviceConfigProperty.get('overrides')).to.eql(Em.A([]));
    });

    it('host overrides not supported', function () {
      var serviceConfigProperty = Em.Object.create({
        overrides: [
          {value: 'new value'}
        ]
      }), component = Em.Object.create({selectedConfigGroup: {isDefault: false}});
      installerStep7Controller._updateOverridesForConfig(serviceConfigProperty, component);
      expect(serviceConfigProperty.get('overrides').length).to.equal(1);
      expect(serviceConfigProperty.get('overrides.firstObject.value')).to.equal('new value');
      expect(serviceConfigProperty.get('overrides.firstObject.isOriginalSCP')).to.equal(false);
      expect(serviceConfigProperty.get('overrides.firstObject.parentSCP')).to.eql(serviceConfigProperty);
    });

    it('host overrides supported', function () {
      sinon.stub(App, 'get', function (k) {
        if (k === 'supports.hostOverrides') return true;
        return Em.get(App, k);
      });
      var serviceConfigProperty = Em.Object.create({
          overrides: [
            {value: 'new value', group: Em.Object.create({name: 'n1'})}
          ]
        }),
        component = Em.Object.create({
          selectedConfigGroup: {isDefault: true},
          configGroups: Em.A([
            Em.Object.create({name: 'n1', properties: []})
          ])
        });
      installerStep7Controller._updateOverridesForConfig(serviceConfigProperty, component);
      App.get.restore();
      expect(serviceConfigProperty.get('overrides').length).to.equal(1);
      expect(serviceConfigProperty.get('overrides.firstObject.value')).to.equal('new value');
      expect(serviceConfigProperty.get('overrides.firstObject.isOriginalSCP')).to.equal(false);
      expect(serviceConfigProperty.get('overrides.firstObject.parentSCP')).to.eql(serviceConfigProperty);
      expect(component.get('configGroups.firstObject.properties').length).to.equal(1);
      expect(component.get('configGroups.firstObject.properties.firstObject.isEditable')).to.equal(false);
      expect(component.get('configGroups.firstObject.properties.firstObject.group')).to.be.object;
    });

  });

  describe('#_updateValidatorsForConfig', function () {

    it('should set isVisible to false', function () {
      var serviceConfigProperty = Em.Object.create({serviceName: 's1', isVisible: true}),
        component = Em.Object.create({serviceName: 's2'}),
        serviceConfigsData = {};
      installerStep7Controller._updateValidatorsForConfig(serviceConfigProperty, component, serviceConfigsData);
      expect(serviceConfigProperty.get('isVisible')).to.equal(false);
    });

    it('should set serviceValidator', function () {
      var serviceConfigProperty = Em.Object.create({serviceName: 's1', name: 'n1', serviceValidator: null}),
        component = Em.Object.create({serviceName: 's1'}),
        serviceConfigsData = {
          configsValidator: Em.Object.create({
            configValidators: {
              n1: {},
              n2: {}
            }
          })
        };
      installerStep7Controller._updateValidatorsForConfig(serviceConfigProperty, component, serviceConfigsData);
      expect(serviceConfigProperty.get('serviceValidator')).to.be.object;
      expect(Em.keys(serviceConfigProperty.get('serviceValidator.configValidators'))).to.eql(['n1', 'n2']);
    });

  });

  describe('#getRecommendedDefaultsForComponent', function () {
    beforeEach(function () {
      sinon.stub(App.router, 'get', function (k) {
        if (k === 'mainServiceInfoConfigsController') return Em.Object.create({
          getInfoForDefaults: Em.K
        });
        return Em.get(App.router, k);
      });
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it('should return empty object', function () {
      var serviceConfigsData = [
          {serviceName: 's1'}
        ],
        serviceName = 's1';
      installerStep7Controller.reopen({serviceConfigsData: serviceConfigsData});
      var r = installerStep7Controller._getRecommendedDefaultsForComponent(serviceName);
      expect(r).to.eql({});
    });

    it('should return recommendedDefaults', function () {
      var serviceConfigsData = [
          {serviceName: 's1', defaultsProviders: [
            {getDefaults: function () {
              return {c1: 'v1', c2: 'v2'};
            }},
            {getDefaults: function () {
              return {c3: 'v3', c4: 'v4'};
            }}
          ]}
        ],
        serviceName = 's1';
      installerStep7Controller.reopen({serviceConfigsData: serviceConfigsData});
      var r = installerStep7Controller._getRecommendedDefaultsForComponent(serviceName);
      expect(r).to.eql({c1: 'v1', c2: 'v2', c3: 'v3', c4: 'v4'});
    });

  });

  describe('#loadComponentConfigs', function () {

    beforeEach(function () {
      sinon.stub(installerStep7Controller, '_updateValidatorsForConfig', Em.K);
      sinon.stub(installerStep7Controller, '_updateOverridesForConfig', Em.K);
      sinon.stub(installerStep7Controller, '_updateIsEditableFlagForConfig', Em.K);
    });

    afterEach(function () {
      installerStep7Controller._updateIsEditableFlagForConfig.restore();
      installerStep7Controller._updateOverridesForConfig.restore();
      installerStep7Controller._updateValidatorsForConfig.restore();
    });

    it('should set recommended defaults', function () {
      var configs = [],
        serviceConfigsData = [
          {serviceName: 's1', configsValidator: Em.Object.create({recommendedDefaults: {}})}
        ],
        component = Em.Object.create({serviceName: 's1'}),
        componentConfig = {},
        recommendedDefaults = {c1: 'v1', c2: 'v2'};
      installerStep7Controller.reopen({serviceConfigsData: serviceConfigsData});
      sinon.stub(installerStep7Controller, '_getRecommendedDefaultsForComponent', function () {
        return recommendedDefaults;
      });
      installerStep7Controller.loadComponentConfigs(configs, componentConfig, component);
      installerStep7Controller._getRecommendedDefaultsForComponent.restore();
      expect(installerStep7Controller.get('serviceConfigsData.firstObject.configsValidator.recommendedDefaults')).to.eql(recommendedDefaults);
    });

    it('should skip null configs', function () {
      var configs = [null, null, null],
        serviceConfigsData = [
          {serviceName: 's1'}
        ],
        component = Em.Object.create({serviceName: 's1'}),
        componentConfig = Em.Object.create({configs: []});
      installerStep7Controller.reopen({serviceConfigsData: serviceConfigsData});
      installerStep7Controller.loadComponentConfigs(configs, componentConfig, component);
      expect(componentConfig.get('configs.length')).to.equal(0);
    });

    it('should update isOverridable flag', function () {
      var configs = [Em.Object.create({validate: Em.K}), Em.Object.create({validate: Em.K})],
        componentConfig = Em.Object.create({configs: []}),
        serviceConfigsData = [
          {serviceName: 's1'}
        ],
        component = Em.Object.create({serviceName: 's1'});
      installerStep7Controller.reopen({serviceConfigsData: serviceConfigsData});
      installerStep7Controller.loadComponentConfigs(configs, componentConfig, component);
      expect(componentConfig.get('configs').getEach('isOverridable')).to.eql([true, true]);
    });

    it('should update value for checkboxes', function () {
      var configs = [
          Em.Object.create({displayType: 'checkbox', value: 'true', validate: Em.K}),
          Em.Object.create({displayType: 'checkbox', value: 'false', validate: Em.K})
        ],
        componentConfig = Em.Object.create({configs: []}),
        serviceConfigsData = [
          {serviceName: 's1'}
        ],
        component = Em.Object.create({serviceName: 's1'});
      installerStep7Controller.reopen({serviceConfigsData: serviceConfigsData});
      installerStep7Controller.loadComponentConfigs(configs, componentConfig, component);
      expect(componentConfig.get('configs').getEach('value')).to.eql([true, false]);
      expect(componentConfig.get('configs').getEach('defaultValue')).to.eql([true, false]);
    });

  });

  describe('#_createSiteToTagMap', function () {
    it('should map sites', function () {
      var desired_configs = {
          s1: {tag: 't1'},
          s2: {tag: 't1'},
          s3: {tag: 't3'},
          s4: {tag: 't1'},
          s5: {tag: 't2'}
        },
        sites = ['s1', 's2', 's3'],
        expected = {s1: 't1', s2: 't1', s3: 't3'};
      var r = installerStep7Controller._createSiteToTagMap(desired_configs, sites);
      expect(r).to.eql(expected);
    });
  });

});
});

;require.register("test/controllers/wizard/step8_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/ajax/ajax_queue');
require('controllers/main/admin/security');
require('controllers/main/service/info/configs');
require('controllers/wizard/step8_controller');
var installerStep8Controller, configurationController;

describe('App.WizardStep8Controller', function () {

  var configs = Em.A([
    Em.Object.create({filename: 'hdfs-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'hdfs-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'hue-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'hue-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'mapred-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'mapred-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'yarn-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'yarn-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'capacity-scheduler.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'capacity-scheduler.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'mapred-queue-acls.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'mapred-queue-acls.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'hbase-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'hbase-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'oozie-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'oozie-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'hive-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'hive-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'pig-properties.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'webhcat-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'webhcat-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'tez-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'tez-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'falcon-startup.properties.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'falcon-startup.properties.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'falcon-runtime.properties.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'falcon-runtime.properties.xml', name: 'p2', value: 'v2'})
  ]);

  beforeEach(function () {
    installerStep8Controller = App.WizardStep8Controller.create({
      configs: configs
    });
    configurationController = App.MainServiceInfoConfigsController.create({});
  });

  var siteObjTests = Em.A([
    {name: 'createHdfsSiteObj', e: {type: 'hdfs-site', tag: 'version1', l: 2}},
    {name: 'createHueSiteObj', e: {type: 'hue-site', tag: 'version1', l: 2}},
    {name: 'createMrSiteObj', e: {type: 'mapred-site', tag: 'version1', l: 2}},
    {name: 'createYarnSiteObj', e: {type: 'yarn-site', tag: 'version1', l: 2}},
    {name: 'createCapacityScheduler', e: {type: 'capacity-scheduler', tag: 'version1', l: 2}},
    {name: 'createMapredQueueAcls', e: {type: 'mapred-queue-acls', tag: 'version1', l: 2}},
    {name: 'createHbaseSiteObj', e: {type: 'hbase-site', tag: 'version1', l: 2}},
    {name: 'createOozieSiteObj', e: {type: 'oozie-site', tag: 'version1', l: 2}},
    {name: 'createHiveSiteObj', e: {type: 'hive-site', tag: 'version1', l: 2}},
    {name: 'createWebHCatSiteObj', e: {type: 'webhcat-site', tag: 'version1', l: 2}},
    {name: 'createTezSiteObj', e: {type: 'tez-site', tag: 'version1', l: 2}},
    {name: 'createPigPropertiesSiteObj', e: {type: 'pig-properties', tag: 'version1', l: 1}},
    {name: 'createFalconStartupSiteObj', e: {type: 'falcon-startup.properties', tag: 'version1', l: 2}},
    {name: 'createFalconRuntimeSiteObj', e: {type: 'falcon-runtime.properties', tag: 'version1', l: 2}}
  ]);

  siteObjTests.forEach(function (test) {
    describe('#' + test.name, function () {

      it(test.name, function () {

        var siteObj = installerStep8Controller.createSiteObj(test.e.type);
        expect(siteObj.tag).to.equal(test.e.tag);
        expect(Em.keys(siteObj.properties).length).to.equal(test.e.l);
      });

    });
  });

  describe('#createConfigurations', function () {

    it('verify if its installerController', function () {
      installerStep8Controller.set('content', {controllerName: 'installerController', services: Em.A([])});
      installerStep8Controller.createConfigurations();
      expect(installerStep8Controller.get('serviceConfigTags').length).to.equal(4);
      installerStep8Controller.clearStep();
    });

    it('verify if its not installerController', function () {
      installerStep8Controller.set('content', {controllerName: 'addServiceController', services: Em.A([])});
      installerStep8Controller.createConfigurations();
      expect(installerStep8Controller.get('serviceConfigTags').length).to.equal(2);
      installerStep8Controller.clearStep();
    });

    it('verify not App.supports.capacitySchedulerUi', function () {
      installerStep8Controller = App.WizardStep8Controller.create({
        content: {controllerName: 'addServiceController', services: Em.A([
          {isSelected: true, isInstalled: false, serviceName: 'MAPREDUCE'}
        ])},
        configs: configs
      });
      App.set('supports.capacitySchedulerUi', false);
      installerStep8Controller.createConfigurations();
      expect(installerStep8Controller.get('serviceConfigTags').length).to.equal(4);
      installerStep8Controller.clearStep();
    });

    it('verify App.supports.capacitySchedulerUi', function () {
      installerStep8Controller = App.WizardStep8Controller.create({
        content: {controllerName: 'addServiceController', services: Em.A([
          {isSelected: true, isInstalled: false, serviceName: 'MAPREDUCE'}
        ])},
        configs: configs
      });
      App.set('supports.capacitySchedulerUi', true);
      installerStep8Controller.createConfigurations();
      expect(installerStep8Controller.get('serviceConfigTags').length).to.equal(6);
      installerStep8Controller.clearStep();
    });


    // e - without global and core!
    var tests = Em.A([
      {selectedServices: Em.A(['MAPREDUCE2']), e: 2},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN']), e: 5},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE']), e: 7},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE']), e: 9},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE']), e: 12},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'WEBHCAT']), e: 13},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'WEBHCAT', 'HUE']), e: 14},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'WEBHCAT', 'HUE', 'PIG']), e: 16},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'WEBHCAT', 'HUE', 'PIG', 'FALCON']), e: 18},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'WEBHCAT', 'HUE', 'PIG', 'FALCON', 'STORM']), e: 19},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'WEBHCAT', 'HUE', 'PIG', 'FALCON', 'STORM', 'TEZ']), e: 20},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'WEBHCAT', 'HUE', 'PIG', 'FALCON', 'STORM', 'TEZ', 'ZOOKEEPER']), e: 22}

    ]);

    tests.forEach(function (test) {
      it(test.selectedServices.join(','), function () {
        var services = test.selectedServices.map(function (serviceName) {
          return Em.Object.create({isSelected: true, isInstalled: false, serviceName: serviceName});
        });
        installerStep8Controller = App.WizardStep8Controller.create({
          content: {controllerName: 'addServiceController', services: services},
          configs: configs
        });
        installerStep8Controller.createConfigurations();
        expect(installerStep8Controller.get('serviceConfigTags').length).to.equal(test.e + 2);
        installerStep8Controller.clearStep();
      });
    });

    // Verify xml character escaping is not done for log4j files and falcon startup-properties and runtime-properties files.
    it('escape xml character for installer wizard', function () {
      var services = Em.A([Em.Object.create({isSelected: true, isInstalled: false, serviceName: 'OOZIE'}),
        Em.Object.create({isSelected: true, isInstalled: false, serviceName: 'FALCON'})]);

      var nonXmlConfigs = [
        {filename: 'oozie-log4j.xml', name: 'p1', value: "'.'v1"},
        {filename: 'falcon-startup.properties.xml', name: 'p1', value: "'.'v1"} ,
        {filename: 'falcon-startup.properties.xml', name: 'p2', value: 'v2'},
        {filename: 'falcon-runtime.properties.xml', name: 'p1', value: "'.'v1"},
        {filename: 'falcon-runtime.properties.xml', name: 'p2', value: 'v2'}
      ];
      installerStep8Controller = App.WizardStep8Controller.create({
        content: {controllerName: 'installerController', services: services},
        configs: nonXmlConfigs
      });
      installerStep8Controller.createConfigurations();
      var nonXmlConfigTypes = ['oozie-log4j', 'falcon-startup.properties', 'falcon-runtime.properties'];
      nonXmlConfigTypes.forEach(function (_nonXmlConfigType) {
        var nonXmlConfigTypeObj = installerStep8Controller.get('serviceConfigTags').findProperty('type', _nonXmlConfigType);
        var nonXmlSitePropertyVal = nonXmlConfigTypeObj.properties['p1'];
        expect(nonXmlSitePropertyVal).to.equal("'.'v1");
      });
      installerStep8Controller.clearStep();
    });

  });

  describe('#createSelectedServicesData', function () {

    var tests = Em.A([
      {selectedServices: Em.A(['MAPREDUCE2']), e: 2},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN']), e: 5},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE']), e: 7},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE']), e: 9},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE']), e: 12},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'WEBHCAT']), e: 13},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'WEBHCAT', 'HUE']), e: 14},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'WEBHCAT', 'HUE', 'PIG']), e: 15},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'WEBHCAT', 'HUE', 'PIG', 'FALCON']), e: 17},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'WEBHCAT', 'HUE', 'PIG', 'FALCON', 'STORM']), e: 18},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'WEBHCAT', 'HUE', 'PIG', 'FALCON', 'STORM', 'TEZ']), e: 19},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'WEBHCAT', 'HUE', 'PIG', 'FALCON', 'STORM', 'TEZ', 'ZOOKEEPER']), e: 21}
    ]);

    tests.forEach(function (test) {
      it(test.selectedServices.join(','), function () {
        var services = test.selectedServices.map(function (serviceName) {
          return Em.Object.create({isSelected: true, isInstalled: false, serviceName: serviceName});
        });
        installerStep8Controller = App.WizardStep8Controller.create({
          content: {controllerName: 'addServiceController', services: services},
          configs: configs
        });
        var serviceData = installerStep8Controller.createSelectedServicesData();
        expect(serviceData.mapProperty('ServiceInfo.service_name')).to.eql(test.selectedServices.toArray());
        installerStep8Controller.clearStep();
      });
    });

  });

  describe('#getRegisteredHosts', function () {

    var tests = Em.A([
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1'}),
          h2: Em.Object.create({bootStatus: 'OTHER', name: 'h2'})
        },
        e: ['h1'],
        m: 'Two hosts, one registered'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'OTHER', name: 'h1'}),
          h2: Em.Object.create({bootStatus: 'OTHER', name: 'h2'})
        },
        e: [],
        m: 'Two hosts, zero registered'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1'}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2'})
        },
        e: ['h1', 'h2'],
        m: 'Two hosts, two registered'
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        installerStep8Controller.set('content', Em.Object.create({hosts: test.hosts}));
        var registeredHosts = installerStep8Controller.getRegisteredHosts();
        expect(registeredHosts.mapProperty('hostName').toArray()).to.eql(test.e);
      });
    });

  });

  describe('#createRegisterHostData', function () {

    var tests = Em.A([
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1', isInstalled: false}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: false})
        },
        e: ['h1', 'h2'],
        m: 'two registered, two isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'OTHER', name: 'h1', isInstalled: false}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: false})
        },
        e: ['h2'],
        m: 'one registered, two isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'OTHER', name: 'h1', isInstalled: true}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: false})
        },
        e: ['h2'],
        m: 'one registered, one isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1', isInstalled: true}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: false})
        },
        e: ['h2'],
        m: 'two registered, one isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'OTHER', name: 'h1', isInstalled: false}),
          h2: Em.Object.create({bootStatus: 'OTHER', name: 'h2', isInstalled: false})
        },
        e: [],
        m: 'zero registered, two isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1', isInstalled: true}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: true})
        },
        e: [],
        m: 'two registered, zeto insInstalled false'
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        installerStep8Controller.set('content', Em.Object.create({hosts: test.hosts}));
        var registeredHostData = installerStep8Controller.createRegisterHostData();
        expect(registeredHostData.mapProperty('Hosts.host_name').toArray()).to.eql(test.e);
      });
    });

  });

  describe('#clusterName', function () {
    it('should be equal to content.cluster.name', function () {
      installerStep8Controller.set('content', {cluster: {name: 'new_name'}});
      expect(installerStep8Controller.get('clusterName')).to.equal('new_name');
    });
  });

  describe('#loadStep', function () {
    beforeEach(function () {
      sinon.stub(installerStep8Controller, 'clearStep', Em.K);
      sinon.stub(installerStep8Controller, 'formatProperties', Em.K);
      sinon.stub(installerStep8Controller, 'loadGlobals', Em.K);
      sinon.stub(installerStep8Controller, 'loadConfigs', Em.K);
      sinon.stub(installerStep8Controller, 'loadClusterInfo', Em.K);
      sinon.stub(installerStep8Controller, 'loadServices', Em.K);
      installerStep8Controller.set('content', {controllerName: 'installerController'});
    });
    afterEach(function () {
      installerStep8Controller.clearStep.restore();
      installerStep8Controller.formatProperties.restore();
      installerStep8Controller.loadGlobals.restore();
      installerStep8Controller.loadConfigs.restore();
      installerStep8Controller.loadClusterInfo.restore();
      installerStep8Controller.loadServices.restore();
    });
    it('should call clearStep', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.clearStep.calledOnce).to.equal(true);
    });
    it('should call loadClusterInfo', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.loadClusterInfo.calledOnce).to.equal(true);
    });
    it('should call loadServices', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.loadServices.calledOnce).to.equal(true);
    });
    it('should call formatProperties if content.serviceConfigProperties is true', function () {
      installerStep8Controller.set('content.serviceConfigProperties', true);
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.loadServices.calledOnce).to.equal(true);
    });
    it('should call loadGlobals if content.serviceConfigProperties is true', function () {
      installerStep8Controller.set('content.serviceConfigProperties', true);
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.loadGlobals.calledOnce).to.equal(true);
    });
    it('should call loadConfigs if content.serviceConfigProperties is true', function () {
      installerStep8Controller.set('content.serviceConfigProperties', true);
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.loadConfigs.calledOnce).to.equal(true);
    });
    it('should set isSubmitDisabled to false', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.get('isSubmitDisabled')).to.equal(false);
    });
    it('should set isBackBtnDisabled to false', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.get('isBackBtnDisabled')).to.equal(false);
    });
    it('should call setSecurityStatus for non-installerController', function () {
      var obj = Em.Object.create({
        setSecurityStatus: Em.K
      });
      sinon.stub(App.router, 'get', function () {
        return obj;
      });
      sinon.spy(obj, 'setSecurityStatus');
      installerStep8Controller.set('content.controllerName', 'addServiceController');
      installerStep8Controller.loadStep();
      expect(obj.setSecurityStatus.calledOnce).to.equal(true);
      obj.setSecurityStatus.restore();
      App.router.get.restore();

    });
  });

  describe('#loadGlobals', function () {
    beforeEach(function () {
      sinon.stub(installerStep8Controller, 'removeHiveConfigs', function (o) {
        return o;
      });
      sinon.stub(installerStep8Controller, 'removeOozieConfigs', function (o) {
        return o;
      });
    });
    afterEach(function () {
      installerStep8Controller.removeHiveConfigs.restore();
      installerStep8Controller.removeOozieConfigs.restore();
    });
    Em.A([
        {
          configs: [],
          m: 'empty configs, removeHiveConfigs isn\'t called, removeOozieConfigs ins\'t called',
          e: {
            globals: [],
            removeHiveConfigs: false,
            removeOozieConfigs: false
          }
        },
        {
          configs: [
            Em.Object.create({id: 'puppet var', name: 'n1'})
          ],
          m: 'not empty configs, removeHiveConfigs isn\'t called, removeOozieConfigs ins\'t called',
          e: {
            globals: ['n1'],
            removeHiveConfigs: false,
            removeOozieConfigs: false
          }
        },
        {
          configs: [
            Em.Object.create({id: 'puppet var', name: 'n1'}),
            Em.Object.create({id: 'puppet var', name: 'hive_database'})
          ],
          m: 'not empty configs, removeHiveConfigs called, removeOozieConfigs ins\'t called',
          e: {
            globals: ['n1', 'hive_database'],
            removeHiveConfigs: true,
            removeOozieConfigs: false
          }
        },
        {
          configs: [
            Em.Object.create({id: 'puppet var', name: 'n1'}),
            Em.Object.create({id: 'puppet var', name: 'oozie_database'})
          ],
          m: 'not empty configs, removeHiveConfigs isn\'t called, removeOozieConfigs called',
          e: {
            globals: ['n1', 'oozie_database'],
            removeHiveConfigs: false,
            removeOozieConfigs: true
          }
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          installerStep8Controller.set('content', {serviceConfigProperties: test.configs});
          installerStep8Controller.loadGlobals();
          if (test.e.removeHiveConfigs) {
            expect(installerStep8Controller.removeHiveConfigs.calledOnce).to.equal(true);
          }
          else {
            expect(installerStep8Controller.removeHiveConfigs.called).to.equal(false);
          }
          if (test.e.removeOozieConfigs) {
            expect(installerStep8Controller.removeOozieConfigs.calledOnce).to.equal(true);
          }
          else {
            expect(installerStep8Controller.removeOozieConfigs.called).to.equal(false);
          }
          expect(installerStep8Controller.get('globals').mapProperty('name')).to.eql(test.e.globals);
        });
      });
  });

  describe('#removeHiveConfigs', function () {
    Em.A([
        {
          globals: [
            {name: 'hive_database', value: 'New MySQL Database'},
            {name: 'hive_ambari_host', value: 'h1'},
            {name: 'hive_hostname', value: 'h2'}
          ],
          removed: Em.A(['hive_existing_mysql_host', 'hive_existing_mysql_database', 'hive_existing_oracle_host',
            'hive_existing_oracle_database', 'hive_existing_postgresql_host', 'hive_existing_postgresql_database']),
          hive_database_type: 'mysql',
          m: 'hive_database: New MySQL Database',
          host: 'h1'
        },
        {
          globals: [
            {name: 'hive_database', value: 'Existing MySQL Database'},
            {name: 'hive_existing_mysql_host', value: 'h1'},
            {name: 'hive_hostname', value: 'h2'}
          ],
          removed: Em.A(['hive_ambari_host', 'hive_ambari_database', 'hive_existing_oracle_host',
            'hive_existing_oracle_database', 'hive_existing_postgresql_host', 'hive_existing_postgresql_database']),
          hive_database_type: 'mysql',
          m: 'hive_database: Existing MySQL Database',
          host: 'h1'
        },
        {
          globals: [
            {name: 'hive_database', value: 'Existing PostgreSQL Database'},
            {name: 'hive_existing_postgresql_host', value: 'h1'},
            {name: 'hive_hostname', value: 'h2'}
          ],
          removed: Em.A(['hive_ambari_host', 'hive_ambari_database', 'hive_existing_oracle_host',
            'hive_existing_oracle_database', 'hive_existing_mysql_host', 'hive_existing_mysql_database']),
          hive_database_type: 'postgres',
          m: 'hive_database: Existing PostgreSQL Database',
          host: 'h1'
        },
        {
          globals: [
            {name: 'hive_database', value: 'Existing Oracle Database'},
            {name: 'hive_existing_oracle_host', value: 'h1'},
            {name: 'hive_hostname', value: 'h2'}
          ],
          removed: Em.A(['hive_ambari_host', 'hive_ambari_database', 'hive_existing_mysql_host',
            'hive_existing_mysql_database', 'hive_existing_postgresql_host', 'hive_existing_postgresql_database']),
          hive_database_type: 'oracle',
          m: 'hive_database: Existing Oracle Database',
          host: 'h1'
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          test.removed.forEach(function (c) {
            test.globals.pushObject({name: c})
          });
          var configs = installerStep8Controller.removeHiveConfigs(test.globals);
          test.removed.forEach(function(name) {
            expect(Em.isNone(configs.findProperty('name', name))).to.equal(true);
          });
          expect(configs.findProperty('name', 'hive_database_type').value).to.equal(test.hive_database_type);
          expect(configs.findProperty('name', 'hive_hostname').value).to.equal(test.host);
        });
      });
  });

  describe('#removeOozieConfigs', function () {
    Em.A([
        {
          globals: [
            {name: 'oozie_database', value: 'New Derby Database'},
            {name: 'oozie_ambari_host', value: 'h1'},
            {name: 'oozie_hostname', value: 'h2'}
          ],
          removed: Em.A(['oozie_ambari_host', 'oozie_ambari_database', 'oozie_existing_mysql_host',
            'oozie_existing_mysql_database', 'oozie_existing_oracle_host', 'oozie_existing_oracle_database',
            'oozie_existing_postgresql_host', 'oozie_existing_postgresql_database']),
          oozie_database_type: 'derby',
          m: 'oozie_database: New Derby Database',
          host: 'h1'
        },
        {
          globals: [
            {name: 'oozie_database', value: 'Existing MySQL Database'},
            {name: 'oozie_existing_mysql_host', value: 'h1'},
            {name: 'oozie_hostname', value: 'h2'}
          ],
          removed: Em.A(['oozie_ambari_host', 'oozie_ambari_database', 'oozie_existing_oracle_host',
            'oozie_existing_oracle_database', 'oozie_derby_database', 'oozie_existing_postgresql_host', 'oozie_existing_postgresql_database']),
          oozie_database_type: 'mysql',
          m: 'oozie_database: Existing MySQL Database',
          host: 'h1'
        },
        {
          globals: [
            {name: 'oozie_database', value: 'Existing PostgreSQL Database'},
            {name: 'oozie_existing_postgresql_host', value: 'h1'},
            {name: 'oozie_hostname', value: 'h2'}
          ],
          removed: Em.A(['oozie_ambari_host', 'oozie_ambari_database', 'oozie_existing_oracle_host',
            'oozie_existing_oracle_database', 'oozie_existing_mysql_host', 'oozie_existing_mysql_database']),
          oozie_database_type: 'postgresql',
          m: 'oozie_database: Existing PostgreSQL Database',
          host: 'h1'
        },
        {
          globals: [
            {name: 'oozie_database', value: 'Existing Oracle Database'},
            {name: 'oozie_existing_oracle_host', value: 'h1'},
            {name: 'oozie_hostname', value: 'h2'}
          ],
          removed: Em.A(['oozie_ambari_host', 'oozie_ambari_database', 'oozie_existing_mysql_host',
            'oozie_existing_mysql_database', 'oozie_derby_database', 'oozie_existing_postgresql_host', 'oozie_existing_postgresql_database']),
          oozie_database_type: 'oracle',
          m: 'oozie_database: Existing Oracle Database',
          host: 'h1'
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          test.removed.forEach(function (c) {
            if (!test.globals.findProperty('name', c)) {
              test.globals.pushObject({name: c})
            }
          });
          var configs = installerStep8Controller.removeOozieConfigs(test.globals);
          test.removed.forEach(function(name) {
            expect(Em.isNone(configs.findProperty('name', name))).to.equal(true);
          });
          expect(configs.findProperty('name', 'oozie_database_type').value).to.equal(test.oozie_database_type);
          expect(configs.findProperty('name', 'oozie_hostname').value).to.equal(test.host);
        });
      });
  });

  describe('#getRegisteredHosts', function() {
    Em.A([
        {
          hosts: {},
          m: 'no content.hosts',
          e: []
        },
        {
          hosts: {
            h1:{bootStatus: ''},
            h2:{bootStatus: ''}
          },
          m: 'no registered hosts',
          e: []
        },
        {
          hosts: {
            h1:{bootStatus: 'REGISTERED', hostName: '', name: 'n1'},
            h2:{bootStatus: 'REGISTERED', hostName: '', name: 'n2'}
          },
          m: 'registered hosts available',
          e: ['n1', 'n2']
        }
      ]).forEach(function(test) {
        it(test.m, function() {
          installerStep8Controller.set('content', {hosts: test.hosts});
          var hosts = installerStep8Controller.getRegisteredHosts();
          expect(hosts.mapProperty('hostName')).to.eql(test.e);
        });
    });
  });

  describe('#loadRepoInfo', function() {
    it('should use App.currentStackVersion', function() {
      var version = 'HDP-1.1.1';
      sinon.stub(App, 'get', function() {return version;});
      sinon.stub(App.ajax, 'send', Em.K);
      installerStep8Controller.loadRepoInfo();
      var data = App.ajax.send.args[0][0].data;
      expect(data).to.eql({stackName: 'HDP', stackVersion: '1.1.1'});
      App.ajax.send.restore();
      App.get.restore();
    });
  });

  describe('#loadRepoInfoSuccessCallback', function () {
    beforeEach(function () {
      installerStep8Controller.set('clusterInfo', Em.Object.create({}));
    });
    Em.A([
        {
          items: [],
          m: 'no data',
          e: {
            base_url: [],
            os_type: []
          }
        },
        {
          items: [
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'bulgenos',
                    base_url: 'url1'
                  }
                }
              ]
            }
          ],
          m: 'unsupported os',
          e: {
            base_url: [],
            os_type: []
          }
        },
        {
          items: [
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat5',
                    base_url: 'url1'
                  }
                }
              ]
            }
          ],
          m: 'only redhat5',
          e: {
            base_url: ['url1'],
            os_type: [Em.I18n.t("installer.step8.repoInfo.osType.redhat5")]
          }
        },
        {
          items: [
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat5',
                    base_url: 'url1'
                  }
                }
              ]
            },
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat6',
                    base_url: 'url2'
                  }
                }
              ]
            }
          ],
          m: 'redhat5, redhat6',
          e: {
            base_url: ['url1', 'url2'],
            os_type: [Em.I18n.t("installer.step8.repoInfo.osType.redhat5"), Em.I18n.t("installer.step8.repoInfo.osType.redhat6")]
          }
        },
        {
          items: [
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat5',
                    base_url: 'url1'
                  }
                }
              ]
            },
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat6',
                    base_url: 'url2'
                  }
                }
              ]
            },
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'sles11',
                    base_url: 'url3'
                  }
                }
              ]
            }
          ],
          m: 'redhat5, redhat6, sles11',
          e: {
            base_url: ['url1', 'url2', 'url3'],
            os_type: [Em.I18n.t("installer.step8.repoInfo.osType.redhat5"), Em.I18n.t("installer.step8.repoInfo.osType.redhat6"), Em.I18n.t("installer.step8.repoInfo.osType.sles11")]
          }
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          installerStep8Controller.loadRepoInfoSuccessCallback({items: test.items});
          expect(installerStep8Controller.get('clusterInfo.repoInfo').mapProperty('base_url')).to.eql(test.e.base_url);
          expect(installerStep8Controller.get('clusterInfo.repoInfo').mapProperty('os_type')).to.eql(test.e.os_type);
        });
      });
  });

  describe('#loadRepoInfoErrorCallback', function() {
    it('should set [] to repoInfo', function() {
      installerStep8Controller.set('clusterInfo', Em.Object.create({repoInfo: [{}, {}]}));
      installerStep8Controller.loadRepoInfoErrorCallback({});
      expect(installerStep8Controller.get('clusterInfo.repoInfo.length')).to.eql(0);
    });
  });

  describe('#loadHiveDbValue', function() {
    beforeEach(function() {
      installerStep8Controller.set('wizardController', Em.Object.create({
        getDBProperty: Em.K
      }));
    });
    Em.A([
        {
          serviceConfigProperties: [
            {name: 'hive_database', value: 'New MySQL Database'}
          ],
          m: 'New MySQL Database',
          e: 'MySQL (New Database)'
        },
        {
          serviceConfigProperties: [
            {name: 'hive_database', value: 'Existing MySQL Database'},
            {name: 'hive_existing_mysql_database', value: 'dbname'}
          ],
          m: 'Existing MySQL Database',
          e: 'dbname (Existing MySQL Database)'
        },
        {
          serviceConfigProperties: [
            {name: 'hive_database', value: 'Existing PostgreSQL Database'},
            {name: 'hive_existing_postgresql_database', value: 'dbname'}
          ],
          m: 'Existing PostgreSQL Database',
          e: 'dbname (Existing PostgreSQL Database)'
        },
        {
          serviceConfigProperties: [
            {name: 'hive_database', value: 'Existing Oracle Database'},
            {name: 'hive_existing_oracle_database', value: 'dbname'}
          ],
          m: 'Existing Oracle Database',
          e: 'dbname (Existing Oracle Database)'
        }
      ]).forEach(function(test) {
        it(test.m, function() {
          sinon.stub(installerStep8Controller.get('wizardController'), 'getDBProperty', function() {
            return test.serviceConfigProperties;
          });
          var dbComponent = Em.Object.create({});
          installerStep8Controller.loadHiveDbValue(dbComponent);
          expect(dbComponent.get('component_value')).to.equal(test.e);
          installerStep8Controller.get('wizardController').getDBProperty.restore();
        });
    });
  });

  describe('#loadHbaseMasterValue', function () {
    Em.A([
        {
          masterComponentHosts: [{component: 'HBASE_MASTER', hostName: 'h1'}],
          component: Em.Object.create({component_name: 'HBASE_MASTER'}),
          m: 'one host',
          e: 'h1'
        },
        {
          masterComponentHosts: [{component: 'HBASE_MASTER', hostName: 'h1'}, {component: 'HBASE_MASTER', hostName: 'h2'}, {component: 'HBASE_MASTER', hostName: 'h3'}],
          component: Em.Object.create({component_name: 'HBASE_MASTER'}),
          m: 'many hosts',
          e: 'h1 ' + Em.I18n.t('installer.step8.other').format(2)
        }
      ]).forEach(function (test) {
        it(test.m, function() {
          installerStep8Controller.set('content', {masterComponentHosts: test.masterComponentHosts});
          installerStep8Controller.loadHbaseMasterValue(test.component);
          expect(test.component.component_value).to.equal(test.e);
        });
      });
  });

  describe('#loadZkServerValue', function() {
    Em.A([
        {
          masterComponentHosts: [{component: 'ZOOKEEPER_SERVER'}],
          component: Em.Object.create({component_name: 'ZOOKEEPER_SERVER'}),
          m: '1 host',
          e: '1 host'
        },
        {
          masterComponentHosts: [{component: 'ZOOKEEPER_SERVER'},{component: 'ZOOKEEPER_SERVER'},{component: 'ZOOKEEPER_SERVER'}],
          component: Em.Object.create({component_name: 'ZOOKEEPER_SERVER'}),
          m: 'many hosts',
          e: '3 hosts'
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          installerStep8Controller.set('content', {masterComponentHosts: test.masterComponentHosts});
          installerStep8Controller.loadZkServerValue(test.component);
          expect(test.component.component_value).to.equal(test.e);
        });
      });
  });

  describe('#loadOozieDbValue', function() {
    beforeEach(function() {
      installerStep8Controller.set('wizardController', Em.Object.create({
        getDBProperty: Em.K
      }));
    });
    Em.A([
        {
          serviceConfigProperties: [
            {name: 'oozie_database', value: 'New Derby Database'},
            {name: 'oozie_derby_database', value: 'dbname'}
          ],
          m: 'New Derby Database',
          e: 'dbname (New Derby Database)'
        },
        {
          serviceConfigProperties: [
            {name: 'oozie_database', value: 'Existing MySQL Database'},
            {name: 'oozie_existing_mysql_database', value: 'dbname'}
          ],
          m: 'Existing MySQL Database',
          e: 'dbname (Existing MySQL Database)'
        },
        {
          serviceConfigProperties: [
            {name: 'oozie_database', value: 'Existing PostgreSQL Database'},
            {name: 'oozie_existing_postgresql_database', value: 'dbname'}
          ],
          m: 'Existing PostgreSQL Database',
          e: 'dbname (Existing PostgreSQL Database)'
        },
        {
          serviceConfigProperties: [
            {name: 'oozie_database', value: 'Existing Oracle Database'},
            {name: 'oozie_existing_oracle_database', value: 'dbname'}
          ],
          m: 'Existing Oracle Database',
          e: 'dbname (Existing Oracle Database)'
        }
      ]).forEach(function(test) {
        it(test.m, function() {
          sinon.stub(installerStep8Controller.get('wizardController'), 'getDBProperty', function() {
            return test.serviceConfigProperties;
          });
          var dbComponent = Em.Object.create({});
          installerStep8Controller.loadOozieDbValue(dbComponent);
          expect(dbComponent.get('component_value')).to.equal(test.e);
          installerStep8Controller.get('wizardController').getDBProperty.restore();
        });
      });
  });

  describe('#loadNagiosAdminValue', function() {
    it('should use serviceConfigProperties nagios_web_login and nagios_contact', function() {
      installerStep8Controller.set('content', {
        serviceConfigProperties: [
          {name: 'nagios_web_login', value: 'admin'},
          {name: 'nagios_contact', value: 'admin@admin.com'}
        ]
      });
      var nagiosAdmin = Em.Object.create({
        component_value: ''
      });
      installerStep8Controller.loadNagiosAdminValue(nagiosAdmin);
      expect(nagiosAdmin.get('component_value')).to.equal('admin / (admin@admin.com)');
    });
  });

  describe('#submit', function() {
    beforeEach(function() {
      sinon.stub(installerStep8Controller, 'submitProceed', Em.K);
      sinon.spy(App, 'showConfirmationPopup');
    });
    afterEach(function() {
      installerStep8Controller.submitProceed.restore();
      App.showConfirmationPopup.restore();
    });
    Em.A([
        {
          controllerName: 'addHostController',
          securityEnabled: true,
          e: true
        },
        {
          controllerName: 'addHostController',
          securityEnabled: false,
          e: false
        },
        {
          controllerName: 'addServiceController',
          securityEnabled: true,
          e: false
        },
        {
          controllerName: 'addServiceController',
          securityEnabled: false,
          e: false
        }
      ]).forEach(function (test) {
        it(test.controllerName + ' ' + test.securityEnabled.toString(), function () {
          installerStep8Controller.reopen({isSubmitDisabled: false, securityEnabled: test.securityEnabled, content: {controllerName: test.controllerName}});
          installerStep8Controller.submit();
          if (test.e) {
            expect(App.showConfirmationPopup.calledOnce).to.equal(true);
            expect(installerStep8Controller.submitProceed.called).to.equal(false);
          }
          else {
            expect(App.showConfirmationPopup.called).to.equal(false);
            expect(installerStep8Controller.submitProceed.calledOnce).to.equal(true);
          }
        });
      });
    it('should call submitProceed when Ok clicked', function() {
      installerStep8Controller.reopen({isSubmitDisabled: false, securityEnabled: true, content: {controllerName: 'addHostController'}});
      installerStep8Controller.submit().onPrimary();
      expect(installerStep8Controller.submitProceed.calledOnce).to.equal(true);
    });
    it('shouldn\'t do nothing if isSubmitDisabled is true', function() {
      installerStep8Controller.reopen({isSubmitDisabled: true});
      installerStep8Controller.submit();
      expect(App.showConfirmationPopup.called).to.equal(false);
      expect(installerStep8Controller.submitProceed.called).to.equal(false);
    });
  });

  describe('#getExistingClusterNamesSuccessCallBack', function() {
    it('should set clusterNames received from server', function() {
      var data = {
        items:[
          {Clusters: {cluster_name: 'c1'}},
          {Clusters: {cluster_name: 'c2'}},
          {Clusters: {cluster_name: 'c3'}}
        ]
      },
      clasterNames = ['c1','c2','c3'];
      installerStep8Controller.getExistingClusterNamesSuccessCallBack(data);
      expect(installerStep8Controller.get('clusterNames')).to.eql(clasterNames);
    });
  });

  describe('#getExistingClusterNamesErrorCallback', function() {
    it('should set [] to clusterNames', function() {
      installerStep8Controller.set('clusterNames', ['c1', 'c2']);
      installerStep8Controller.getExistingClusterNamesErrorCallback();
      expect(installerStep8Controller.get('clusterNames')).to.eql([]);
    });
  });

  describe('#deleteClusters', function() {
    it('should call App.ajax.send for each provided clusterName', function() {
      sinon.stub(App.ajax, 'send', Em.K);
      var clusterNames = ['h1', 'h2', 'h3'];
      installerStep8Controller.deleteClusters(clusterNames);
      expect(App.ajax.send.callCount).to.equal(clusterNames.length);
      clusterNames.forEach(function(n, i) {
        expect(App.ajax.send.getCall(i).args[0].data).to.eql({name: n});
      });
      App.ajax.send.restore();
    });
  });

  describe('#createSelectedServicesData', function() {
    it('should reformat provided data', function() {
      var selectedServices = [
        Em.Object.create({serviceName: 's1'}),
        Em.Object.create({serviceName: 's2'}),
        Em.Object.create({serviceName: 's3'})
      ];
      var expected = [
        {"ServiceInfo": { "service_name": 's1' }},
        {"ServiceInfo": { "service_name": 's2' }},
        {"ServiceInfo": { "service_name": 's3' }}
      ];
      installerStep8Controller.reopen({selectedServices: selectedServices});
      var createdData = installerStep8Controller.createSelectedServicesData();
      expect(createdData).to.eql(expected);
    });
  });

  describe('#createRegisterHostData', function() {
    it('should return empty data if no hosts', function() {
      sinon.stub(installerStep8Controller, 'getRegisteredHosts', function() {return [];});
      expect(installerStep8Controller.createRegisterHostData()).to.eql([]);
      installerStep8Controller.getRegisteredHosts.restore();
    });
    it('should return computed data', function() {
      var data = [
        {isInstalled: false, hostName: 'h1'},
        {isInstalled: true, hostName: 'h2'},
        {isInstalled: false, hostName: 'h3'}
      ];
      var expected = [
        {"Hosts": { "host_name": 'h1'}},
        {"Hosts": { "host_name": 'h3'}}
      ];
      sinon.stub(installerStep8Controller, 'getRegisteredHosts', function() {return data;});
      expect(installerStep8Controller.createRegisterHostData()).to.eql(expected);
      installerStep8Controller.getRegisteredHosts.restore();
    });
  });

  describe('#createZooCfgObj', function() {
    it('should affect zoo.cfg properties', function() {
      var configs = [
          {filename: 'zoo.cfg', value: 'a&amp;b', name: 'p1'},
          {filename: 'zoo.cfg', value: 'a&lt;b', name: 'p2'},
          {filename: 'zoo.cfg', value: 'a&gt;b', name: 'p3'},
          {filename: 'zoo.cfg', value: 'a&quot;b', name: 'p4'},
          {filename: 'zoo.cfg', value: 'a&apos;b', name: 'p5'}
        ],
        expected = {
          type: 'zoo.cfg',
          tag: 'version1',
          properties: {
            p1: 'a&b',
            p2: 'a<b',
            p3: 'a>b',
            p4: 'a"b',
            p5: 'a\'b'
          }
        };
      installerStep8Controller.reopen({configs: configs});
      expect(installerStep8Controller.createZooCfgObj()).to.eql(expected);
    });
  });

  describe('#createStormSiteObj', function() {
    it('should remove quotes for some properties', function() {
      var configs = [
          {filename: 'storm-site.xml', value: ["a", "b"], name: 'nimbus.childopts'},
          {filename: 'storm-site.xml', value: ["a", "b"], name: 'supervisor.childopts'},
          {filename: 'storm-site.xml', value: ["a", "b"], name: 'worker.childopts'}
        ],
        expected = {
          type: 'storm-site',
          tag: 'version1',
          properties: {
            'nimbus.childopts': '[a,b]',
            'supervisor.childopts': '[a,b]',
            'worker.childopts': '[a,b]'
          }
        };
      installerStep8Controller.reopen({configs: configs});
      expect(installerStep8Controller.createStormSiteObj()).to.eql(expected);
    });
    it('should replace quote \'"\' to "\'" for some properties', function() {
      var configs = [
          {filename: 'storm-site.xml', value: ["a", "b"], name: 'storm.zookeeper.servers'}
        ],
        expected = {
          type: 'storm-site',
          tag: 'version1',
          properties: {
            'storm.zookeeper.servers': '[\'a\',\'b\']'
          }
        };
      installerStep8Controller.reopen({configs: configs});
      expect(installerStep8Controller.createStormSiteObj()).to.eql(expected);
    });
    it('should affect storm-site.xml properties', function() {
      var configs = [
          {filename: 'storm-site.xml', value: 'a&amp;b', name: 'p1'},
          {filename: 'storm-site.xml', value: 'a&lt;b', name: 'p2'},
          {filename: 'storm-site.xml', value: 'a&gt;b', name: 'p3'},
          {filename: 'storm-site.xml', value: 'a&quot;b', name: 'p4'},
          {filename: 'storm-site.xml', value: 'a&apos;b', name: 'p5'}
        ],
        expected = {
          type: 'storm-site',
          tag: 'version1',
          properties: {
            p1: 'a&b',
            p2: 'a<b',
            p3: 'a>b',
            p4: 'a"b',
            p5: 'a\'b'
          }
        };
      installerStep8Controller.reopen({configs: configs});
      expect(installerStep8Controller.createStormSiteObj()).to.eql(expected);
    });
  });

  describe('#ajaxQueueFinished', function() {
    it('should call App.router.next', function() {
      sinon.stub(App.router, 'send', Em.K);
      installerStep8Controller.ajaxQueueFinished();
      expect(App.router.send.calledWith('next')).to.equal(true);
      App.router.send.restore();
    });
  });

  describe('#addRequestToAjaxQueue', function() {
    describe('testMode = true', function() {
      before(function() {
        App.set('testMode', true);
      });
      after(function() {
        App.set('testMode', false);
      });
      it('shouldn\'t do nothing', function() {
        installerStep8Controller.set('ajaxRequestsQueue', App.ajaxQueue.create());
        installerStep8Controller.get('ajaxRequestsQueue').clear();
        installerStep8Controller.addRequestToAjaxQueue({});
        expect(installerStep8Controller.get('ajaxRequestsQueue.queue.length')).to.equal(0);
      });
    });
    describe('testMode = true', function() {
      before(function() {
        App.set('testMode', false);
      });
      it('should add request', function() {
        var clusterName = 'c1';
        installerStep8Controller.reopen({clusterName: clusterName});
        installerStep8Controller.set('ajaxRequestsQueue', App.ajaxQueue.create());
        installerStep8Controller.get('ajaxRequestsQueue').clear();
        installerStep8Controller.addRequestToAjaxQueue({name:'name', data:{}});
        var request = installerStep8Controller.get('ajaxRequestsQueue.queue.firstObject');
        expect(request.error).to.equal('ajaxQueueRequestErrorCallback');
        expect(request.data.cluster).to.equal(clusterName);
      });
    });
  });

  describe('#ajaxQueueRequestErrorCallback', function() {
    var obj = Em.Object.create({
      registerErrPopup: Em.K,
      setStepsEnable: Em.K
    });
    beforeEach(function() {
      sinon.stub(App.router, 'get', function() {
        return obj;
      });
      sinon.spy(obj, 'registerErrPopup');
      sinon.spy(obj, 'setStepsEnable');
    });
    afterEach(function() {
      App.router.get.restore();
      obj.registerErrPopup.restore();
      obj.setStepsEnable.restore();
    });
    it('should set hasErrorOccurred true', function () {
      installerStep8Controller.set('hasErrorOccurred', false);
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(installerStep8Controller.get('hasErrorOccurred')).to.equal(true);
    });
    it('should set isSubmitDisabled false', function () {
      installerStep8Controller.set('isSubmitDisabled', true);
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(installerStep8Controller.get('isSubmitDisabled')).to.equal(false);
    });
    it('should set isBackBtnDisabled false', function () {
      installerStep8Controller.set('isBackBtnDisabled', true);
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(installerStep8Controller.get('isBackBtnDisabled')).to.equal(false);
    });
    it('should call setStepsEnable', function () {
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(obj.setStepsEnable.calledOnce).to.equal(true);
    });
    it('should call registerErrPopup', function () {
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(obj.registerErrPopup.calledOnce).to.equal(true);
    });
  });

  describe('#removeInstalledServicesConfigurationGroups', function() {
    beforeEach(function() {
      sinon.stub(App.config, 'deleteConfigGroup', Em.K);
    });
    afterEach(function() {
      App.config.deleteConfigGroup.restore();
    });
    it('should call App.config.deleteConfigGroup for each received group', function() {
      var groups = [{}, {}, {}];
      installerStep8Controller.removeInstalledServicesConfigurationGroups(groups);
      expect(App.config.deleteConfigGroup.callCount).to.equal(groups.length);
    });
  });

  describe('#assignComponentHosts', function() {
    it('component with custom handler', function() {
      var castom_value = 'custom',
        component = Em.Object.create({
        customHandler: 'customHandler'
      });
      installerStep8Controller.reopen({
        customHandler: function(o) {o.set('component_value', castom_value)}
      });
      installerStep8Controller.assignComponentHosts(component);
      expect(component.get('component_value')).to.equal(castom_value);
    });
    it('component is master', function() {
      var component = Em.Object.create({
          component_name: 'c1',
          isMaster: true
        }),
        masterComponentHosts = [
          {component: 'c1', hostName: 'h1'}
        ];
      installerStep8Controller.reopen({content: {masterComponentHosts: masterComponentHosts}});
      installerStep8Controller.assignComponentHosts(component);
      expect(component.get('component_value')).to.equal('h1');
    });
    it('component isn\'t master, 1 host', function() {
      var component = Em.Object.create({
          component_name: 'c1',
          isMaster: false
        }),
        slaveComponentHosts = [
          {componentName: 'c1', hosts: [{}]}
        ];
      installerStep8Controller.reopen({content: {slaveComponentHosts: slaveComponentHosts}});
      installerStep8Controller.assignComponentHosts(component);
      expect(component.get('component_value')).to.equal('1 host');
    });
    it('component isn\'t master, 2 hosts', function() {
      var component = Em.Object.create({
          component_name: 'c1',
          isMaster: false
        }),
        slaveComponentHosts = [
          {componentName: 'c1', hosts: [{}, {}]}
        ];
      installerStep8Controller.reopen({content: {slaveComponentHosts: slaveComponentHosts}});
      installerStep8Controller.assignComponentHosts(component);
      expect(component.get('component_value')).to.equal('2 hosts');
    });
  });

  describe('#addDynamicProperties', function() {
    it('shouldn\'t add property', function() {
      var serviceConfigProperties = [
          {name: 'templeton.hive.properties'}
        ],
        configs = [];
      installerStep8Controller.reopen({content: {serviceConfigProperties: serviceConfigProperties}});
      installerStep8Controller.addDynamicProperties(configs);
      expect(configs.length).to.equal(0);
    });
    it('should add property', function() {
      var serviceConfigProperties = [],
        configs = [];
      installerStep8Controller.reopen({content: {serviceConfigProperties: serviceConfigProperties}});
      installerStep8Controller.addDynamicProperties(configs);
      expect(configs.length).to.equal(1);
    });
  });

  describe('#formatProperties', function() {

  });

  describe('#updateConfigurations', function() {

    beforeEach(function() {
      sinon.stub(configurationController, 'doPUTClusterConfigurationSite', Em.K);
      sinon.stub(App.router, 'get', function() {
        return configurationController;
      });
    });

    afterEach(function() {
      configurationController.doPUTClusterConfigurationSite.restore();
      App.router.get.restore();
    });

    it('empty configsToUpdate', function() {
      installerStep8Controller.updateConfigurations([]);
      expect(configurationController.doPUTClusterConfigurationSite.called).to.be.false;
    });

    it('one service, no site properties', function() {
      var configsToUpdate = [
        {serviceName: 's1', id: ''},
        {serviceName: 's1', id: ''}
      ];
      installerStep8Controller.updateConfigurations(configsToUpdate);
      expect(configurationController.doPUTClusterConfigurationSite.called).to.be.false;
    });

    it('one service, site properties, 2 files', function() {
      var configsToUpdate = [
        {serviceName: 's1', id: 'site property', filename: 'f1.xml', name: 'n1', value: 'v1'},
        {serviceName: 's1', id: 'site property', filename: 'f2.xml', name: 'n2', value: 'v2'}
      ];
      installerStep8Controller.updateConfigurations(configsToUpdate);
      expect(configurationController.doPUTClusterConfigurationSite.calledTwice).to.be.true;
    });

    it('two services, site properties, 2 files', function() {
      var configsToUpdate = [
        {serviceName: 's1', id: 'site property', filename: 'f1.xml', name: 'n1', value: 'v1'},
        {serviceName: 's1', id: 'site property', filename: 'f1.xml', name: 'n12', value: 'v12'},
        {serviceName: 's1', id: 'site property', filename: 'f2.xml', name: 'n2', value: 'v2'},
        {serviceName: 's2', id: 'site property', filename: 'f2.xml', name: 'n3', value: 'v3'}
      ];
      installerStep8Controller.updateConfigurations(configsToUpdate);
      expect(configurationController.doPUTClusterConfigurationSite.calledThrice).to.be.true;
      var firstCallArgs = configurationController.doPUTClusterConfigurationSite.args[0][0];
      expect(firstCallArgs.type).to.equal('f1');
      expect(firstCallArgs.properties).to.eql({"n1":"v1","n12":"v12"});
      var secondCallArgs = configurationController.doPUTClusterConfigurationSite.args[1][0];
      expect(secondCallArgs.type).to.equal('f2');
      expect(secondCallArgs.properties).to.eql({"n2":"v2"});
      var thirdCallArgs = configurationController.doPUTClusterConfigurationSite.args[2][0];
      expect(thirdCallArgs.type).to.equal('f2');
      expect(thirdCallArgs.properties).to.eql({"n3":"v3"});
    });

  });

  describe('#loadServices', function() {

    beforeEach(function() {
      sinon.stub(installerStep8Controller, 'assignComponentHosts', function(obj) {
        Em.set(obj, 'component_value', 'component_value');
      });
      installerStep8Controller.set('services', []);
    });

    afterEach(function() {
      installerStep8Controller.assignComponentHosts.restore();
    });

    it('no reviewService', function() {
      installerStep8Controller.set('rawContent', []);
      installerStep8Controller.loadServices();
      expect(installerStep8Controller.get('services')).to.eql([]);
    });

    it('no reviewService 2', function() {
      installerStep8Controller.set('rawContent', [{config_name: 'services'}]);
      installerStep8Controller.loadServices();
      expect(installerStep8Controller.get('services')).to.eql([]);
    });

    it('no selectedServices', function() {
      installerStep8Controller.reopen({
        selectedServices: [],
        rawContent: [{config_name: 'services', config_value: [{}]}]
      });
      installerStep8Controller.loadServices();
      expect(installerStep8Controller.get('services')).to.eql([]);
    });

    it('no intersections selectedServices and reviewService.services', function() {
      installerStep8Controller.reopen({
        selectedServices: [{serviceName: 's1'}],
        rawContent: [{config_name: 'services', config_value: [{service_name: 's2'}]}]
      });
      installerStep8Controller.loadServices();
      expect(installerStep8Controller.get('services')).to.eql([]);
    });

    it('push some services', function() {
      installerStep8Controller.reopen({
        selectedServices: [{serviceName: 's1'}],
        rawContent: [
          {
            config_name: 'services',
            config_value: [Em.Object.create({service_name: 's1', service_components: [{}]})]
          }
        ]
      });
      installerStep8Controller.loadServices();
      expect(installerStep8Controller.get('services.length')).to.eql(1);
    });

  });

  describe('#createCoreSiteObj', function() {
    Em.A([
        {
          configs: [
            {filename: 'core-site.xml', name: 'hadoop.proxyuser.o.hosts'},
            {filename: 'core-site.xml', name: 'hadoop.proxyuser.o.groups'}
          ],
          globals: [
            {name: 'oozie_user', value: 'o'}
          ],
          selectedServices: [
            {serviceName: ''}
          ],
          m: 'no OOZIE',
          e: {
            excludedConfigs: ['hadoop.proxyuser.o.hosts', 'hadoop.proxyuser.o.groups'],
            includedConfigs: []
          }
        },
        {
          configs: [
            {filename: 'core-site.xml', name: 'hadoop.proxyuser.o.hosts'},
            {filename: 'core-site.xml', name: 'hadoop.proxyuser.o.groups'}
          ],
          globals: [
            {name: 'oozie_user', value: 'o'}
          ],
          selectedServices: [
            {serviceName: 'OOZIE'}
          ],
          m: 'OOZIE exists',
          e: {
            excludedConfigs: [],
            includedConfigs: ['hadoop.proxyuser.o.hosts', 'hadoop.proxyuser.o.groups']
          }
        },
        {
          configs: [
            {filename: 'core-site.xml', name: 'hadoop.proxyuser.h.hosts'},
            {filename: 'core-site.xml', name: 'hadoop.proxyuser.h.groups'}
          ],
          globals: [
            {name: 'hive_user', value: 'h'}
          ],
          selectedServices: [
            {serviceName: ''}
          ],
          m: 'no HIVE',
          e: {
            excludedConfigs: ['hadoop.proxyuser.h.hosts', 'hadoop.proxyuser.h.groups'],
            includedConfigs: []
          }
        },
        {
          configs: [
            {filename: 'core-site.xml', name: 'hadoop.proxyuser.h.hosts'},
            {filename: 'core-site.xml', name: 'hadoop.proxyuser.h.groups'}
          ],
          globals: [
            {name: 'hive_user', value: 'h'}
          ],
          selectedServices: [
            {serviceName: 'HIVE'}
          ],
          m: 'HIVE exists',
          e: {
            excludedConfigs: [],
            includedConfigs: ['hadoop.proxyuser.h.hosts', 'hadoop.proxyuser.h.groups']
          }
        },
        {
          configs: [
            {filename: 'core-site.xml', name: 'hadoop.proxyuser.hc.hosts'},
            {filename: 'core-site.xml', name: 'hadoop.proxyuser.hc.groups'}
          ],
          globals: [
            {name: 'hcat_user', value: 'hc'}
          ],
          selectedServices: [
            {serviceName: ''}
          ],
          m: 'no WEBHCAT',
          e: {
            excludedConfigs: ['hadoop.proxyuser.hc.hosts', 'hadoop.proxyuser.hc.groups'],
            includedConfigs: []
          }
        },
        {
          configs: [
            {filename: 'core-site.xml', name: 'hadoop.proxyuser.hc.hosts'},
            {filename: 'core-site.xml', name: 'hadoop.proxyuser.hc.groups'}
          ],
          globals: [
            {name: 'hcat_user', value: 'hc'}
          ],
          selectedServices: [
            {serviceName: 'WEBHCAT'}
          ],
          m: 'WEBHCAT exists',
          e: {
            excludedConfigs: [],
            includedConfigs: ['hadoop.proxyuser.hc.hosts', 'hadoop.proxyuser.hc.groups']
          }
        },
        {
          configs: [
            {filename: 'core-site.xml', name: 'fs.glusterfs.c1'},
            {filename: 'core-site.xml', name: 'fs.glusterfs.c2'}
          ],
          globals: [],
          selectedServices: [
            {serviceName: ''}
          ],
          m: 'no GLUSTERFS',
          e: {
            excludedConfigs: ['fs.glusterfs.c1', 'fs.glusterfs.c2', 'fs.default.name', 'fs.defaultFS'],
            includedConfigs: []
          }
        },
        {
          configs: [
            {filename: 'core-site.xml', name: 'fs.default.name'},
            {filename: 'core-site.xml', name: 'fs.defaultFS'}
          ],
          globals: [
            {name: 'fs_glusterfs_default_name', value: 'v1'},
            {name: 'glusterfs_defaultFS_name', value: 'v2'}
          ],
          selectedServices: [
            {serviceName: 'GLUSTERFS'}
          ],
          m: 'GLUSTERFS exists',
          e: {
            excludedConfigs: [],
            includedConfigs: ['fs.default.name', 'fs.defaultFS']
          }
        },
        {
          configs: [],
          globals: [
            {name: 'fs_glusterfs_default_name', value: 'v1'},
            {name: 'glusterfs_defaultFS_name', value: 'v2'}
          ],
          selectedServices: [
            {serviceName: 'GLUSTERFS'}
          ],
          m: 'GLUSTERFS exists 2',
          e: {
            excludedConfigs: ['fs_glusterfs_default_name', 'glusterfs_defaultFS_name'],
            includedConfigs: []
          }
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          installerStep8Controller.reopen({
            globals: test.globals,
            configs: test.configs,
            selectedServices: test.selectedServices
          });
          var coreSiteObj = installerStep8Controller.createCoreSiteObj();
          expect(coreSiteObj.type).to.equal('core-site');
          expect(coreSiteObj.tag).to.equal('version1');
          var properties = Em.keys(coreSiteObj.properties);
          test.e.excludedConfigs.forEach(function (configName) {
            expect(properties.contains(configName)).to.be.false;
          });
          test.e.includedConfigs.forEach(function (configName) {
            expect(properties.contains(configName)).to.be.true;
          });
        });
      });
  });

  describe('#createGlobalSiteObj', function() {

    it('required by agent configs should be skipped', function() {
      var globals = [{isRequiredByAgent: false, name: ''}, {isRequiredByAgent: false, name: ''}];
      installerStep8Controller.reopen({globals: globals, selectedServices: []});
      var globalSiteObj = installerStep8Controller.createGlobalSiteObj();
      expect(globalSiteObj.type).to.equal('global');
      expect(globalSiteObj.tag).to.equal('version1');
      expect(Em.keys(globalSiteObj.properties)).to.eql(['gmond_user']);
    });

    it('gluster configs should be skipped', function() {
      var globals = [{isRequiredByAgent: true, name: 'fs_glusterfs.c1'}, {isRequiredByAgent: true, name: 'fs_glusterfs.c2'}];
      installerStep8Controller.reopen({globals: globals, selectedServices: [{serviceName: ''}]});
      var globalSiteObj = installerStep8Controller.createGlobalSiteObj();
      expect(globalSiteObj.type).to.equal('global');
      expect(globalSiteObj.tag).to.equal('version1');
      expect(Em.keys(globalSiteObj.properties)).to.eql(['gmond_user']);
    });

    it('_heapsize|_newsize|_maxnewsize should add m to end', function() {
      var globals = [
        {isRequiredByAgent: true, name: 'c1_heapsize', value: '1'},
        {isRequiredByAgent: true, name: 'c1_newsize', value: '2'},
        {isRequiredByAgent: true, name: 'c1_maxnewsize', value: '3'}
      ];
      installerStep8Controller.reopen({globals: globals, selectedServices: [{serviceName: ''}]});
      var globalSiteObj = installerStep8Controller.createGlobalSiteObj();
      expect(globalSiteObj.type).to.equal('global');
      expect(globalSiteObj.tag).to.equal('version1');
      globals.forEach(function(global) {
        expect(globalSiteObj.properties[global.name]).to.equal(global.value + 'm');
      });
    });

    it('for some configs should not add  m to end', function() {
      var globals = [
        {isRequiredByAgent: true, name: 'hadoop_heapsize', value: '1'},
        {isRequiredByAgent: true, name: 'yarn_heapsize', value: '2'},
        {isRequiredByAgent: true, name: 'nodemanager_heapsize', value: '3'},
        {isRequiredByAgent: true, name: 'resourcemanager_heapsize', value: '4'},
        {isRequiredByAgent: true, name: 'apptimelineserver_heapsize', value: '5'},
        {isRequiredByAgent: true, name: 'jobhistory_heapsize', value: '6'}
      ];
      installerStep8Controller.reopen({globals: globals, selectedServices: [{serviceName: ''}]});
      var globalSiteObj = installerStep8Controller.createGlobalSiteObj();
      expect(globalSiteObj.type).to.equal('global');
      expect(globalSiteObj.tag).to.equal('version1');
      globals.forEach(function(global) {
        expect(globalSiteObj.properties[global.name]).to.equal(global.value);
      });
    });

  });

  describe('#applyInstalledServicesConfigurationGroup', function() {
    beforeEach(function() {
      sinon.stub($, 'ajax', Em.K);
      sinon.stub(App.router, 'get', function() {
        return configurationController;
      });
    });
    afterEach(function() {
      $.ajax.restore();
      App.router.get.restore();
    });
    it('should do ajax request for each config group', function() {
      var configGroups = [{ConfigGroup: {id:''}}, {ConfigGroup: {id:''}}];
      installerStep8Controller.applyInstalledServicesConfigurationGroup(configGroups);
      expect($.ajax.callCount).to.equal(configGroups.length);
    });
  });

  describe('#getExistingClusterNames', function() {
    beforeEach(function() {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    afterEach(function() {
      App.ajax.send.restore();
    });
    it('should do ajax request', function() {
      installerStep8Controller.getExistingClusterNames();
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#loadConfigs', function() {
    beforeEach(function() {
      sinon.stub(installerStep8Controller, 'loadUiSideConfigs', function(k) {return k});
      sinon.stub(App.config, 'excludeUnsupportedConfigs', function(k) {return k;});
    });
    afterEach(function() {
      installerStep8Controller.loadUiSideConfigs.restore();
      App.config.excludeUnsupportedConfigs.restore();
    });
    it('should save configs', function() {
      var serviceConfigProperties = [
        {id: 'site property', value: true, isCanBeEmpty: true},
        {id: 'site property', value: 1, isCanBeEmpty: true},
        {id: 'site property', value: '1', isCanBeEmpty: true},
        {id: 'site property', value: null, isCanBeEmpty: false}
      ];
      installerStep8Controller.reopen({content: {services: [], serviceConfigProperties: serviceConfigProperties}, configMapping: []});
      installerStep8Controller.loadConfigs();
      var configs = installerStep8Controller.get('configs');
      expect(configs.mapProperty('value')).to.eql(['true', 1, '1']);
    });
  });

  describe('#loadUiSideConfigs', function() {
    beforeEach(function() {
      sinon.stub(installerStep8Controller, 'addDynamicProperties', Em.K);
      sinon.stub(installerStep8Controller, 'getGlobConfigValueWithOverrides', function(t, v, n) {
        return {
          value: v,
          overrides: []
        }
      });
      sinon.stub(App.config, 'setConfigValue', Em.K);
    });
    afterEach(function() {
      installerStep8Controller.addDynamicProperties.restore();
      installerStep8Controller.getGlobConfigValueWithOverrides.restore();
      App.config.setConfigValue.restore();
    });

    it('all configs witohut foreignKey', function() {
      var configMapping = [
        {foreignKey: null, templateName: 't1', value: 'v1', name: 'c1', filename: 'f1'},
        {foreignKey: null, templateName: 't2', value: 'v2', name: 'c2', filename: 'f2'},
        {foreignKey: null, templateName: 't3', value: 'v3', name: 'c3', filename: 'f2'},
        {foreignKey: null, templateName: 't4', value: 'v4', name: 'c4', filename: 'f1'}
      ];
      var uiConfigs = installerStep8Controller.loadUiSideConfigs(configMapping);
      expect(uiConfigs.length).to.equal(configMapping.length);
      expect(uiConfigs.everyProperty('id', 'site property')).to.be.true;
      uiConfigs.forEach(function(c, index) {
        expect(c.overrides).to.be.an.array;
        expect(c.value).to.equal(configMapping[index].value);
        expect(c.name).to.equal(configMapping[index].name);
        expect(c.filename).to.equal(configMapping[index].filename);
      });
    });

    it('some configs witohut foreignKey', function() {
      var configMapping = [
        {foreignKey: null, templateName: 't1', value: 'v1', name: 'c1', filename: 'f1'},
        {foreignKey: null, templateName: 't2', value: 'v2', name: 'c2', filename: 'f2'},
        {foreignKey: null, templateName: 't3', value: 'v3', name: 'c3', filename: 'f2'},
        {foreignKey: null, templateName: 't4', value: 'v4', name: 'c4', filename: 'f1'},
        {foreignKey: 'fk1', templateName: 't5', value: 'v5', name: 'c5', filename: 'f1'},
        {foreignKey: 'fk2', templateName: 't6', value: 'v6', name: 'c6', filename: 'f1'},
        {foreignKey: 'fk3', templateName: 't7', value: 'v7', name: 'c7', filename: 'f2'},
        {foreignKey: 'fk4', templateName: 't8', value: 'v8', name: 'c8', filename: 'f2'}
      ];
      var uiConfigs = installerStep8Controller.loadUiSideConfigs(configMapping);
      expect(uiConfigs.length).to.equal(configMapping.length);
      expect(uiConfigs.everyProperty('id', 'site property')).to.be.true;
      uiConfigs.forEach(function(c, index) {
        if (Em.isNone(configMapping[index].foreignKey))
          expect(c.overrides).to.be.an.array;
        expect(c.value).to.equal(configMapping[index].value);
        expect(c.name).to.equal(configMapping[index].name);
        expect(c.filename).to.equal(configMapping[index].filename);
      });
    });
  });

  describe('#getGlobConfigValueWithOverrides', function() {

    it('shouldn\t do nothing', function() {
      var r = installerStep8Controller.getGlobConfigValueWithOverrides('', 'without tags', '');
      expect(r).to.eql({value: 'without tags', overrides: []});
    });

    it('should return value with empty overrides', function() {
      installerStep8Controller.set('globals', [
        {name: 'c1', value: 'v1', overrides: []}
      ]);
      var r = installerStep8Controller.getGlobConfigValueWithOverrides(['c1'], '<templateName[0]>', '');
      expect(r).to.eql({value: 'v1', overrides: []});
    });

    it('should return value with not empty overrides', function() {
      installerStep8Controller.set('globals', [
        {name: 'c1', value: 'v1', overrides: [{value: 'v2', hosts: ['h2']}]}
      ]);
      var r = installerStep8Controller.getGlobConfigValueWithOverrides(['c1'], '<templateName[0]>', '');
      expect(r).to.eql({value: 'v1', overrides: [{value: 'v2', hosts: ['h2']}]});
    });

  });

  describe('Queued requests', function() {

    beforeEach(function() {
      sinon.stub(installerStep8Controller, 'addRequestToAjaxQueue', Em.K);
    });

    afterEach(function() {
      installerStep8Controller.addRequestToAjaxQueue.restore();
    });

    describe('#createCluster', function() {
      it('shouldn\'t add request to queue if not installerController used', function() {
        installerStep8Controller.reopen({content: {controllerName: 'addServiceController'}});
        installerStep8Controller.createCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.called).to.equal(false);
      });
      it('App.currentStackVersion should be changed if localRepo selected', function() {
        App.set('currentStackVersion', 'HDP-1.1.1');
        installerStep8Controller.reopen({content: {controllerName: 'installerController', installOptions: {localRepo: true}}});
        var data = {
          data: JSON.stringify({ "Clusters": {"version": 'HDPLocal-1.1.1' }})
        };
        installerStep8Controller.createCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data).to.eql(data);
      });
      it('App.currentStackVersion shouldn\'t be changed if localRepo ins\'t selected', function() {
        App.set('currentStackVersion', 'HDP-1.1.1');
        installerStep8Controller.reopen({content: {controllerName: 'installerController', installOptions: {localRepo: false}}});
        var data = {
          data: JSON.stringify({ "Clusters": {"version": 'HDP-1.1.1' }})
        };
        installerStep8Controller.createCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data).to.eql(data);
      });
    });

    describe('#createSelectedServices', function() {
      it('shouldn\'t do nothing if no data', function() {
        sinon.stub(installerStep8Controller, 'createSelectedServicesData', function() {return [];});
        installerStep8Controller.createSelectedServices();
        expect(installerStep8Controller.addRequestToAjaxQueue.called).to.equal(false);
        installerStep8Controller.createSelectedServicesData.restore();
      });
      it('should call addRequestToAjaxQueue with computed data', function() {
        var data = [
          {"ServiceInfo": { "service_name": 's1' }},
          {"ServiceInfo": { "service_name": 's2' }},
          {"ServiceInfo": { "service_name": 's3' }}
        ];
        sinon.stub(installerStep8Controller, 'createSelectedServicesData', function() {return data;});
        installerStep8Controller.createSelectedServices();
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data).to.eql({data: JSON.stringify(data)});
        installerStep8Controller.createSelectedServicesData.restore();
      });
    });

    describe('#registerHostsToCluster', function() {
      it('shouldn\'t do nothing if no data', function() {
        sinon.stub(installerStep8Controller, 'createRegisterHostData', function() {return [];});
        installerStep8Controller.registerHostsToCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.called).to.equal(false);
        installerStep8Controller.createRegisterHostData.restore();
      });
      it('should call addRequestToAjaxQueue with computed data', function() {
        var data = [
          {"Hosts": { "host_name": 'h1'}},
          {"Hosts": { "host_name": 'h3'}}
        ];
        sinon.stub(installerStep8Controller, 'createRegisterHostData', function() {return data;});
        installerStep8Controller.registerHostsToCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data).to.eql({data: JSON.stringify(data)});
        installerStep8Controller.createRegisterHostData.restore();
      });
    });

    describe('#registerHostsToComponent', function() {

      it('shouldn\'t do request if no hosts provided', function() {
        installerStep8Controller.registerHostsToComponent([]);
        expect(installerStep8Controller.addRequestToAjaxQueue.called).to.equal(false);
      });

      it('should do request if hostNames are provided', function() {
        var hostNames = ['h1', 'h2'],
          componentName = 'c1';
        installerStep8Controller.registerHostsToComponent(hostNames, componentName);
        var data = JSON.parse(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data);
        expect(data.RequestInfo.query).to.equal('Hosts/host_name=h1|Hosts/host_name=h2');
        expect(data.Body.host_components[0].HostRoles.component_name).to.equal('c1');
      });

    });

    describe('#applyConfigurationsToCluster', function() {
      it('should call addRequestToAjaxQueue', function() {
        var serviceConfigTags = [
            {
              type: 'type1',
              tag: 'tag1',
              properties: [
                {},
                {}
              ]
            }
          ],
          data = '['+JSON.stringify({
            Clusters: {
              desired_config: {
                type: serviceConfigTags[0].type,
                tag: serviceConfigTags[0].tag,
                properties: serviceConfigTags[0].properties
              }
            }
          })+']';
        installerStep8Controller.reopen({serviceConfigTags: serviceConfigTags});
        installerStep8Controller.applyConfigurationsToCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data).to.eql({data: data});
      });
    });

    describe('#applyConfigurationGroups', function() {
      it('should call addRequestToAjaxQueue', function() {
        var data = [{}, {}];
        installerStep8Controller.applyConfigurationGroups(data);
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data).to.eql({data: JSON.stringify(data)});
      });
    });

    describe('#newServiceComponentErrorCallback', function() {

      it('should add request for new component', function() {
        var serviceName = 's1',
          componentName = 'c1';
        installerStep8Controller.newServiceComponentErrorCallback({}, {}, '', {}, {serviceName: serviceName, componentName: componentName});
        var data = JSON.parse(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data);
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.serviceName).to.equal(serviceName);
        expect(data.components[0].ServiceComponentInfo.component_name).to.equal(componentName);
      });

    });

    describe('#createComponents', function() {
      beforeEach(function() {
        installerStep8Controller.reopen({
          selectedServices: [
            Em.Object.create({serviceName: 's1'}),
            Em.Object.create({serviceName: 's2'})
          ]
        });
        sinon.stub(App.StackServiceComponent, 'find', function() {
          return Em.A([
            Em.Object.create({serviceName: 's1', componentName: 'c1'}),
            Em.Object.create({serviceName: 's1', componentName: 'c2'}),
            Em.Object.create({serviceName: 's2', componentName: 'c3'}),
            Em.Object.create({serviceName: 's2', componentName: 'c4'})
          ]);
        });
      });
      afterEach(function() {
        App.StackServiceComponent.find.restore();
      });

      it('should do two requests', function() {
        installerStep8Controller.createComponents();
        expect(installerStep8Controller.addRequestToAjaxQueue.calledTwice).to.be.true;
        var firstRequestData = JSON.parse(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data);
        expect(firstRequestData.components.mapProperty('ServiceComponentInfo.component_name')).to.eql(['c1', 'c2']);
        var secondRequestData = JSON.parse(installerStep8Controller.addRequestToAjaxQueue.args[1][0].data.data);
        expect(secondRequestData.components.mapProperty('ServiceComponentInfo.component_name')).to.eql(['c3', 'c4']);
      });

      it('should check App_TIMELINE_SERVER', function() {
        sinon.stub(App, 'get', function(k) {
          if ('isHadoop21Stack' === k) return true;
          if ('testMode' === k) return false;
          return Em.get(App, k);
        });
        sinon.stub(App.YARNService, 'find', function() {return [{}]});
        sinon.stub(App.ajax, 'send', Em.K);
        installerStep8Controller.set('content', {controllerName: 'addServiceController'});

        installerStep8Controller.createComponents();
        expect(App.ajax.send.calledOnce).to.equal(true);
        expect(App.ajax.send.args[0][0].data.serviceName).to.equal('YARN');
        expect(App.ajax.send.args[0][0].data.componentName).to.equal('APP_TIMELINE_SERVER');

        App.ajax.send.restore();
        App.get.restore();
        App.YARNService.find.restore();
      });

    });

    describe('#setLocalRepositories', function() {

      it('shouldn\'t do nothing', function () {
        installerStep8Controller.set('content', {controllerName: 'addServiceController'});
        sinon.stub(App, 'get', function (k) {
          if ('supports.localRepositories' === k) return false;
          return Em.get(App, k);
        });
        expect(installerStep8Controller.setLocalRepositories()).to.equal(false);
        App.get.restore();
      });

      it('shouldn\'t do requests', function() {
        installerStep8Controller.set('content', {
          controllerName: 'installerController',
          stacks: [
            {
              isSelected: true,
              operatingSystems: [
                {baseUrl: 'u1', originalBaseUrl: 'u1'},
                {baseUrl: 'u2', originalBaseUrl: 'u2'}
              ]
            }
          ]
        });
        installerStep8Controller.setLocalRepositories();
        expect(installerStep8Controller.addRequestToAjaxQueue.called).to.equal(false);
      });

      it('should do 2 requests', function() {
        installerStep8Controller.set('content', {
          controllerName: 'installerController',
          stacks: [
            {
              isSelected: true,
              operatingSystems: [
                {baseUrl: 'new_u1', originalBaseUrl: 'u1', osType: 'o1', repoId: 'r1'},
                {baseUrl: 'new_u2', originalBaseUrl: 'u2', osType: 'o2', repoId: 'r2'}
              ]
            }
          ]
        });
        installerStep8Controller.setLocalRepositories();
        expect(installerStep8Controller.addRequestToAjaxQueue.calledTwice).to.equal(true);
        var firstRequestData = installerStep8Controller.addRequestToAjaxQueue.args[0][0].data;
        expect(firstRequestData.osType).to.equal('o1');
        expect(firstRequestData.repoId).to.equal('r1');
        expect(JSON.parse(firstRequestData.data).Repositories.base_url).to.equal('new_u1');

        var secondRequestData = installerStep8Controller.addRequestToAjaxQueue.args[1][0].data;
        expect(secondRequestData.osType).to.equal('o2');
        expect(secondRequestData.repoId).to.equal('r2');
        expect(JSON.parse(secondRequestData.data).Repositories.base_url).to.equal('new_u2');
      });

    });

    describe('#createMasterHostComponents', function() {
      beforeEach(function() {
        sinon.stub(installerStep8Controller, 'registerHostsToComponent', Em.K);
      });
      afterEach(function() {
        installerStep8Controller.registerHostsToComponent.restore();
      });
      it('should create components', function() {
        var masterComponentHosts = [
          {component: 'c1', isInstalled: false, hostName: 'h1'},
          {component: 'c1', isInstalled: true, hostName: 'h2'},
          {component: 'c2', isInstalled: false, hostName: 'h1'},
          {component: 'c2', isInstalled: false, hostName: 'h2'}
        ];
        installerStep8Controller.set('content', {masterComponentHosts: masterComponentHosts});
        installerStep8Controller.createMasterHostComponents();
        expect(installerStep8Controller.registerHostsToComponent.calledTwice).to.equal(true);
        expect(installerStep8Controller.registerHostsToComponent.args[0][0]).to.eql(['h1']);
        expect(installerStep8Controller.registerHostsToComponent.args[0][1]).to.equal('c1');
        expect(installerStep8Controller.registerHostsToComponent.args[1][0]).to.eql(['h1', 'h2']);
        expect(installerStep8Controller.registerHostsToComponent.args[1][1]).to.equal('c2');
      });
    });

    describe('#createAdditionalHostComponents', function() {

      beforeEach(function() {
        sinon.stub(installerStep8Controller, 'registerHostsToComponent', Em.K);
      });

      afterEach(function() {
        installerStep8Controller.registerHostsToComponent.restore();
      });

      it('should add GANGLIA MONITOR (1)', function() {
        installerStep8Controller.reopen({
          getRegisteredHosts: function() {
            return [{hostName: 'h1'}, {hostName: 'h2'}];
          },
          content: {
            services: [
              Em.Object.create({serviceName: 'GANGLIA', isSelected: true, isInstalled: false})
            ]
          }
        });
        installerStep8Controller.createAdditionalHostComponents();
        expect(installerStep8Controller.registerHostsToComponent.calledOnce).to.equal(true);
        expect(installerStep8Controller.registerHostsToComponent.args[0][0]).to.eql(['h1', 'h2']);
        expect(installerStep8Controller.registerHostsToComponent.args[0][1]).to.equal('GANGLIA_MONITOR');
      });

      it('should add GANGLIA MONITOR (2)', function() {
        installerStep8Controller.reopen({
          getRegisteredHosts: function() {
            return [{hostName: 'h1', isInstalled: true}, {hostName: 'h2', isInstalled: false}];
          },
          content: {
            services: [
              Em.Object.create({serviceName: 'GANGLIA', isSelected: true, isInstalled: true})
            ]
          }
        });
        installerStep8Controller.createAdditionalHostComponents();
        expect(installerStep8Controller.registerHostsToComponent.calledOnce).to.equal(true);
        expect(installerStep8Controller.registerHostsToComponent.args[0][0]).to.eql(['h2']);
        expect(installerStep8Controller.registerHostsToComponent.args[0][1]).to.equal('GANGLIA_MONITOR');
      });

      it('should add MYSQL_SERVER', function() {
        installerStep8Controller.reopen({
          getRegisteredHosts: function() {
            return [{hostName: 'h1'}, {hostName: 'h2'}];
          },
          content: {
            masterComponentHosts: [
              {component: 'HIVE_SERVER', hostName: 'h1'},
              {component: 'HIVE_SERVER', hostName: 'h2'}
            ],
            services: [
              Em.Object.create({serviceName: 'HIVE', isSelected: true, isInstalled: false})
            ],
            serviceConfigProperties: [
              {name: 'hive_database', value: 'New MySQL Database'}
            ]
          }
        });
        installerStep8Controller.createAdditionalHostComponents();
        expect(installerStep8Controller.registerHostsToComponent.calledOnce).to.equal(true);
        expect(installerStep8Controller.registerHostsToComponent.args[0][0]).to.eql(['h1', 'h2']);
        expect(installerStep8Controller.registerHostsToComponent.args[0][1]).to.equal('MYSQL_SERVER');
      });

    });

    describe('#createSlaveAndClientsHostComponents', function() {

      beforeEach(function() {
        sinon.stub(installerStep8Controller, 'registerHostsToComponent', Em.K);
      });

      afterEach(function() {
        installerStep8Controller.registerHostsToComponent.restore();
      });

      it('each slave is not CLIENT', function() {
        installerStep8Controller.reopen({
          content: {
            slaveComponentHosts: [
              {componentName: 'c1', hosts: [{isInstalled: true, hostName: 'h1'}, {isInstalled: false, hostName: 'h2'}, {isInstalled: false, hostName: 'h3'}]}
            ]
          }
        });
        installerStep8Controller.createSlaveAndClientsHostComponents();
        expect(installerStep8Controller.registerHostsToComponent.calledOnce).to.be.true;
        expect(installerStep8Controller.registerHostsToComponent.args[0][0]).to.eql(['h2', 'h3']);
        expect(installerStep8Controller.registerHostsToComponent.args[0][1]).to.equal('c1');
      });

      var clients = Em.A([
        {
          component_name: 'HDFS_CLIENT',
          masterComponentHosts: [
            {component: 'HBASE_MASTER', isInstalled: false, hostName: 'h1'},
            {component: 'HBASE_MASTER', isInstalled: true, hostName: 'h2'},
            {component: 'HBASE_REGIONSERVER', isInstalled: false, hostName: 'h3'},
            {component: 'WEBHCAT_SERVER', isInstalled: false, hostName: 'h1'},
            {component: 'HISTORYSERVER', isInstalled: false, hostName: 'h3'},
            {component: 'OOZIE_SERVER', isInstalled: true, hostName: 'h4'}
          ],
          e: ['h1', 'h3']
        },
        {
          component_name: 'MAPREDUCE_CLIENT',
          masterComponentHosts: [
            {component: 'HIVE_SERVER', isInstalled: false, hostName: 'h1'},
            {component: 'WEBHCAT_SERVER', isInstalled: false, hostName: 'h1'},
            {component: 'NAGIOS_SERVER', isInstalled: false, hostName: 'h2'},
            {component: 'OOZIE_SERVER', isInstalled: true, hostName: 'h3'}
          ],
          e: ['h1', 'h2']
        },
        {
          component_name: 'OOZIE_CLIENT',
          masterComponentHosts: [
            {component: 'NAGIOS_SERVER', isInstalled: false, hostName: 'h2'}
          ],
          e: ['h2']
        },
        {
          component_name: 'ZOOKEEPER_CLIENT',
          masterComponentHosts: [
            {component: 'WEBHCAT_SERVER', isInstalled: false, hostName: 'h1'}
          ],
          e: ['h1']
        },
        {
          component_name: 'HIVE_CLIENT',
          masterComponentHosts: [
            {component: 'WEBHCAT_SERVER', isInstalled: false, hostName: 'h1'},
            {component: 'HIVE_SERVER', isInstalled: false, hostName: 'h1'}
          ],
          e: ['h1']
        },
        {
          component_name: 'HCAT',
          masterComponentHosts: [
            {component: 'NAGIOS_SERVER', isInstalled: false, hostName: 'h1'}
          ],
          e: ['h1']
        },
        {
          component_name: 'YARN_CLIENT',
          masterComponentHosts: [
            {component: 'NAGIOS_SERVER', isInstalled: false, hostName: 'h1'},
            {component: 'HIVE_SERVER', isInstalled: false, hostName: 'h2'},
            {component: 'OOZIE_SERVER', isInstalled: false, hostName: 'h3'},
            {component: 'WEBHCAT_SERVER', isInstalled: true, hostName: 'h1'}
          ],
          e: ['h1', 'h2', 'h3']
        },
        {
          component_name: 'TEZ_CLIENT',
          masterComponentHosts: [
            {component: 'NAGIOS_SERVER', isInstalled: false, hostName: 'h1'},
            {component: 'HIVE_SERVER', isInstalled: false, hostName: 'h2'}
          ],
          e: ['h1', 'h2']
        }
      ]);

      clients.forEach(function(test) {
        it('slave is CLIENT (isInstalled false) ' + test.component_name, function() {
          installerStep8Controller.reopen({
            content: {
              clients: [
                {isInstalled: false, component_name: test.component_name}
              ],
              slaveComponentHosts: [
                {componentName: 'CLIENT', hosts: []}
              ],
              masterComponentHosts: test.masterComponentHosts
            }
          });
          installerStep8Controller.createSlaveAndClientsHostComponents();
          expect(installerStep8Controller.registerHostsToComponent.calledOnce).to.be.true;
          expect(installerStep8Controller.registerHostsToComponent.args[0][0]).to.eql(test.e);
          expect(installerStep8Controller.registerHostsToComponent.args[0][1]).to.equal(test.component_name);
        });
      });

      clients.forEach(function(test) {
        it('slave is CLIENT (isInstalled true, h1 - host to be excluded) ' + test.component_name, function() {
          sinon.stub(App.HostComponent, 'find', function() {
            return [
              {componentName: test.component_name, workStatus: 'INSTALLED', host: {hostName: 'h1'}}
            ];
          });
          installerStep8Controller.reopen({
            content: {
              clients: [
                {isInstalled: true, component_name: test.component_name}
              ],
              slaveComponentHosts: [
                {componentName: 'CLIENT', hosts: []}
              ],
              masterComponentHosts: test.masterComponentHosts
            }
          });
          installerStep8Controller.createSlaveAndClientsHostComponents();

          App.HostComponent.find.restore();
          expect(installerStep8Controller.registerHostsToComponent.calledOnce).to.be.true;
          // Don't know why, but
          // expect(installerStep8Controller.registerHostsToComponent.args[0][0]).to.eql(test.e.without('h1'));
          // doesn't work
          expect(JSON.stringify(installerStep8Controller.registerHostsToComponent.args[0][0])).to.equal(JSON.stringify(test.e.without('h1')));
          expect(installerStep8Controller.registerHostsToComponent.args[0][1]).to.equal(test.component_name);
        });
      });

    });

  });

});

});

;require.register("test/controllers/wizard/step9_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var Ember = require('ember');
var App = require('app');
require('models/stack_service_component');
require('models/hosts');
require('controllers/wizard/step9_controller');
require('utils/helper');
var modelSetup = require('test/init_model_test');
var c, obj;
describe('App.InstallerStep9Controller', function () {
  beforeEach(function () {
    modelSetup.setupStackServiceComponent();
    c = App.WizardStep9Controller.create();
    obj = App.InstallerController.create();
  });
  afterEach(function () {
    modelSetup.cleanStackServiceComponent();
  });

  describe('#isSubmitDisabled', function () {
    var tests = Em.A([
      {controllerName: 'addHostController', state: 'STARTED', e: false},
      {controllerName: 'addHostController', state: 'START FAILED', e: false},
      {controllerName: 'addHostController', state: 'INSTALL FAILED', e: false},
      {controllerName: 'addHostController', state: 'PENDING', e: true},
      {controllerName: 'addHostController', state: 'INSTALLED', e: true},
      {controllerName: 'addServiceController', state: 'STARTED', e: false},
      {controllerName: 'addServiceController', state: 'START FAILED', e: false},
      {controllerName: 'addServiceController', state: 'INSTALL FAILED', e: false},
      {controllerName: 'addServiceController', state: 'PENDING', e: true},
      {controllerName: 'addServiceController', state: 'INSTALLED', e: true},
      {controllerName: 'installerController', state: 'STARTED', e: false},
      {controllerName: 'installerController', state: 'START FAILED', e: false},
      {controllerName: 'installerController', state: 'INSTALL FAILED', e: true},
      {controllerName: 'installerController', state: 'INSTALLED', e: true},
      {controllerName: 'installerController', state: 'PENDING', e: true}
    ]);
    tests.forEach(function (test) {
      var controller = App.WizardStep9Controller.create({
        content: {
          controllerName: test.controllerName,
          cluster: {
            status: test.state
          }
        }
      });
      it('controllerName is ' + test.controllerName + '; cluster status is ' + test.state + '; isSubmitDisabled should be ' + test.e, function () {
        expect(controller.get('isSubmitDisabled')).to.equal(test.e);
      });
    });

  });

  describe('#status', function () {
    var tests = Em.A([
      {
        hosts: [
          {status: 'failed'},
          {status: 'success'}
        ],
        isStepFailed: false,
        progress: '100',
        m: 'One host is failed',
        e: 'failed'
      },
      {
        hosts: [
          {status: 'warning'},
          {status: 'success'}
        ],
        m: 'One host is failed and step is not failed',
        isStepFailed: false,
        progress: '100',
        e: 'warning'
      },
      {
        hosts: [
          {status: 'warning'},
          {status: 'success'}
        ],
        m: 'One host is failed and step is failed',
        isStepFailed: true,
        progress: '100',
        e: 'failed'
      },
      {
        hosts: [
          {status: 'success'},
          {status: 'success'}
        ],
        m: 'All hosts are success and progress is 100',
        isStepFailed: false,
        progress: '100',
        e: 'success'
      },
      {
        hosts: [
          {status: 'success'},
          {status: 'success'}
        ],
        m: 'All hosts are success and progress is 50',
        isStepFailed: false,
        progress: '50',
        e: 'info'
      }
    ]);
    tests.forEach(function (test) {
      var controller = App.WizardStep9Controller.create({hosts: test.hosts, isStepFailed: function () {
        return test.isStepFailed
      }, progress: test.progress});
      controller.updateStatus();
      it(test.m, function () {
        expect(controller.get('status')).to.equal(test.e);
      });
    });
  });

  describe('#showRetry', function () {
    it('cluster status is not INSTALL FAILED', function () {
      var controller = App.WizardStep9Controller.create({content: {cluster: {status: 'INSTALLED'}}});
      expect(controller.get('showRetry')).to.equal(false);
    });
    it('cluster status is INSTALL FAILED', function () {
      var controller = App.WizardStep9Controller.create({content: {cluster: {status: 'INSTALL FAILED'}}});
      expect(controller.get('showRetry')).to.equal(true);
    });
  });

  describe('#resetHostsForRetry', function () {
    var hosts = {'host1': Em.Object.create({status: 'failed', message: 'Failed'}), 'host2': Em.Object.create({status: 'success', message: 'Success'})};
    var controller = App.WizardStep9Controller.create({content: {hosts: hosts}});
    it('All should have status "pending" and message "Waiting"', function () {
      controller.resetHostsForRetry();
      for (var name in hosts) {
        if (hosts.hasOwnProperty(name)) {
          expect(controller.get('content.hosts')[name].get('status', 'pending')).to.equal('pending');
          expect(controller.get('content.hosts')[name].get('message', 'Waiting')).to.equal('Waiting');
        }
      }
    });
  });

  var hosts_for_load_and_render = {
    'host1': {
      message: 'message1',
      status: 'unknown',
      progress: '1',
      logTasks: [
        {},
        {}
      ],
      bootStatus: 'REGISTERED'
    },
    'host2': {
      message: '',
      status: 'failed',
      progress: '1',
      logTasks: [
        {},
        {}
      ],
      bootStatus: ''
    },
    'host3': {
      message: '',
      status: 'waiting',
      progress: null,
      logTasks: [
        {},
        {}
      ],
      bootStatus: ''
    },
    'host4': {
      message: 'message4',
      status: null,
      progress: '10',
      logTasks: [
        {}
      ],
      bootStatus: 'REGISTERED'
    }
  };

  describe('#loadHosts', function () {
    var controller = App.WizardStep9Controller.create({content: {hosts: hosts_for_load_and_render}});
    controller.loadHosts();
    var loaded_hosts = controller.get('hosts');
    it('Only REGISTERED hosts', function () {
      expect(loaded_hosts.length).to.equal(2);
    });
    it('All hosts have progress 0', function () {
      expect(loaded_hosts.everyProperty('progress', 0)).to.equal(true);
    });
    it('All hosts have progress 0', function () {
      expect(loaded_hosts.everyProperty('progress', 0)).to.equal(true);
    });
    it('All host don\'t have logTasks', function () {
      expect(loaded_hosts.everyProperty('logTasks.length', 0)).to.equal(true);
    });
  });

  describe('#hostHasClientsOnly', function () {
    var tests = Em.A([
      {
        hosts: [
          Em.Object.create({
            hostName: 'host1',
            logTasks: [
              {Tasks: {role: 'HDFS_CLIENT'}},
              {Tasks: {role: 'DATANODE'}}
            ],
            status: 'old_status',
            progress: '10',
            e: {status: 'old_status', progress: '10'}
          }),
          Em.Object.create({
            hostName: 'host2',
            logTasks: [
              {Tasks: {role: 'HDFS_CLIENT'}}
            ],
            status: 'old_status',
            progress: '10',
            e: {status: 'success', progress: '100'}
          })
        ],
        jsonError: false
      },
      {
        hosts: [
          Em.Object.create({
            hostName: 'host1',
            logTasks: [
              {Tasks: {role: 'HDFS_CLIENT'}},
              {Tasks: {role: 'DATANODE'}}
            ],
            status: 'old_status',
            progress: '10',
            e: {status: 'success', progress: '100'}
          }),
          Em.Object.create({
            hostName: 'host2',
            logTasks: [
              {Tasks: {role: 'HDFS_CLIENT'}}
            ],
            status: 'old_status',
            progress: '10',
            e: {status: 'success', progress: '100'}
          })
        ],
        jsonError: true
      }
    ]);
    tests.forEach(function (test) {
      it('', function () {
        var controller = App.WizardStep9Controller.create({hosts: test.hosts});
        controller.hostHasClientsOnly(test.jsonError);
        test.hosts.forEach(function (host) {
          expect(controller.get('hosts').findProperty('hostName', host.hostName).get('status')).to.equal(host.e.status);
          expect(controller.get('hosts').findProperty('hostName', host.hostName).get('progress')).to.equal(host.e.progress);
        });
      });
    });
  });

  describe('#onSuccessPerHost', function () {
    var tests = Em.A([
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'pending'}),
        actions: [],
        e: {status: 'success'},
        m: 'No tasks for host'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'success'},
        m: 'All Tasks COMPLETED and cluster status INSTALLED'
      },
      {
        cluster: {status: 'FAILED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'info'},
        m: 'All Tasks COMPLETED and cluster status FAILED'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'FAILED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'info'},
        m: 'Not all Tasks COMPLETED and cluster status INSTALLED'
      },
      {
        cluster: {status: 'FAILED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'FAILED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'info'},
        m: 'Not all Tasks COMPLETED and cluster status FAILED'
      }
    ]);
    tests.forEach(function (test) {
      var controller = App.WizardStep9Controller.create({content: {cluster: {status: test.cluster.status}}});
      controller.onSuccessPerHost(test.actions, test.host);
      it(test.m, function () {
        expect(test.host.status).to.equal(test.e.status);
      });
    });
  });

  describe('#onErrorPerHost', function () {
    var tests = Em.A([
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'pending'}),
        actions: [],
        e: {status: 'pending'},
        isMasterFailed: false,
        m: 'No tasks for host'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'FAILED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'warning'},
        isMasterFailed: false,
        m: 'One Task FAILED and cluster status INSTALLED'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'ABORTED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'warning'},
        isMasterFailed: false,
        m: 'One Task ABORTED and cluster status INSTALLED'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'TIMEDOUT'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'warning'},
        isMasterFailed: false,
        m: 'One Task TIMEDOUT and cluster status INSTALLED'
      },
      {
        cluster: {status: 'PENDING'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'FAILED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'failed'},
        isMasterFailed: true,
        m: 'One Task FAILED and cluster status PENDING isMasterFailed true'
      },
      {
        cluster: {status: 'PENDING'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'info'},
        isMasterFailed: false,
        m: 'One Task FAILED and cluster status PENDING isMasterFailed false'
      }
    ]);
    tests.forEach(function (test) {
      var controller = App.WizardStep9Controller.create({content: {cluster: {status: test.cluster.status}}, isMasterFailed: function () {
        return test.isMasterFailed;
      }});
      controller.onErrorPerHost(test.actions, test.host);
      it(test.m, function () {
        expect(test.host.status).to.equal(test.e.status);
      });
    });
  });

  describe('#isMasterFailed', function () {
    var tests = Em.A([
      {
        actions: [
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'DATANODE'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'TASKTRACKER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'HBASE_REGIONSERVER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'GANGLIA_MONITOR'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'SUPERVISOR'}}
        ],
        e: false,
        m: 'No one Master is failed'
      },
      {
        actions: [
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'NAMENODE'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'TASKTRACKER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'HBASE_REGIONSERVER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'GANGLIA_MONITOR'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'SUPERVISOR'}}
        ],
        e: true,
        m: 'One Master is failed'
      },
      {
        actions: [
          {Tasks: {command: 'PENDING', status: 'FAILED', role: 'NAMENODE'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'TASKTRACKER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'HBASE_REGIONSERVER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'GANGLIA_MONITOR'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'SUPERVISOR'}}
        ],
        e: false,
        m: 'one Master is failed but command is not install'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        var controller = App.WizardStep9Controller.create();
        expect(controller.isMasterFailed(test.actions)).to.equal(test.e);
      });
    });
  });

  describe('#onInProgressPerHost', function () {
    var tests = Em.A([
      {
        host: Em.Object.create({message: 'default_message'}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {message: 'default_message', b: true},
        m: 'All Tasks COMPLETED'
      },
      {
        host: Em.Object.create({message: 'default_message'}),
        actions: [
          {Tasks: {status: 'IN_PROGRESS'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {message: 'default_message', b: false},
        m: 'One Task IN_PROGRESS'
      },
      {
        host: Em.Object.create({message: 'default_message'}),
        actions: [
          {Tasks: {status: 'QUEUED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {message: 'default_message', b: false},
        m: 'One Task QUEUED'
      },
      {
        host: Em.Object.create({message: 'default_message'}),
        actions: [
          {Tasks: {status: 'PENDING'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {message: 'default_message', b: false},
        m: 'One Task PENDING'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        var controller = App.WizardStep9Controller.create();
        controller.onInProgressPerHost(test.actions, test.host);
        expect(test.host.message == test.e.message).to.equal(test.e.b);
      });
    });
  });

  describe('#progressPerHost', function () {
    var tests = Em.A([
      {
        cluster: {status: 'PENDING'},
        host: Em.Object.create({progress: 0}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'QUEUED'}},
          {Tasks: {status: 'QUEUED'}},
          {Tasks: {status: 'IN_PROGRESS'}}
        ],
        e: {ret: 17, host: '17'},
        m: 'All types of status available. cluster status PENDING'
      },
      {
        cluster: {status: 'PENDING'},
        host: Em.Object.create({progress: 0}),
        actions: [],
        e: {ret: 33, host: '33'},
        m: 'No tasks available. cluster status PENDING'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({progress: 0}),
        actions: [],
        e: {ret: 100, host: '100'},
        m: 'No tasks available. cluster status INSTALLED'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({progress: 0}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'QUEUED'}},
          {Tasks: {status: 'QUEUED'}},
          {Tasks: {status: 'IN_PROGRESS'}}
        ],
        e: {ret: 68, host: '68'},
        m: 'All types of status available. cluster status INSTALLED'
      },
      {
        cluster: {status: 'FAILED'},
        host: Em.Object.create({progress: 0}),
        actions: [],
        e: {ret: 100, host: '100'},
        m: 'Cluster status is not PENDING or INSTALLED'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        var controller = App.WizardStep9Controller.create({content: {cluster: {status: test.cluster.status}}});
        var progress = controller.progressPerHost(test.actions, test.host);
        expect(progress).to.equal(test.e.ret);
        expect(test.host.progress).to.equal(test.e.host);
      });
    });
  });

  describe('#clearStep', function () {
    var controller = App.WizardStep9Controller.create({hosts: [
      {},
      {},
      {}
    ]});
    it('All to default values', function () {
      controller.clearStep();
      expect(controller.get('hosts.length')).to.equal(0);
      expect(controller.get('status')).to.equal('info');
      expect(controller.get('progress')).to.equal('0');
      expect(controller.get('numPolls')).to.equal(1);
    });
  });

  describe('#replacePolledData', function () {
    var controller = App.WizardStep9Controller.create({polledData: [
      {},
      {},
      {}
    ]});
    var newPolledData = [
      {}
    ];
    controller.replacePolledData(newPolledData);
    it('replacing polled data', function () {
      expect(controller.get('polledData.length')).to.equal(newPolledData.length);
    });
  });

  describe('#isSuccess', function () {
    var tests = Em.A([
      {
        polledData: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: true,
        m: 'All tasks are COMPLETED'
      },
      {
        polledData: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'FAILED'}}
        ],
        e: false,
        m: 'Not all tasks are COMPLETED'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        var controller = App.WizardStep9Controller.create();
        expect(controller.isSuccess(test.polledData)).to.equal(test.e);
      });
    });
  });

  describe('#isStepFailed', function () {
    var tests = Em.A([
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'FAILED'}},
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'PENDING'}}
        ],
        e: true,
        m: 'GANGLIA_MONITOR 2/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'PENDING'}}
        ],
        e: false,
        m: 'GANGLIA_MONITOR 1/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'FAILED'}},
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'PENDING'}}
        ],
        e: true,
        m: 'HBASE_REGIONSERVER 2/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'PENDING'}}
        ],
        e: false,
        m: 'HBASE_REGIONSERVER 1/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'FAILED'}},
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'PENDING'}}
        ],
        e: true,
        m: 'TASKTRACKER 2/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'PENDING'}}
        ],
        e: false,
        m: 'TASKTRACKER 1/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'FAILED'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}}
        ],
        e: true,
        m: 'DATANODE 2/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}}
        ],
        e: false,
        m: 'DATANODE 1/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'NAMENODE', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}}
        ],
        e: true,
        m: 'NAMENODE failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'NAMENODE', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}}
        ],
        e: false,
        m: 'Nothing failed failed'
      }
    ]);
    tests.forEach(function (test) {
      var controller = App.WizardStep9Controller.create({polledData: test.polledData});
      it(test.m, function () {
        expect(controller.isStepFailed()).to.equal(test.e);
      });
    });
  });

  describe('#finishState', function () {
    var statuses = Em.A(['INSTALL FAILED', 'START FAILED', 'STARTED']);
    it('Installer is finished', function () {
      statuses.forEach(function (status) {
        var controller = App.WizardStep9Controller.create({content: {cluster: {status: status}}});
        var result = controller.finishState();
        expect(result).to.equal(true);
      });
    });
    it('Unknown cluster status ', function () {
      var controller = App.WizardStep9Controller.create({content: {cluster: {status: 'FAKE_STATUS'}}});
      var result = controller.finishState();
      expect(result).to.equal(false);
    });
    it('for INSTALLED status should call isServicesStarted', function () {
      sinon.stub(c, 'togglePreviousSteps', Em.K);
      c.set('content', {cluster: {status: 'INSTALLED'}});
      var polledData = {'{}': {}};
      sinon.stub(c, 'isServicesStarted', Em.K);
      c.finishState(polledData);
      expect(c.isServicesStarted.calledWith(polledData)).to.equal(true);
      c.isServicesStarted.restore();
      c.togglePreviousSteps.restore();
    });
    it('for PENDING status should call isServicesInstalled', function () {
      sinon.stub(c, 'togglePreviousSteps', Em.K);
      c.set('content', {cluster: {status: 'PENDING'}});
      var polledData = {'{}': {}};
      sinon.stub(c, 'isServicesInstalled', Em.K);
      c.finishState(polledData);
      expect(c.isServicesInstalled.calledWith(polledData)).to.equal(true);
      c.isServicesInstalled.restore();
      c.togglePreviousSteps.restore();
    });
  });

  describe('#setLogTasksStatePerHost', function () {
    var tests = Em.A([
      {
        tasksPerHost: [
          {Tasks: {id: 1, status: 'COMPLETED'}},
          {Tasks: {id: 2, status: 'COMPLETED'}}
        ],
        tasks: [],
        e: {m: 'COMPLETED', l: 2},
        m: 'host didn\'t have tasks and got 2 new'
      },
      {
        tasksPerHost: [
          {Tasks: {id: 1, status: 'COMPLETED'}},
          {Tasks: {id: 2, status: 'COMPLETED'}}
        ],
        tasks: [
          {Tasks: {id: 1, status: 'IN_PROGRESS'}},
          {Tasks: {id: 2, status: 'IN_PROGRESS'}}
        ],
        e: {m: 'COMPLETED', l: 2},
        m: 'host had 2 tasks and got both updated'
      },
      {
        tasksPerHost: [],
        tasks: [
          {Tasks: {id: 1, status: 'IN_PROGRESS'}},
          {Tasks: {id: 2, status: 'IN_PROGRESS'}}
        ],
        e: {m: 'IN_PROGRESS', l: 2},
        m: 'host had 2 tasks and didn\'t get updates'
      },
      {
        tasksPerHost: [
          {Tasks: {id: 1, status: 'COMPLETED'}},
          {Tasks: {id: 2, status: 'COMPLETED'}},
          {Tasks: {id: 3, status: 'COMPLETED'}}
        ],
        tasks: [
          {Tasks: {id: 1, status: 'IN_PROGRESS'}},
          {Tasks: {id: 2, status: 'IN_PROGRESS'}}
        ],
        e: {m: 'COMPLETED', l: 3},
        m: 'host had 2 tasks and got both updated and 1 new'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        var controller = App.WizardStep9Controller.create({hosts: [Em.Object.create({logTasks: test.tasks})]});
        controller.setLogTasksStatePerHost(test.tasksPerHost, controller.get('hosts')[0]);
        expect(controller.get('hosts')[0].get('logTasks').everyProperty('Tasks.status', test.e.m)).to.equal(true);
        expect(controller.get('hosts')[0].get('logTasks.length')).to.equal(test.e.l);
      });
    });
  });

  describe('#parseHostInfo', function () {

    var tests = Em.A([
      {
        cluster: {status: 'PENDING'},
        hosts: Em.A([
          Em.Object.create({name: 'host1', status: '', message: '', progress: '', logTasks: []}),
          Em.Object.create({name: 'host2', status: '', message: '', progress: '', logTasks: []})
        ]),
        polledData: {
          tasks: [
            {Tasks: {host_name: 'host2', status: 'COMPLETED'}},
            {Tasks: {host_name: 'host2', status: 'COMPLETED'}}
          ]
        },
        e: {
          hosts: {
            host1: {progress: '33'},
            host2: {progress: '33'}
          },
          progress: '33'
        },
        m: 'Two hosts. One host without tasks. Second host has all tasks COMPLETED. Cluster status is PENDING'
      },
      {
        cluster: {status: 'PENDING'},
        hosts: Em.A([
          Em.Object.create({name: 'host1', status: '', message: '', progress: '', logTasks: []}),
          Em.Object.create({name: 'host2', status: '', message: '', progress: '', logTasks: []})
        ]),
        polledData: {
          tasks: [
            {Tasks: {host_name: 'host1', status: 'IN_PROGRESS'}},
            {Tasks: {host_name: 'host2', status: 'IN_PROGRESS'}}
          ]
        },
        e: {hosts: {host1: {progress: '12'}, host2: {progress: '12'}}, progress: '12'},
        m: 'Two hosts. Each host has one task IN_PROGRESS. Cluster status is PENDING'
      },
      {
        cluster: {status: 'PENDING'},
        hosts: Em.A([
          Em.Object.create({name: 'host1', status: '', message: '', progress: '', logTasks: []}),
          Em.Object.create({name: 'host2', status: '', message: '', progress: '', logTasks: []})
        ]),
        polledData: {
          tasks: [
            {Tasks: {host_name: 'host1', status: 'QUEUED'}},
            {Tasks: {host_name: 'host2', status: 'QUEUED'}}
          ]
        },
        e: {
          hosts: {
            host1: {progress: '3'},
            host2: {progress: '3'}
          },
          progress: '3'
        },
        m: 'Two hosts. Each host has one task QUEUED. Cluster status is PENDING'
      },
      {
        cluster: {status: 'INSTALLED'},
        hosts: Em.A([
          Em.Object.create({name: 'host1', status: '', message: '', progress: '', logTasks: []}),
          Em.Object.create({name: 'host2', status: '', message: '', progress: '', logTasks: []})
        ]),
        polledData: {
          tasks: [
            {Tasks: {host_name: 'host2', status: 'COMPLETED'}},
            {Tasks: {host_name: 'host2', status: 'COMPLETED'}}
          ]
        },
        e: {
          hosts: {
            host1: {progress: '100'},
            host2: {progress: '100'}
          },
          progress: '100'
        },
        m: 'Two hosts. One host without tasks. Second host has all tasks COMPLETED. Cluster status is INSTALLED'
      },
      {
        cluster: {status: 'INSTALLED'},
        hosts: Em.A([
          Em.Object.create({name: 'host1', status: '', message: '', progress: '', logTasks: []}),
          Em.Object.create({name: 'host2', status: '', message: '', progress: '', logTasks: []})
        ]),
        polledData: {
          tasks: [
            {Tasks: {host_name: 'host1', status: 'IN_PROGRESS'}},
            {Tasks: {host_name: 'host2', status: 'IN_PROGRESS'}}
          ]
        },
        e: {
          hosts: {
            host1: {progress: '58'},
            host2: {progress: '58'}
          },
          progress: '58'
        },
        m: 'Two hosts. Each host has one task IN_PROGRESS. Cluster status is INSTALLED'
      },
      {
        cluster: {status: 'INSTALLED'},
        hosts: Em.A([
          Em.Object.create({name: 'host1', status: '', message: '', progress: '', logTasks: []}),
          Em.Object.create({name: 'host2', status: '', message: '', progress: '', logTasks: []})
        ]),
        polledData: {
          tasks: [
            {Tasks: {host_name: 'host1', status: 'QUEUED'}},
            {Tasks: {host_name: 'host2', status: 'QUEUED'}}
          ]
        },
        e: {
          hosts: {
            host1: {progress: '40'},
            host2: {progress: '40'}
          },
          progress: '40'
        },
        m: 'Two hosts. Each host has one task QUEUED. Cluster status is INSTALLED'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        var controller = App.WizardStep9Controller.create({hosts: test.hosts, content: {cluster: {status: test.cluster.status}}, finishState: function () {
          return false;
        }});
        var logTasksChangesCounter = controller.get('logTasksChangesCounter');
        controller.parseHostInfo(test.polledData);
        expect(controller.get('logTasksChangesCounter')).to.equal(logTasksChangesCounter + 1);
        for (var name in test.e.hosts) {
          if (test.e.hosts.hasOwnProperty(name)) {
            expect(controller.get('hosts').findProperty('name', name).get('progress')).to.equal(test.e.hosts[name].progress);
          }
        }
        expect(controller.get('progress')).to.equal(test.e.progress);
      });
    });
    it('shouldn\'t do nothing if polledData.Requests.id != requestId', function () {
      sinon.stub(c, 'togglePreviousSteps', Em.K);
      c.set('content', {cluster: {requestId: 1}});
      var polledData = {Requests: {id: 2}, tasks: []};
      sinon.spy(c, 'finishState');
      expect(c.parseHostInfo(polledData)).to.equal(false);
      expect(c.finishState.called).to.equal(false);
      c.finishState.restore();
      c.togglePreviousSteps.restore();
    });
  });

  describe('#isAllComponentsInstalledSuccessCallback', function () {

    describe('', function () {
      var hosts = Em.A([
        Em.Object.create({name: 'host1', status: 'failed', expectedStatus: 'heartbeat_lost'}),
        Em.Object.create({name: 'host2', status: 'info', expectedStatus: 'heartbeat_lost'}),
        Em.Object.create({name: 'host3', status: 'warning', expectedStatus: 'warning'}),
        Em.Object.create({name: 'host4', status: 'info', expectedStatus: 'info'})
      ]);
      var heartbeatLostData = {
        "items": [
          {
            "Hosts": {
              "cluster_name": "c1",
              "host_name": "host1",
              "host_state": "HEARTBEAT_LOST"
            },
            "host_components": [
              {
                "HostRoles": {
                  "cluster_name": "c1",
                  "component_name": "NAMENODE",
                  "host_name": "host1",
                  "state": "INSTALL_FAILED"
                }
              }
            ]
          },
          {
            "Hosts": {
              "cluster_name": "c1",
              "host_name": "host2",
              "host_state": "HEARTBEAT_LOST"
            },
            "host_components": [
              {
                "HostRoles": {
                  "cluster_name": "c1",
                  "component_name": "ZOOKEEPER_SERVER",
                  "host_name": "host2",
                  "state": "UNKNOWN"
                }
              }
            ]
          },
          {
            "Hosts": {
              "cluster_name": "c1",
              "host_name": "host3",
              "host_state": "HEALTHY"
            },
            "host_components": [
              {
                "HostRoles": {
                  "cluster_name": "c1",
                  "component_name": "DATANODE",
                  "host_name": "host3",
                  "state": "INSTALL_FAILED"
                }
              }
            ]
          },
          {
            "Hosts": {
              "cluster_name": "c1",
              "host_name": "host4",
              "host_state": "HEALTHY"
            },
            "host_components": [
              {
                "HostRoles": {
                  "cluster_name": "c1",
                  "component_name": "PIG",
                  "host_name": "host4",
                  "state": "INSTALLED"
                }
              },
              {
                "HostRoles": {
                  "cluster_name": "c1",
                  "component_name": "DATANODE",
                  "host_name": "host3",
                  "state": "INSTALLED"
                }
              }
            ]
          }
        ]
      };

      var controller = App.WizardStep9Controller.create({hosts: hosts, content: {controllerName: 'installerController'}});

      App.testMode = true;
      // Action
      controller.isAllComponentsInstalledSuccessCallback(heartbeatLostData);


      // Validation  for the status of all hosts.
      controller.get('hosts').forEach(function (test) {
        var status = heartbeatLostData.items.findProperty('Hosts.host_name', test.get('name')).Hosts.host_state;
        it('Host "' + test.get('name') + '"' + ' with status "' + status + '" ', function () {
          expect(test.get('status')).to.equal(test.get('expectedStatus'));
        });
      });

    });

    describe('', function () {
      var noHeartbeatLostData = {
        "items": [
          {
            "Hosts": {
              "cluster_name": "c1",
              "host_name": "host1",
              "host_state": "HEALTHY"
            },
            "host_components": [
              {
                "HostRoles": {
                  "cluster_name": "c1",
                  "component_name": "NAMENODE",
                  "host_name": "host1",
                  "state": "INSTALL_FAILED"
                }
              }
            ]
          }
        ]
      };

      var hosts = Em.A([Em.Object.create({name: 'host1', status: 'failed'})]);
      // When there is no heartbeat lost for any host and cluster failed install task, Refreshing the page should not launch start all services request.
      // Below transitions are possibilities in this function
      // PENDING -> INSTALL or PENDING. This transition happens when install all services request is completed successfully.
      // INSTALL FAILED -> INSTALL FAILED. No transition should happen when install all services request fails and then user hits refresh
      // Cluster is not expected to enter this function in other states: INSTALLED, START FAILED, STARTED

      var statuses = Em.A(['INSTALL FAILED', 'INSTALLED', 'START FAILED', 'STARTED']);  // Cluster in any of this states should have no effect on the state from this function
      statuses.forEach(function (priorStatus) {
        var controller = App.WizardStep9Controller.create({hosts: hosts, content: {controllerName: 'installerController', cluster: {status: priorStatus}}, togglePreviousSteps: function () {
        }});
        // Action
        controller.isAllComponentsInstalledSuccessCallback(noHeartbeatLostData);
        // Validation for the cluster state.
        var actualStatus = controller.get('content.cluster.status');
        it('Cluster state before entering the function "' + priorStatus + '"', function () {
          expect(actualStatus).to.equal(priorStatus);
        });
      });
    });
  });

  // isServicesInstalled is called after every poll for "Install All Services" request.
  // This function should result into a call to "Start All Services" request only if install request completed successfully.
  describe('#isServicesInstalled', function () {

    var hostStateJsonData = {
      "items": [
        {
          "Hosts": {
            "cluster_name": "c1",
            "host_name": "ambari-1.c.apache.internal",
            "host_state": "HEALTHY"
          },
          "host_components": [
            {
              "HostRoles": {
                "cluster_name": "c1",
                "component_name": "GANGLIA_MONITOR",
                "host_name": "ambari-1.c.apache.internal",
                "state": "STARTED"
              }
            }
          ]
        }
      ]
    };
    var hosts = Em.A([Em.Object.create({name: 'host1', progress: '33', status: 'info'}),
      Em.Object.create({name: 'host2', progress: '33', status: 'info'})]);
    // polledData has all hosts with status completed to trigger transition from install->start request.
    var polledData = Em.A([Em.Object.create({Tasks: {name: 'host1', status: 'COMPLETED'}}),
      Em.Object.create({Tasks: {name: 'host2', status: 'COMPLETED'}})]);
    var controller = App.WizardStep9Controller.create({hosts: hosts, content: {controllerName: 'installerController',
      cluster: {status: 'PENDING', name: 'c1'}}, launchStartServices: function () {
      return true;
    }});
    var tests = Em.A([
      // controller has "status" value as "info" initially. If no errors are encountered then wizard stages
      // transition info->success, on error info->error, on warning info->warning
      {status: 'info', e: {startServicesCalled: true}, m: 'If no failed tasks then start services request should be called'},
      {status: 'failed', e: {startServicesCalled: false}, m: 'If install request has failed tasks then start services call should not be called'}
    ]);

    beforeEach(function () {
      App.testMode = true;
      sinon.spy(controller, 'launchStartServices');
      sinon.stub($, 'ajax').yieldsTo('success', hostStateJsonData);
    });

    afterEach(function () {
      App.testMode = false;
      controller.launchStartServices.restore();
      $.ajax.restore();
    });

    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('status', test.status);
        //Action
        controller.isServicesInstalled(polledData);
        //Validation
        expect(controller.launchStartServices.called).to.equal(test.e.startServicesCalled);
      });
    });
  });

  // On completion of Start all services error callback function,
  // Cluster Status should be INSTALL FAILED
  // All progress bar on the screen should be finished (100%) with blue color.
  // Retry button should be enabled, next button should be disabled

  describe('#launchStartServicesErrorCallback', function () {
    App.testMode = true;
    // override the actual function
    App.popup = {
      setErrorPopup: function () {
        return true;
      }
    };
    var hosts = Em.A([Em.Object.create({name: 'host1', progress: '33', status: 'info'}), Em.Object.create({name: 'host2', progress: '33', status: 'info'})]);
    var controller = App.WizardStep9Controller.create({hosts: hosts, content: {controllerName: 'installerController', cluster: {status: 'PENDING', name: 'c1'}}, togglePreviousSteps: function () {
    }});

    //Action
    controller.launchStartServicesErrorCallback({status: 500, statusTesxt: 'Server Error'}, {}, '', {});
    it('Cluster Status should be INSTALL FAILED', function () {
      expect(controller.get('content.cluster.status')).to.equal('INSTALL FAILED');
    });

    it('Main progress bar on the screen should be finished (100%) with red color', function () {
      expect(controller.get('progress')).to.equal('100');
      expect(controller.get('status')).to.equal('failed');
    });

    it('All Host progress bars on the screen should be finished (100%) with blue color', function () {
      controller.get('hosts').forEach(function (host) {
        expect(host.get('progress')).to.equal('100');
        expect(host.get('status')).to.equal('info');
      });
    });

    it('Next button should be disabled', function () {
      expect(controller.get('isSubmitDisabled')).to.equal(true);
    });

    it('Retry button should be visible', function () {
      expect(controller.get('showRetry')).to.equal(true);
    })

  });

  describe('#submit', function () {
    it('should call App.router.send', function () {
      sinon.stub(App.router, 'send', Em.K);
      c.submit();
      expect(App.router.send.calledWith('next')).to.equal(true);
      App.router.send.restore();
    });
  });

  describe('#back', function () {
    beforeEach(function () {
      sinon.stub(App.router, 'send', Em.K);
    });
    afterEach(function () {
      App.router.send.restore();
    });
    it('should call App.router.send', function () {
      c.reopen({isSubmitDisabled: false});
      c.back();
      expect(App.router.send.calledWith('back')).to.equal(true);
    });
    it('shouldn\'t call App.router.send', function () {
      c.reopen({isSubmitDisabled: true});
      c.back();
      expect(App.router.send.called).to.equal(false);
    });
  });

  describe('#loadStep', function () {
    beforeEach(function () {
      sinon.stub(c, 'clearStep', Em.K);
      sinon.stub(c, 'loadHosts', Em.K);
    });
    afterEach(function () {
      c.clearStep.restore();
      c.loadHosts.restore();
    });
    it('should call clearStep', function () {
      c.loadStep();
      expect(c.clearStep.calledOnce).to.equal(true);
    });
    it('should call loadHosts', function () {
      c.loadStep();
      expect(c.loadHosts.calledOnce).to.equal(true);
    });
  });

  describe('#startPolling', function () {
    beforeEach(function () {
      sinon.stub(c, 'getLogsByRequestErrorCallback', Em.K);
    });
    afterEach(function () {
      c.getLogsByRequestErrorCallback.restore();
    });
    it('should set isSubmitDisabled to true', function () {
      c.set('isSubmitDisabled', false);
      c.startPolling();
      expect(c.get('isSubmitDisabled')).to.equal(true);
    });
    it('should call doPolling', function () {
      sinon.stub(c, 'doPolling', Em.K);
      c.startPolling();
      expect(c.doPolling.calledOnce).to.equal(true);
      c.doPolling.restore();
    });
  });

  describe('#loadLogData', function () {
    beforeEach(function () {
      sinon.stub(c, 'getLogsByRequest', Em.K);
      c.set('wizardController', Em.Object.create({
        cluster: {oldRequestsId: []},
        getDBProperty: function (name) {
          return this.get(name);
        }
      }));
    });
    afterEach(function () {
      c.getLogsByRequest.restore();
    });
    it('shouldn\'t call getLogsByRequest if no requestIds', function () {
      c.set('wizardController.cluster.oldRequestsId', []);
      c.loadLogData();
      expect(c.getLogsByRequest.called).to.equal(false);
    });
    it('should call getLogsByRequest 3 times', function () {
      c.set('wizardController.cluster.oldRequestsId', [1, 2, 3]);
      c.loadLogData();
      expect(c.getLogsByRequest.calledThrice).to.equal(true);
    });
    it('should set POLL_INTERVAL to 1 if testMode enabled', function () {
      App.set('testMode', true);
      c.set('wizardController.cluster.oldRequestsId', [1, 2, 3]);
      c.loadLogData();
      expect(c.get('POLL_INTERVAL')).to.equal(1);
      App.set('testMode', false);
    });
  });

  describe('#loadCurrentTaskLog', function () {
    beforeEach(function () {
      sinon.spy(App.ajax, 'send');
    });
    afterEach(function () {
      App.ajax.send.restore();
    });
    it('shouldn\'t call App.ajax.send if no currentOpenTaskId', function () {
      c.set('currentOpenTaskId', null);
      c.loadCurrentTaskLog();
      expect(App.ajax.send.called).to.equal(false);
    });
    it('should call App.ajax.send with provided data', function () {
      sinon.stub(c, 'togglePreviousSteps', Em.K);
      c.set('currentOpenTaskId', 1);
      c.set('currentOpenTaskRequestId', 2);
      c.set('content', {cluster: {name: 3}});
      c.loadCurrentTaskLog();
      expect(App.ajax.send.args[0][0].data).to.eql({taskId: 1, requestId: 2, clusterName: 3, sync: true});
      c.togglePreviousSteps.restore();
    });
  });

  describe('#loadCurrentTaskLogSuccessCallback', function () {
    it('should increment logTasksChangesCounter', function () {
      c.set('logTasksChangesCounter', 0);
      c.loadCurrentTaskLogSuccessCallback();
      expect(c.get('logTasksChangesCounter')).to.equal(1);
    });
    it('should update stdout, stderr', function () {
      c.set('currentOpenTaskId', 1);
      c.reopen({
        hosts: [
          Em.Object.create({
            name: 'h1',
            logTasks: [
              {Tasks: {id: 1, stdout: '', stderr: ''}}
            ]
          })
        ]
      });
      var data = {Tasks: {host_name: 'h1', id: 1, stderr: 'stderr', stdout: 'stdout'}};
      c.loadCurrentTaskLogSuccessCallback(data);
      var t = c.get('hosts')[0].logTasks[0].Tasks;
      expect(t.stdout).to.equal('stdout');
      expect(t.stderr).to.equal('stderr');
    });
    it('shouldn\'t update stdout, stderr', function () {
      c.set('currentOpenTaskId', 1);
      c.reopen({
        hosts: [
          Em.Object.create({
            name: 'h1',
            logTasks: [
              {Tasks: {id: 2, stdout: '', stderr: ''}}
            ]
          })
        ]
      });
      var data = {Tasks: {host_name: 'h1', id: 1, stderr: 'stderr', stdout: 'stdout'}};
      c.loadCurrentTaskLogSuccessCallback(data);
      var t = c.get('hosts')[0].logTasks[0].Tasks;
      expect(t.stdout).to.equal('');
      expect(t.stderr).to.equal('');
    });
    it('shouldn\'t update stdout, stderr (2)', function () {
      c.set('currentOpenTaskId', 1);
      c.reopen({
        hosts: [
          Em.Object.create({
            name: 'h2',
            logTasks: [
              {Tasks: {id: 1, stdout: '', stderr: ''}}
            ]
          })
        ]
      });
      var data = {Tasks: {host_name: 'h1', id: 1, stderr: 'stderr', stdout: 'stdout'}};
      c.loadCurrentTaskLogSuccessCallback(data);
      var t = c.get('hosts')[0].logTasks[0].Tasks;
      expect(t.stdout).to.equal('');
      expect(t.stderr).to.equal('');
    });
  });

  describe('#loadCurrentTaskLogErrorCallback', function () {
    it('should set currentOpenTaskId to 0', function () {
      c.set('currentOpenTaskId', 123);
      c.loadCurrentTaskLogErrorCallback();
      expect(c.get('currentOpenTaskId')).to.equal(0);
    });
  });

  describe('#getLogsByRequest', function () {
    beforeEach(function () {
      sinon.spy(App.ajax, 'send');
      sinon.stub(c, 'togglePreviousSteps', Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
      c.togglePreviousSteps.restore();
    });
    it('should call App.ajax.send with provided data', function () {
      var polling = 1;
      var requestId = 2;
      c.set('content', {cluster: {name: 3}});
      c.set('numPolls', 4);
      c.getLogsByRequest(polling, requestId);
      expect(App.ajax.send.args[0][0].data).to.eql({polling: polling, requestId: requestId, cluster: 3, numPolls: 4});
    });
  });

  describe('#doPolling', function () {
    beforeEach(function () {
      sinon.stub(c, 'getLogsByRequest', Em.K);
      sinon.stub(c, 'togglePreviousSteps', Em.K);
    });
    afterEach(function () {
      c.getLogsByRequest.restore();
      c.togglePreviousSteps.restore();
    });
    it('should increment numPolls if testMode', function () {
      App.set('testMode', true);
      c.set('numPolls', 0);
      c.doPolling();
      expect(c.get('numPolls')).to.equal(1);
      App.set('testMode', false);
    });
    it('should call getLogsByRequest', function () {
      c.set('content', {cluster: {requestId: 1}});
      c.doPolling();
      expect(c.getLogsByRequest.calledWith(true, 1)).to.equal(true);
    });
  });

  describe('#isAllComponentsInstalled', function () {
    beforeEach(function () {
      sinon.spy(App.ajax, 'send');
      sinon.stub(c, 'togglePreviousSteps', Em.K);
      sinon.stub(c, 'saveClusterStatus', Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
      c.togglePreviousSteps.restore();
      c.saveClusterStatus.restore();
    });
    it('shouldn\'t call App.ajax.send', function () {
      c.set('content', {controllerName: 'addServiceController'});
      c.isAllComponentsInstalled();
      expect(App.ajax.send.called).to.equal(false);
    });
    it('shouldn\'t call App.ajax.send (2)', function () {
      c.set('content', {controllerName: 'addHostController'});
      c.isAllComponentsInstalled();
      expect(App.ajax.send.called).to.equal(false);
    });
    it('should call App.ajax.send', function () {
      c.set('content', {cluster: {name: 'n'}, controllerName: 'installerController'});
      c.isAllComponentsInstalled();
      expect(App.ajax.send.args[0][0].data).to.eql({cluster: 'n'});
    });
  });

  describe('#isAllComponentsInstalledErrorCallback', function () {
    beforeEach(function () {
      sinon.stub(c, 'saveClusterStatus', Em.K);
      sinon.stub(c, 'togglePreviousSteps', Em.K);
    });
    afterEach(function () {
      c.saveClusterStatus.restore();
      c.togglePreviousSteps.restore();
    });
    it('should call saveClusterStatus', function () {
      c.isAllComponentsInstalledErrorCallback({});
      expect(c.saveClusterStatus.calledOnce).to.equal(true);
    });
  });

  describe('#saveClusterStatus', function () {
    beforeEach(function () {
      sinon.stub(c, 'togglePreviousSteps', Em.K);
    });
    afterEach(function () {
      c.togglePreviousSteps.restore();
    });
    it('in testMode should set content.cluster', function () {
      var d = {n: 'n'};
      c.set('content', {cluster: ''});
      App.set('testMode', true);
      c.saveClusterStatus(d);
      expect(c.get('content.cluster')).to.eql(d);
      App.set('testMode', false);
    });
    it('if testMode is false should use content.controller', function () {
      var d = {n: 'n'},
        obj = Em.Object.create({
          saveClusterStatus: Em.K
        });
      sinon.stub(App.router, 'get', function () {
        return obj;
      });
      sinon.spy(obj, 'saveClusterStatus');
      c.set('content', {cluster: ''});
      App.set('testMode', false);
      c.saveClusterStatus(d);
      expect(obj.saveClusterStatus.calledWith(d)).to.eql(true);
      App.set('testMode', true);
      obj.saveClusterStatus.restore();
      App.router.get.restore();
    });
  });

  describe('#saveInstalledHosts', function () {
    beforeEach(function () {
      sinon.stub(c, 'togglePreviousSteps', Em.K);
    });
    afterEach(function () {
      c.togglePreviousSteps.restore();
    });
    it('if testMode is false should use content.controller', function () {
      var d = {n: 'n'},
        obj = Em.Object.create({
          saveInstalledHosts: Em.K
        });
      sinon.stub(App.router, 'get', function () {
        return obj;
      });
      sinon.spy(obj, 'saveInstalledHosts');
      c.set('content', {cluster: ''});
      App.set('testMode', false);
      c.saveInstalledHosts(d);
      expect(obj.saveInstalledHosts.calledWith(d)).to.eql(true);
      App.set('testMode', true);
      obj.saveInstalledHosts.restore();
      App.router.get.restore();
    });
  });

  describe('#getComponentMessage', function () {
    var tests = Em.A([
      {
        clients: ['c1'],
        m: 'One client',
        e: 'c1'
      },
      {
        clients: ['c1', 'c2'],
        m: 'Two clients',
        e: 'c1 and c2'
      },
      {
        clients: ['c1', 'c2', 'c3'],
        m: 'Three clients',
        e: 'c1, c2 and c3'
      },
      {
        clients: ['c1', 'c2', 'c3', 'c4'],
        m: 'Four clients',
        e: 'c1, c2, c3 and c4'
      },
      {
        clients: ['c1', 'c2', 'c3', 'c4', 'c5'],
        m: 'Five clients',
        e: 'c1, c2, c3, c4 and c5'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        var label = c.getComponentMessage(test.clients);
        expect(label).to.equal(test.e);
      });
    });
  });

  describe('#togglePreviousSteps', function () {
    beforeEach(function () {
      sinon.stub(obj, 'setStepsEnable', Em.K);
      sinon.stub(obj, 'setLowerStepsDisable', Em.K);
      sinon.stub(App.router, 'get', function () {
        return obj;
      });
    });
    afterEach(function () {
      App.router.get.restore();
      obj.setStepsEnable.restore();
      obj.setLowerStepsDisable.restore();
    });
    it('shouldn\'t do nothing on testMode', function () {
      App.set('testMode', true);
      c.togglePreviousSteps();
      expect(App.router.get.called).to.equal(false);
      App.set('testMode', false);
    });
    Em.A([
        {
          status: 'INSTALL FAILED',
          controllerName: 'installerController',
          e: {
            setStepsEnable: true,
            setLowerStepsDisable: false
          }
        },
        {
          status: 'STARTED',
          controllerName: 'installerController',
          e: {
            setStepsEnable: false,
            setLowerStepsDisable: true
          }
        },
        {
          status: 'INSTALL FAILED',
          controllerName: 'addServiceController',
          e: {
            setStepsEnable: false,
            setLowerStepsDisable: true
          }
        },
        {
          status: 'STARTED',
          controllerName: 'addServiceController',
          e: {
            setStepsEnable: false,
            setLowerStepsDisable: true
          }
        }
      ]).forEach(function (test) {
        it(test.status + ' ' + test.controllerName, function () {
          App.set('testMode', false);
          c.reopen({content: {cluster: {status: test.status}, controllerName: test.controllerName}});
          c.togglePreviousSteps();
          expect(App.router.get.calledWith('installerController')).to.equal(true);
          if (test.e.setStepsEnable) {
            expect(obj.setStepsEnable.calledOnce).to.equal(true);
          }
          else {
            expect(obj.setStepsEnable.called).to.equal(false);
          }
          if (test.e.setLowerStepsDisable) {
            expect(obj.setLowerStepsDisable.calledWith(9)).to.equal(true);
          }
          else {
            expect(obj.setLowerStepsDisable.called).to.equal(false);
          }
        });
      });
  });

  describe('#navigateStep', function () {
    beforeEach(function () {
      sinon.stub(c, 'togglePreviousSteps', Em.K);
      sinon.stub(c, 'loadStep', Em.K);
      sinon.stub(c, 'loadLogData', Em.K);
      sinon.stub(c, 'startPolling', Em.K);
    });
    afterEach(function () {
      c.togglePreviousSteps.restore();
      c.loadStep.restore();
      c.loadLogData.restore();
      c.startPolling.restore();
    });
    it('should set custom data in testMode', function () {
      App.set('testMode', true);
      c.reopen({content: {cluster: {status: 'st', isCompleted: true, requestId: 0}}});
      c.navigateStep();
      expect(c.get('content.cluster.status')).to.equal('PENDING');
      expect(c.get('content.cluster.isCompleted')).to.equal(false);
      expect(c.get('content.cluster.requestId')).to.equal(1);
      App.set('testMode', false);
    });
    it('isCompleted = true, requestId = 1', function () {
      App.set('testMode', false);
      c.reopen({content: {cluster: {isCompleted: true, requestId: 1}}});
      c.navigateStep();
      expect(c.loadStep.calledOnce).to.equal(true);
      expect(c.loadLogData.calledWith(1)).to.equal(true);
      expect(c.get('progress')).to.equal('100');
    });
    it('isCompleted = false, requestId = 1, status = INSTALL FAILED', function () {
      App.set('testMode', false);
      c.reopen({content: {cluster: {status: 'INSTALL FAILED', isCompleted: false, requestId: 1}}});
      c.navigateStep();
      expect(c.loadStep.calledOnce).to.equal(true);
      expect(c.loadLogData.calledWith(1)).to.equal(true);
    });
    it('isCompleted = false, requestId = 1, status = START FAILED', function () {
      App.set('testMode', false);
      c.reopen({content: {cluster: {status: 'START FAILED', isCompleted: false, requestId: 1}}});
      c.navigateStep();
      expect(c.loadStep.calledOnce).to.equal(true);
      expect(c.loadLogData.calledWith(1)).to.equal(true);
    });
    it('isCompleted = false, requestId = 1, status = OTHER', function () {
      App.set('testMode', false);
      c.reopen({content: {cluster: {status: 'STARTED', isCompleted: false, requestId: 1}}});
      c.navigateStep();
      expect(c.loadStep.calledOnce).to.equal(true);
      expect(c.loadLogData.calledWith(1)).to.equal(true);
      expect(c.startPolling.calledOnce).to.equal(true);
    });
  });

  describe('#launchStartServices', function () {
    beforeEach(function () {
      sinon.spy(App.ajax, 'send');
      sinon.stub(c, 'togglePreviousSteps', Em.K);
      sinon.stub(c, 'saveClusterStatus', Em.K);
      c.reopen({content: {}});
    });
    afterEach(function () {
      App.ajax.send.restore();
      c.togglePreviousSteps.restore();
      c.saveClusterStatus.restore();
    });
    it('should set numPolls to 6 in testMode', function () {
      App.set('testMode', true);
      c.set('numPolls', 0);
      c.launchStartServices();
      expect(c.get('numPolls')).to.equal(6);
      App.set('testMode', false);
    });
    Em.A([
        {
          controllerName: 'installerController',
          clusterName: 'c1',
          e: {
            name: 'wizard.step9.installer.launch_start_services'
          }
        },
        {
          controllerName: 'addHostController',
          clusterName: 'c1',
          wizardController: Em.Object.create({
            getDBProperty: function () {
              return {h1: '', h2: ''};
            }
          }),
          e: {
            name: 'wizard.step9.add_host.launch_start_services',
            data: 'host_name.in(h1,h2)'
          }
        }
      ]).forEach(function (test) {
        it(test.controllerName, function () {
          c.reopen({content: {controllerName: test.controllerName, cluster: {name: test.clusterName}}});
          if (test.wizardController) {
            c.reopen({wizardController: test.wizardController});
          }
          c.launchStartServices();
          var r = App.ajax.send.args[0][0];
          expect(r.data.cluster).to.equal(test.clusterName);
          expect(r.name).to.equal(test.e.name);
          if (test.e.data) {
            expect(r.data.data.contains(test.e.data)).to.equal(true);
          }
        });
      });
  });

  describe('#isServicesStarted', function () {
    beforeEach(function () {
      sinon.stub(c, 'saveClusterStatus', Em.K);
      sinon.stub(c, 'saveInstalledHosts', Em.K);
    });
    afterEach(function () {
      c.saveClusterStatus.restore();
      c.saveInstalledHosts.restore();
    });
    Em.A([
        {
          polledData: [
            {Tasks: {status: 'PENDING'}}
          ],
          m: 'PENDING',
          e: false
        },
        {
          polledData: [
            {Tasks: {status: 'QUEUED'}}
          ],
          m: 'QUEUED',
          e: false
        },
        {
          polledData: [
            {Tasks: {status: 'IN_PROGRESS'}}
          ],
          m: 'IN_PROGRESS',
          e: false
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          var r = c.isServicesStarted(test.polledData);
          expect(r).to.equal(test.e);
        });
      });
    Em.A([
        {
          polledData: [
            {Tasks: {status: 'SUCCESS'}}
          ],
          m: 'tasks ok, isSuccess true',
          isSuccess: true,
          e: {
            status: 'STARTED',
            hasInstallTime: true
          }
        },
        {
          polledData: [
            {Tasks: {status: 'SUCCESS'}}
          ],
          m: 'tasks ok, isSuccess false',
          isSuccess: false,
          e: {
            status: 'START FAILED',
            hasInstallTime: false
          }
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          sinon.stub(c, 'isSuccess', function () {
            return test.isSuccess;
          });
          c.reopen({content: {cluster: {requestId: 2}}});
          var r = c.isServicesStarted(test.polledData);
          var args = c.saveClusterStatus.args[0][0];
          expect(r).to.equal(true);
          expect(c.get('progress')).to.equal('100');
          expect(args.status).to.equal(test.e.status);
          expect(args.requestId).to.equal(2);
          expect(args.hasOwnProperty('installTime')).to.equal(test.e.hasInstallTime);
          expect(args.isCompleted).to.equal(true);
          expect(c.saveInstalledHosts.calledOnce).to.equal(true);
          c.isSuccess.restore();
        });
      });
  });

  describe('#launchStartServicesSuccessCallback', function () {
    beforeEach(function () {
      sinon.stub(c, 'saveClusterStatus', Em.K);
      sinon.stub(c, 'doPolling', Em.K);
      sinon.stub(c, 'hostHasClientsOnly', Em.K);
    });
    afterEach(function () {
      c.saveClusterStatus.restore();
      c.doPolling.restore();
      c.hostHasClientsOnly.restore();
    });
    it('should call doPolling if some data were received', function () {
      c.launchStartServicesSuccessCallback({Requests: {id: 2}});
      expect(c.doPolling.calledOnce).to.equal(true);
    });
    Em.A([
        {
          jsonData: {Requests: {id: 2}},
          e: {
            hostHasClientsOnly: false,
            clusterStatus: {
              status: 'INSTALLED',
              requestId: 2,
              isStartError: false,
              isCompleted: false
            }
          }
        },
        {
          jsonData: null,
          e: {
            hostHasClientsOnly: true,
            clusterStatus: {
              status: 'STARTED',
              isStartError: false,
              isCompleted: true
            },
            status: 'success',
            progress: '100'
          }
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          c.launchStartServicesSuccessCallback(test.jsonData);
          expect(c.hostHasClientsOnly.calledWith(test.e.hostHasClientsOnly)).to.equal(true);
          expect(c.saveClusterStatus.calledWith(test.e.clusterStatus)).to.equal(true);
          if (test.e.status) {
            expect(c.get('status')).to.equal(test.e.status);
          }
          if (test.e.progress) {
            expect(c.get('progress')).to.equal(test.e.progress);
          }
        });
      });
  });

  describe('#getLogsByRequestSuccessCallback', function () {
    beforeEach(function () {
      sinon.stub(c, 'isAllComponentsInstalled', Em.K);
      sinon.stub(window, 'setTimeout', Em.K);
    });
    afterEach(function () {
      c.isAllComponentsInstalled.restore();
      window.setTimeout.restore();
    });
    Em.A([
        {
          polling: false,
          status: 'INSTALL FAILED',
          m: 'should call isAllComponentsInstalled',
          e: true
        },
        {
          polling: false,
          status: 'INSTALLED',
          m: 'shouldn\'t call isAllComponentsInstalled',
          e: false
        },
        {
          polling: true,
          status: 'INSTALL FAILED',
          m: 'shouldn\'t call isAllComponentsInstalled (2)',
          e: false
        },
        {
          polling: true,
          status: 'INSTALLED',
          m: 'shouldn\'t call isAllComponentsInstalled (3)',
          e: false
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          sinon.stub(c, 'parseHostInfo', Em.K);
          c.reopen({content: {cluster: {status: test.status}}});
          c.getLogsByRequestSuccessCallback({}, {}, {polling: test.polling});
          if (test.e) {
            expect(c.isAllComponentsInstalled.calledOnce).to.equal(true);
          }
          else {
            expect(c.isAllComponentsInstalled.called).to.equal(false);
          }
          c.parseHostInfo.restore();
        });
      });
  });

});
});

;require.register("test/controllers/wizard_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/cluster');
require('controllers/wizard');

describe('App.WizardController', function () {

  var wizardController = App.WizardController.create({});

  var totalSteps = 11;
  var ruller = [];
  for(var i = 0; i < totalSteps; i++) {
    ruller.push(i);
  }

  describe('#setLowerStepsDisable', function() {
    for(var i = 1; i < totalSteps; i++) {
      var indx = i;
      var steps = [];
      for(var j = 1; j <= indx; j++) {
        steps.push(Em.Object.create({step:j,value:false}));
      }
      wizardController.set('isStepDisabled', steps);
      for(j = 1; j <= indx; j++) {
        it('Steps: ' + i + ' | Disabled: ' + (j-1), function() {
          wizardController.setLowerStepsDisable(j);
          expect(wizardController.get('isStepDisabled').filterProperty('value', true).length).to.equal(j-1);
        });
      }
    }
  });

  // isStep0 ... isStep10 tests
  App.WizardController1 = App.WizardController.extend({currentStep:''});
  var tests = [];
  for(var i = 0; i < totalSteps; i++) {
    var n = ruller.slice(0);
    n.splice(i,1);
    tests.push({i:i,n:n});
  }
  tests.forEach(function(test) {
    describe('isStep'+test.i, function() {
      var w = App.WizardController1.create();
      w.set('currentStep', test.i);
      it('Current Step is ' + test.i + ', so isStep' + test.i + ' is TRUE', function() {
        expect(w.get('isStep'+ test.i)).to.equal(true);
      });
      test.n.forEach(function(indx) {
        it('Current Step is ' + test.i + ', so isStep' + indx + ' is FALSE', function() {
          expect(w.get('isStep'+ indx)).to.equal(false);
        });
      });
    });
  });
  // isStep0 ... isStep10 tests end

  describe('#gotoStep', function() {
    var w = App.WizardController1.create();
    var steps = [];
    for(var j = 0; j < totalSteps; j++) {
      steps.push(Em.Object.create({step:j,value:false}));
    }
    steps.forEach(function(step, index) {
      step.set('value', true);
      w.set('isStepDisabled', steps);
      it('step ' + index + ' is disabled, so gotoStep('+index+') is not possible', function() {
        expect(w.gotoStep(index)).to.equal(false);
      });
    });
  });

  describe('#launchBootstrapSuccessCallback', function() {
    it('Save bootstrapRequestId', function() {
      var data = {requestId: 123};
      var params = {popup: {finishLoading: function(){}}};
      sinon.spy(params.popup, "finishLoading");
      wizardController.launchBootstrapSuccessCallback(data, {}, params);
      expect(params.popup.finishLoading.calledWith(123)).to.be.true;
      params.popup.finishLoading.restore();
    });
  });

});

});

;require.register("test/data/HDP2/secure_mapping_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/helper');
var mappedProperties = require('data/HDP2/secure_mapping');

describe('hdp2SiteMapping', function () {

  // All mapped properties should have value of string type
  mappedProperties.forEach(function(mappedProperty){
    it('Value of "' + mappedProperty.name  + '"' + ' should be string', function () {
      expect(mappedProperty.value).to.be.a('string');
    });
  });
});
});

;require.register("test/data/HDP2/site_properties_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/helper');
var siteProperties = require('data/HDP2/site_properties').configProperties;

describe('hdp2SiteProperties', function () {


  //@TODO: log4j propeties should not be a part of site properties file. A separate file  should address this logic. site_properties.js should be used only to provide ui attributes to existing stack properties
  //Exclude log4j properties from unit tests for now
  siteProperties = siteProperties.filter(function(item, index){
    return !(item.filename && item.filename.endsWith('log4j.xml'));
  });
  // No site properties should be made invisible
  siteProperties.forEach(function(siteProperty){
    it('Check invisible attribute of "' + siteProperty.name  + '"' + '. It should not be defined ', function () {
      expect(siteProperty.isVisible).to.equal(undefined);
    });
  });

  // No site properties should have value and defaultValue defined on client side.
  // These should be always retrieved from server.

    siteProperties.forEach(function(siteProperty){
      it('Check value and defaultValue attribute of "' + siteProperty.name + '"' + '. It should not be defined ', function () {
        expect(siteProperty.value).to.equal(undefined);
        expect(siteProperty.defaultValue).to.equal(undefined);
    });
  });

  // No site properties should have description field duplicated on client side.
  // These should be always retrieved from server.
  siteProperties.forEach(function(siteProperty){
    it('Check description attribute of "' + siteProperty.name + '"' + '. It should not be defined ', function () {
      expect(siteProperty.description).to.equal(undefined);
    });
  });

  // All the site properties should be persisted in the configuration tag
  // So isRequiredByAgent should be never defined over here
  // These should be always retrieved from server and saved in the correct configuration resource via API.
  siteProperties.forEach(function(siteProperty){
    it('Check isRequiredByAgent attribute of "' + siteProperty.name + '"' + '. It should not be defined ', function () {
      expect(siteProperty.isRequiredByAgent).to.equal(undefined);
    });
  });

  // All Falcon site properties should be mapped to site file. There is a property with same name (*.domain)
  // in different site files of Falcon service

    var falconSiteProperties = siteProperties.filterProperty('serviceName','FALCON');
    falconSiteProperties.forEach(function(siteProperty){
      it('Check filename attribute for "' + siteProperty.name + '"' + ' property of Falcon service. It should be defined ', function () {
        expect(siteProperty).to.have.property('filename');
    });
  });

});
});

;require.register("test/init_model_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/stack_service_component');
require('mappers/server_data_mapper');
require('mappers/stack_service_component_mapper');

module.exports = {
  setupStackServiceComponent: function() {
    /**
     * initialization of App.StackServiceComponent model
     * @type {*}
     */
    var data = {items: Em.A([])};
    require('test/service_components').items.forEach(function(i) {
      i.serviceComponents.forEach(function(sc) {
        data.items.pushObject(sc.StackServiceComponents);
      });
    });
    App.stackServiceComponentMapper.map(data);
  },
  cleanStackServiceComponent: function(){
    App.StackServiceComponent.find().set('content',[]);
  },
  setupStackVersion: function(context, version) {
    context.prevStackVersion = App.get('currentStackVersion');
    App.set('currentStackVersion', version);
  },
  restoreStackVersion: function(context) {
    App.set('currentStackVersion', context.prevStackVersion);
  },
  configs: require('test/mock_data_setup/configs_mock_data'),
  /**
   * Delete record from DS.Store and set its stateManager to proper state
   * @param {DS.Model} record
   * @method deleteRecord
   */
  deleteRecord: function (record) {
    record.deleteRecord();
    record.get('stateManager').transitionTo('loading');
  }
};
});

;require.register("test/login_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('controllers/login_controller');

describe('App.LoginController', function () {

  var loginController = App.LoginController.create();

  describe('#validateCredentials()', function () {
    /*
    it('should return undefined if no username is present', function () {
      loginController.set('loginName', '');
      expect(loginController.validateCredentials()).to.equal(undefined);
    })
    it('should return undefined if no password is present', function () {
      loginController.set('password', '');
      expect(loginController.validateCredentials()).to.equal(undefined);
    })
    it('should return the user object with the specified username and password (dummy until actual integration)', function () {
      loginController.set('loginName', 'admin');
      loginController.set('password', 'admin');
      expect(loginController.validateCredentials().get('loginName'), 'admin');
    })
    */
  })
});

});

;require.register("test/mappers/hosts_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('models/host');
require('models/host_component');
require('mappers/server_data_mapper');
require('mappers/hosts_mapper');

describe('App.hostsMapper', function () {



});

});

;require.register("test/mappers/jobs_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('views/main/apps/item/dag_view');
require('mappers/server_data_mapper');
require('mappers/jobs_mapper');

describe('App.jobTimeLineMapper', function () {

  var test_input = {
    "map": [
      {
        "x": 1369394950,
        "y": 0
      },
      {
        "x": 1369394951,
        "y": 1
      },
      {
        "x": 1369394952,
        "y": 1
      },
      {
        "x": 1369394953,
        "y": 0
      }
    ],
    "shuffle": [
      {
        "x": 1369394950,
        "y": 0
      },
      {
        "x": 1369394951,
        "y": 0
      },
      {
        "x": 1369394952,
        "y": 1
      },
      {
        "x": 1369394953,
        "y": 1
      }
    ],
    "reduce": [
      {
        "x": 1369394950,
        "y": 0
      },
      {
        "x": 1369394951,
        "y": 0
      },
      {
        "x": 1369394952,
        "y": 0
      },
      {
        "x": 1369394953,
        "y": 0
      }
    ]
  };

  describe('#coordinatesModify()', function () {
    it('map', function() {
      var new_map = App.jobTimeLineMapper.coordinatesModify(test_input.map);
      expect(new_map.length).to.equal(6);

      expect(new_map[1].y).to.equal(new_map[0].y);
      expect(new_map[2].x).to.equal(new_map[1].x);

      expect(new_map[4].y).to.equal(new_map[5].y);
      expect(new_map[3].x).to.equal(new_map[4].x);
    });
    it('shuffle', function() {
      var new_shuffle = App.jobTimeLineMapper.coordinatesModify(test_input.shuffle);
      expect(new_shuffle.length).to.equal(6);

      expect(new_shuffle[2].y).to.equal(new_shuffle[1].y);
      expect(new_shuffle[3].x).to.equal(new_shuffle[2].x);

      expect(new_shuffle[3].y).to.equal(new_shuffle[4].y);
      expect(new_shuffle[4].x).to.equal(new_shuffle[5].x);
    });
    it('reduce', function() {
      var new_reduce = App.jobTimeLineMapper.coordinatesModify(test_input.reduce);
      expect(new_reduce.length).to.equal(4);
    });
  });
});

});

;require.register("test/mappers/runs_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('mappers/server_data_mapper');
require('mappers/runs_mapper');

describe('App.runsMapper', function () {

  var tests = [
    {
      i: {
        "workflowContext": {
          "workflowDag": {
            "entries": [
              {
                "source": "scope-5",
                "targets": []
              }
            ]
          }
        }
      },
      index: 0,
      e: '{dag: {"scope-5": []}}',
      m: 'One entry. Without targets'
    },
    {
      i: {
        "workflowContext": {
          "workflowDag": {
            "entries": [
              {
                "source": "scope-5",
                "targets": ['t1']
              }
            ]
          }
        }
      },
      index: 0,
      e: '{dag: {"scope-5": ["t1"]}}',
      m: 'One entry. With one target'
    },
    {
      i: {
        "workflowContext": {
          "workflowDag": {
            "entries": [
              {
                "source": "scope-5",
                "targets": ['t1,t2,t3']
              }
            ]
          }
        }
      },
      index: 0,
      e: '{dag: {"scope-5": ["t1,t2,t3"]}}',
      m: 'One entry. With multiple targets'
    },
    {
      i: {
        "workflowContext": {
          "workflowDag": {
            "entries": [
              {
                "source": "scope-5",
                "targets": []
              },
              {
                "source": "scope-4",
                "targets": []
              }
            ]
          }
        }
      },
      index: 0,
      e: '{dag: {"scope-5": [],"scope-4": []}}',
      m: 'Two entries. Without targets'
    },
    {
      i: {
        "workflowContext": {
          "workflowDag": {
            "entries": [
              {
                "source": "scope-5",
                "targets": ['t1,t2,t3']
              },
              {
                "source": "scope-4",
                "targets": ['t1']
              }
            ]
          }
        }
      },
      index: 0,
      e: '{dag: {"scope-5": ["t1,t2,t3"],"scope-4": ["t1"]}}',
      m: 'Two entries. With multiple targets'
    },
    {
      i: {
        "workflowContext": {
          "workflowDag": {
            "entries": [
              {
                "source": "scope-5",
                "targets": ['t1,t2,t3']
              },
              {
                "source": "scope-4",
                "targets": ['t1,t2,t3']
              }
            ]
          }
        }
      },
      index: 0,
      e: '{dag: {"scope-5": ["t1,t2,t3"],"scope-4": ["t1,t2,t3"]}}',
      m: 'Two entries. With multiple targets'
    }
  ];

  describe('#generateWorkflow', function() {
    tests.forEach(function(test) {
      it (test.m, function() {
        var result = App.runsMapper.generateWorkflow(test.i, test.index);
        expect(result.workflowContext).to.equal(test.e);
        expect(result.index).to.equal(test.index + 1);
      });
    });
  });

});

});

;require.register("test/mappers/server_data_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('mappers/server_data_mapper');

describe('App.QuickDataMapper', function () {

  var test_json = {
    a1: {
      b1: {
        c1: 'val1'
      },
      b2: 'val2',
      b3: [
        {
          c2: 'val4'
        },
        {
          c2: 'val5'
        },
        {
          c2: 'val1'
        }
      ]
    },
    a2: 'val3',
    item: {
      'key.dotted': 'val6'
    }
  };

  describe('#getJsonProperty', function() {
    var tests = [
      {i:'a1.b1.c1',e:'val1'},
      {i:'a1.b2',e:'val2'},
      {i:'a2',e:'val3'},
      {i:'a1.b3[0].c2',e:'val4'},
      {i:'a1.b3[1].c2',e:'val5'}
    ];
    tests.forEach(function(test) {
      it(test.i, function() {
        var mapper = App.QuickDataMapper.create();
        expect(mapper.getJsonProperty(test_json, test.i)).to.equal(test.e);
      });
    });
  });

  describe('#parseIt', function() {
    var config = {
      $a2: 'a2',
      f1: 'a1.b1.c1',
      f2: 'a1.b3[0].c2',
      f3: 'a1.b3',
      f4_key: 'a1.b3',
      f4_type: 'array',
      f4: {
        item: 'c2'
      },
      f5: 'item.["key.dotted"]'
    };
    var mapper = App.QuickDataMapper.create();
    var result = mapper.parseIt(test_json, config);
    it('Property starts with $', function() {
      expect(result.a2).to.equal('a2');
    });
    it('Multi-components path', function() {
      expect(result.f1).to.equal('val1');
    });
    it('Path with array index', function() {
      expect(result.f2).to.equal('val4');
    });
    it('Path returns array', function() {
      expect(result.f3.length).to.equal(3);
    });
    it('Generate array of json fields', function() {
      expect(result.f4).to.eql(['val1','val4','val5']);
    });
    it('Check value with dotted key', function() {
      expect(result.f5).to.eql('val6');
    });
  });

});

});

;require.register("test/mappers/service_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('utils/helper');
require('mappers/server_data_mapper');
require('mappers/service_metrics_mapper');

describe('App.serviceMetricsMapper', function () {

  describe('#hbaseMapper', function() {

    it ('Round Average Load', function() {
      var tests = [
        {
          components: [
            {
                ServiceComponentInfo: {
                  AverageLoad: 1.23456789,
                  component_name: "HBASE_MASTER",
                  RegionsInTransition : [ ]
                }
              }
          ],
          e: '1.23'
        },
        {
          components: [
            {
                ServiceComponentInfo: {
                  AverageLoad: 1.00,
                  component_name: "HBASE_MASTER",
                  RegionsInTransition : [ ]
                }
              }
          ],
          e: '1.00'
        },
        {
          components: [
            {
                ServiceComponentInfo: {
                  AverageLoad: 1,
                  component_name: "HBASE_MASTER",
                  RegionsInTransition : [ ]
                }
              }
          ],
          e: '1.00'
        },
        {
          components: [
            {
                ServiceComponentInfo: {
                  AverageLoad: 1.2,
                  component_name: "HBASE_MASTER",
                  RegionsInTransition : [ ]
                }
              }
          ],
          e: '1.20'
        }
      ];
      tests.forEach(function(test) {
        var result = App.serviceMetricsMapper.hbaseMapper(test);
        expect(result.average_load).to.equal(test.e);
      });
    });
  });

});

});

;require.register("test/mappers/status_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('mappers/server_data_mapper');

describe('App.statusMapper', function () {


});

});

;require.register("test/mappers/users_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('mappers/server_data_mapper');
require('mappers/users_mapper');

describe('App.usersMapper', function () {

  describe('#isAdmin', function() {
    var tests = [
      {i:'user,admin',e:true,m:'has admin role'},
      {i:'admin,user',e:true,m:'has admin role'},
      {i:'user',e:false,m:'doesn\'t have admin role'}
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        expect(App.usersMapper.isAdmin(test.i)).to.equal(test.e);
      });
    });
  });

});

});

;require.register("test/mixins/common/chart/storm_linear_time_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mixins/common/chart/storm_linear_time');

var slt,
  template,
  series,
  jsonDataFalse = {
    metrics: {
      id: 'metrics'
    }
  },
  jsonDataTrue = {
    metrics: {
      storm: {
        nimbus: {
          name: 'nimbus'
        }
      }
    }
  };

describe('App.StormLinearTimeChartMixin', function () {

  beforeEach(function () {
    slt = Em.Object.create(App.StormLinearTimeChartMixin, {
      stormChartDefinition: [
        {
          field: 'name',
          name: 'nimbus'
        }
      ]
    });
  });

  describe('#getDataForAjaxRequest', function () {
    it('should take data from stormChartDefinition', function () {
      template = slt.getDataForAjaxRequest().metricsTemplate;
      expect(template).to.contain('metrics');
      expect(template).to.contain('storm');
      expect(template).to.contain('nimbus');
    });
  });

  describe('#transformToSeries', function () {
    it('should be empty', function () {
      expect(slt.transformToSeries(jsonDataFalse)).to.be.empty;
    });
    it('should take one element from data', function () {
      slt.set('transformData', function (data, name) {
        return name + ': ' + JSON.stringify(data);
      });
      series = slt.transformToSeries(jsonDataTrue);
      expect(series).to.have.length(1);
      expect(series[0]).to.equal('nimbus: "nimbus"');
    });
  });

});

});

;require.register("test/mixins/common/localStorage_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mixins/common/localStorage');

var localStorage,
  nameCases = [
    {
      toSet: {
        name: 'name'
      },
      toExpect: 'Name'
    },
    {
      toSet: {
        name: null,
        controller: {
          name: 'samplecontroller'
        }
      },
      toExpect: 'Samplecontroller'
    },
    {
      toSet: {
        controller: {
          name: 'sampleController'
        }
      },
      toExpect: 'Sample'
    }
  ];

describe('App.LocalStorage', function () {

  beforeEach(function () {
    localStorage = Em.Object.create(App.LocalStorage);
  });

  after(function () {
    App.db.cleanUp();
  });

  describe('#dbNamespace', function () {
    nameCases.forEach(function (item) {
      it('should be ' + item.toExpect, function () {
        localStorage.setProperties(item.toSet);
        expect(localStorage.get('dbNamespace')).to.equal(item.toExpect)
      });
    });
  });

  describe('#getDBProperty', function () {
    it('should take value from DB', function () {
      localStorage.set('name', 'name');
      localStorage.setDBProperty('key', 'value');
      expect(localStorage.getDBProperty('key')).to.equal('value');
    });
  });

});

});

;require.register("test/mixins/main/host/details/host_components/decommissionable_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mixins/main/host/details/host_components/decommissionable');

var decommissionable,
  view,
  statusCases = [
    {
      status: App.HostComponentStatus.started,
      expected: false
    },
    {
      status: 'status',
      expected: true
    }
  ],
  responseCases = [
    {
      HostRoles: {
        desired_admin_state: 'state'
      },
      ServiceComponentInfo: 'info'
    },
    {
      HostRoles: {
        desired_admin_state: null
      },
      ServiceComponentInfo: null
    }
  ],
  textCases = [
    {
      available: true,
      text: Em.I18n.t('common.decommission')
    },
    {
      available: false,
      text: Em.I18n.t('common.recommission')
    }
  ];

describe('App.Decommissionable', function () {

  beforeEach(function () {
    decommissionable = Em.Object.create(App.Decommissionable);
  });

  describe('#isComponentDecommissionDisable', function () {
    statusCases.forEach(function (item) {
      it('should be ' + item.expected, function () {
        decommissionable.set('content', {
          service: {
            workStatus: item.status
          }
        });
        expect(decommissionable.get('isComponentDecommissionDisable')).to.equal(item.expected);
      });
    });
  });

  describe('#getDesiredAdminStateSuccessCallback', function () {
    responseCases.forEach(function (item) {
      var state = item.HostRoles.desired_admin_state;
      it('should return ' + state, function () {
        decommissionable.getDesiredAdminStateSuccessCallback(item);
        expect(decommissionable.get('desiredAdminState')).to.equal(state);
      });
    });
  });

  describe('#getDesiredAdminStateErrorCallback', function () {
    it('should return null', function () {
      decommissionable.getDesiredAdminStateErrorCallback();
      expect(decommissionable.get('desiredAdminState')).to.be.a('null');
    });
  });

  describe('#getDecommissionStatusSuccessCallback', function () {
    responseCases.forEach(function (item) {
      var state = item.ServiceComponentInfo;
      it('should return ' + state, function () {
        decommissionable.getDecommissionStatusSuccessCallback(item);
        expect(decommissionable.get('decommissionedStatusObject')).to.equal(state);
      });
    });
  });

  describe('#getDecommissionStatusErrorCallback', function () {
    it('should return null', function () {
      decommissionable.getDecommissionStatusErrorCallback();
      expect(decommissionable.get('decommissionedStatusObject')).to.be.a('null');
    });
  });

  describe('#decommissionView.text', function () {

    beforeEach(function () {
      view = decommissionable.decommissionView.create();
      view.reopen({
        parentView: decommissionable
      });
    });

    textCases.forEach(function (item) {
      it('should be ' + item.text, function () {
        view.set('parentView.isComponentDecommissionAvailable', item.available);
        expect(view.get('text')).to.equal(item.text);
      });
    });

  });

});

});

;require.register("test/mock_data_setup/configs_mock_data", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = {
  setupConfigGroupsObject: function(serviceName) {
    var serviceGroups = this.setupServiceConfigTagsObject(serviceName).mapProperty('siteName');
    var configGroups = [
      {
        "tag":"version1",
        "type":"core-site",
        "properties": {
          "fs.defaultFS" : "hdfs://c6401.ambari.apache.org:8020",
          "fs.trash.interval" : "360"
        }
      },
      {
        "tag":"version1",
        "type":"global",
        "properties":{
          "hadoop_heapsize":"1024",
          "storm_log_dir": "/var/log/storm",
          "stormuiserver_host": "c6401.ambari.apache.org",
          "nonexistent_property": "some value"
        }
      },
      {
        "tag":"version1",
        "type":"hdfs-site",
        "properties": {
          "dfs.datanode.data.dir": "/b,/a",
          "dfs.namenode.name.dir": "/b,/a,/c",
          "dfs.namenode.checkpoint.dir": "/b,/d,/a,/c",
          "dfs.datanode.failed.volumes.tolerated": "2",
          "content": "custom mock property"
        }
      },
      {
        "tag":"version1",
        "type":"hdfs-log4j",
        "properties": {
          "content": "hdfs log4j content"
        }
      },
      {
        "tag":"version1",
        "type":"zoo.cfg",
        "properties": {
          "custom.zoo.cfg": "zoo cfg content"
        }
      },
      {
        "tag":"version1",
        "type":"storm-site",
        "properties": {
          "storm.zookeeper.servers": "['c6401.ambari.apache.org','c6402.ambari.apache.org']",
          "single_line_property": "value",
          "multi_line_property": "value \n value"
        }
      },
      {
        "tag":"version1",
        "type":"zoo.cfg",
        "properties": {
          "custom.zoo.cfg": "value"
        }
      }
    ];
    return configGroups.filter(function(configGroup) {
      return serviceGroups.contains(configGroup.type);
    });
  },
  setupServiceConfigTagsObject: function(serviceName) {
    var configTags = {
      STORM: ['global','storm-site'],
      HDFS: ['global','hdfs-site','core-site','hdfs-log4j'],
      ZOOKEEPER: ['global', 'zoo.cfg']
    };
    var configTagsObject = [];
    if (serviceName) {
      configTags[serviceName].forEach(function(tag) {
        configTagsObject.push({
          siteName: tag,
          tagName: "version1",
          newTagName: null
        });
      });
    } else {
      for (var serviceName in configTags) {
        configTags[serviceName].forEach(function(tag) {
          configTagsObject.push({
            siteName: tag,
            tagName: "version1",
            newTagName: null
          });
        });
      }
    }
    return configTagsObject.uniq();
  },
  setupAdvancedConfigsObject: function() {
    return [
      {
        "serviceName": "HDFS",
        "name": "fs.defaultFS",
        "value": "hdfs://c6401.ambari.apache.org:8020",
        "description": "fs.defaultFS",
        "filename": "core-site.xml"
      },
      {
        "serviceName": "STORM",
        "name": "storm.zookeeper.servers",
        "value": "['localhost']",
        "description": "desc",
        "filename": "storm-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "dfs.datanode.data.dir",
        "value": "/hadoop/hdfs/data",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "dfs.namenode.name.dir",
        "value": "/hadoop/hdfs/namenode",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "dfs.namenode.checkpoint.dir",
        "value": "/hadoop/hdfs/namesecondary",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "dfs.datanode.failed.volumes.tolerated",
        "value": "2",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "content",
        "value": "custom mock property",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "content",
        "value": "hdfs log4j content",
        "description": "desc",
        "filename": "hdfs-log4j.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "content",
        "value": "custom hdfs log4j content",
        "description": "desc",
        "filename": "custom-hdfs-log4j.xml"
      },
      {
        "serviceName": "ZOOKEEPER",
        "name": "content",
        "value": "zookeeper log4j.xml content",
        "description": "desc",
        "filename": "zookeeper-log4j.xml"
      },
      {
        "serviceName": "ZOOKEEPER",
        "name": "custom.zoo.cfg",
        "value": "zoo cfg content",
        "description": "zoo.cfg config",
        "filename": "zoo.cfg"
      },
      {
        "serviceName": "YARN",
        "name": "content",
        "value": " value \n value",
        "filename": "capacity-scheduler.xml"
      },
      {
        "serviceName": "YARN",
        "name": "yarn.scheduler.capacity.root.default.capacity",
        "value": "100",
        "filename": "capacity-scheduler.xml"
      }
    ];
  },
  setupStoredConfigsObject: function() {
    return [
      {
        "name":"storm.zookeeper.servers",
        "value":[
          "c6401.ambari.apache.org",
          "c6402.ambari.apache.org"
        ],
        "defaultValue":"['c6401.ambari.apache.org','c6402.ambari.apache.org']",
        "filename":"storm-site.xml",
        "isUserProperty":false,
        "isOverridable":false,
        "showLabel":true,
        "serviceName":"STORM",
        "displayType":"masterHosts",
        "isVisible":true,
        "description":"desc",
        "isSecureConfig":false,
        "category":"General",
        "id":"site property",
        "displayName":"storm.zookeeper.servers"
      },
      {
        "name":"single_line_property",
        "value":"value",
        "defaultValue":"value",
        "filename":"storm-site.xml",
        "isUserProperty":true,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"STORM",
        "id":"site property",
        "displayType":"advanced",
        "displayName":"single_line_property",
        "category":"AdvancedStormSite"
      },
      {
        "name":"multi_line_property",
        "value":"value \n value",
        "defaultValue":"value \n value",
        "filename":"storm-site.xml",
        "isUserProperty":true,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"STORM",
        "id":"site property",
        "displayType":"multiLine",
        "displayName":"multi_line_property",
        "category":"AdvancedStormSite"
      },
      {
        "name":"nonexistent_property",
        "value":"some value",
        "defaultValue":"some value",
        "filename":"global.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"STORM",
        "isVisible":false,
        "id":"puppet var",
        "displayName":null,
        "options":null
      },
      {
        "name":"dfs.datanode.data.dir",
        "value":"/a,/b",
        "defaultValue":"/a,/b",
        "filename":"hdfs-site.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"HDFS",
        "displayType":"directories",
        "isRequired":true,
        "isReconfigurable":true,
        "isVisible":true,
        "description":"desc",
        "index":1,
        "isSecureConfig":false,
        "category":"DataNode",
        "id":"site property",
        "displayName":"DataNode directories"
      },
      {
        "name":"content",
        "value":"custom mock property",
        "defaultValue":"custom mock property",
        "filename":"hdfs-site.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":false,
        "serviceName":"HDFS",
        "displayType":"content",
        "isRequired":true,
        "isRequiredByAgent":true,
        "isReconfigurable":true,
        "isVisible":true,
        "description":"desc",
        "isSecureConfig":false,
        "category":"AdvancedHDFSLog4j",
        "id":"site property",
        "displayName":"content"
      },
      {
        "name":"content",
        "value":"hdfs log4j content",
        "defaultValue":"hdfs log4j content",
        "filename":"hdfs-log4j.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":false,
        "serviceName":"HDFS",
        "displayType":"content",
        "isRequired":true,
        "isRequiredByAgent":true,
        "isReconfigurable":true,
        "isVisible":true,
        "description":"desc",
        "isSecureConfig":false,
        "category":"AdvancedHDFSLog4j",
        "id":"site property",
        "displayName":"content"
      },
      {
        "name":"storm_log_dir",
        "value":"/var/log/storm",
        "defaultValue":"/var/log/storm",
        "filename":"global.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"STORM",
        "displayType":"directory",
        "isRequired":true,
        "isRequiredByAgent":true,
        "isReconfigurable":true,
        "isVisible":true,
        "description":"Storm log directory",
        "isSecureConfig":false,
        "category":"General",
        "id":"puppet var",
        "displayName":"storm_log_dir"
      }
    ];
  }
}

});

;require.register("test/models/alert_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/alert');

var alert,
  sampleTime = 1399312800,
  statusCases = [
    {
      status: 0,
      property: 'isOk',
      format: 'OK'
    },
    {
      status: 1,
      property: 'isWarning',
      format: 'WARN'
    },
    {
      status: 2,
      property: 'isCritical',
      format: 'CRIT'
    },
    {
      status: 3,
      property: 'isPassive',
      format: 'MAINT'
    },
    {
      status: 4,
      property: '',
      format: 'UNKNOWN'
    }
  ],
  ignoredCases = [
    {
      title: 'title',
      result: false
    },
    {
      title: 'Percent',
      result: true
    }
  ],
  serviceTypeCases = [
    {
      type: 'MAPREDUCE',
      name: 'MapReduce',
      link: '#/main/services/MAPREDUCE/summary'
    },
    {
      type: 'HDFS',
      name: 'HDFS',
      link: '#/main/services/HDFS/summary'
    },
    {
      type: 'HBASE',
      name: 'HBase',
      link: '#/main/services/HBASE/summary'
    },
    {
      type: 'ZOOKEEPER',
      name: 'Zookeeper',
      link: '#/main/services/ZOOKEEPER/summary'
    },
    {
      type: 'OOZIE',
      name: 'Oozie',
      link: '#/main/services/OOZIE/summary'
    },
    {
      type: 'HIVE',
      name: 'Hive',
      link: '#/main/services/HIVE/summary'
    },
    {
      type: 'service',
      name: null,
      link: null
    },
    {
      type: null,
      name: null,
      link: null
    }
  ],
  titles = ['NodeManager health', 'NodeManager process', 'TaskTracker process', 'RegionServer process', 'DataNode process', 'DataNode space', 'ZooKeeper Server process', 'Supervisors process'];

describe('App.Alert', function () {

  beforeEach(function() {
    alert = App.Alert.create();
  });

  describe('#date', function () {
    it('is Mon May 05 2014', function () {
      alert.set('lastTime', sampleTime);
      expect(alert.get('date').toDateString()).to.equal('Mon May 05 2014');
    });
  });

  statusCases.forEach(function (item) {
    var status = item.status,
      property = item.property;
    if (property) {
      describe('#' + property, function () {
        it('status ' + status + ' is for ' + property, function () {
          alert.set('status', status);
          expect(alert.get(property)).to.be.true;
          var falseStates = statusCases.mapProperty('property').without(property).without('');
          var falseStatuses = [];
          falseStates.forEach(function (state) {
            falseStatuses.push(alert.get(state));
          });
          expect(falseStatuses).to.eql([false, false, false]);
        });
      });
    }
  });

  describe('#ignoredForServices', function () {
    titles.forEach(function (item) {
      it('should be true for ' + item, function () {
        alert.set('title', item);
        expect(alert.get('ignoredForServices')).to.be.true;
      });
    });
    it('should be false', function () {
      alert.set('title', 'title');
      expect(alert.get('ignoredForServices')).to.be.false;
    });
  });

  describe('#ignoredForHosts', function () {
    ignoredCases.forEach(function (item) {
      it('should be ' + item.result, function () {
        alert.set('title', item.title);
        expect(alert.get('ignoredForHosts')).to.equal(item.result);
      });
    });
  });

  describe('#timeSinceAlert', function () {
    statusCases.forEach(function (item) {
      var format = item.format;
      it('should indicate ' + format + ' status duration', function () {
        alert.setProperties({
          lastTime: sampleTime,
          status: item.status.toString()
        });
        expect(alert.get('timeSinceAlert')).to.have.string(format);
        expect(alert.get('timeSinceAlert.length')).to.be.above(format.length);
        alert.set('lastTime', 0);
        expect(alert.get('timeSinceAlert')).to.equal(format);
      });
    });
    it('should be empty', function () {
      alert.set('lastTime', undefined);
      expect(alert.get('timeSinceAlert')).to.be.empty;
    });
  });

  describe('#makeTimeAtleastMinuteAgo', function () {
    it('should set the minute-ago time', function () {
      var time = App.dateTime() - 50000,
        date = new Date(time - 10000);
      alert.set('lastTime', time);
      expect(alert.makeTimeAtleastMinuteAgo(alert.get('date'))).to.be.at.least(date);
    });
    it('should return the actual time', function () {
      var time = App.dateTime() - 70000;
      alert.set('lastTime', time);
      expect(alert.makeTimeAtleastMinuteAgo(alert.get('date'))).to.eql(alert.get('date'));
    });
  });

  describe('#timeSinceAlertDetails', function () {
    it ('should return the appropriate string', function () {
      alert.set('lastTime', sampleTime);
      var occurred = Em.I18n.t('services.alerts.occurredOn').format('May 05 2014', alert.get('date').toLocaleTimeString());
      var brChecked = Em.I18n.t('services.alerts.brLastCheck').format($.timeago(sampleTime));
      var checked = Em.I18n.t('services.alerts.lastCheck').format($.timeago(sampleTime));
      expect(alert.get('timeSinceAlertDetails')).to.equal(occurred);
      alert.set('lastCheck', sampleTime / 1000);
      expect(alert.get('timeSinceAlertDetails')).to.equal(occurred + brChecked);
      alert.set('lastTime', undefined);
      expect(alert.get('timeSinceAlertDetails')).to.equal(checked);
    });
    it ('should be empty', function () {
      alert.set('lastCheck', undefined);
      expect(alert.get('timeSinceAlertDetails')).to.be.empty;
    });
  });

  describe('#serviceName', function () {
    serviceTypeCases.forEach(function (item) {
      it('should be ' + item.name, function () {
        alert.set('serviceType', item.type);
        expect(alert.get('serviceName')).to.equal(item.name);
      });
    });
  });

  describe('#serviceLink', function () {
    serviceTypeCases.forEach(function (item) {
      it('should be ' + item.link, function () {
        alert.set('serviceType', item.type);
        expect(alert.get('serviceLink')).to.equal(item.link);
      });
    });
  });

});

});

;require.register("test/models/authentication_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/authentication');

var form,
  methods = [
    {
      name: 'method',
      fields: ['primaryServer', 'searchBaseDn', 'usernameAttribute']
    },
    {
      name: 'bindMethod',
      fields: ['bindUser', 'password', 'passwordRetype']
    }
  ],
  classCases = [
    {
      result: 0,
      message: 'fail',
      className: 'error'
    },
    {
      result: 1,
      message: 'success',
      className: 'success'
    }
  ];

describe('App.AuthenticationForm', function () {

  beforeEach(function() {
    form = App.AuthenticationForm.create();
  });

  methods.forEach(function (method) {
    method.fields.forEach(function (field) {
      describe('#' + field + '.isRequired', function () {
        for (var i = 2; i--; ) {
          it('should be ' + i + ' dependent on ' + method.name + ' value', function () {
            form.getField(method.name).set('value', i);
            expect(form.getField(field).get('isRequired')).to.equal(i);
          });
        }
      });
    });
  });

  describe('#testResult', function () {
    it('should be 0 or 1', function () {
      form.testConfiguration();
      expect([0, 1]).to.include(Number(form.get('testResult')));
    });
  });

  describe('#testConfigurationMessage', function () {
    classCases.forEach(function (item) {
      it('should indicate ' + item.message, function () {
        form.set('testResult', item.result);
        expect(form.get('testConfigurationMessage')).to.equal(Em.I18n.t('admin.authentication.form.test.' + item.message));
      });
    });
  });

  describe('#testConfigurationClass', function () {
    classCases.forEach(function (item) {
      it('should indicate ' + item.className, function () {
        form.set('testResult', item.result);
        expect(form.get('testConfigurationClass')).to.equal('text-' + item.className);
      });
    });
  });

});

});

;require.register("test/models/cluster_states_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/cluster_states');

var status = App.clusterStatus,
  notInstalledStates = ['CLUSTER_NOT_CREATED_1', 'CLUSTER_DEPLOY_PREP_2', 'CLUSTER_INSTALLING_3', 'SERVICE_STARTING_3'],
  values = {
    clusterName: 'name',
    clusterState: 'STACK_UPGRADING',
    wizardControllerName: 'wizardStep0Controller',
    localdb: {}
  },
  response = {
    clusterState: 'DEFAULT',
    clusterName: 'cluster'
  },
  newValue = {
    clusterName: 'name',
    clusterState: 'STACK_UPGRADING',
    wizardControllerName: 'wizardStep0Controller'
  };

describe('App.clusterStatus', function () {

  describe('#isInstalled', function () {
    notInstalledStates.forEach(function (item) {
      it('should be false', function () {
        status.set('clusterState', item);
        expect(status.get('isInstalled')).to.be.false;
      });
    });
    it('should be true', function () {
      status.set('clusterState', 'DEFAULT');
      expect(status.get('isInstalled')).to.be.true;
    });
  });

  describe('#value', function () {
    it('should be set from properties', function () {
      Em.keys(values).forEach(function (key) {
        status.set(key, values[key]);
      });
      expect(status.get('value')).to.eql(values);
    });
  });

  describe('#getUserPrefSuccessCallback', function () {
    it('should set the cluster parameters', function () {
      status.getUserPrefSuccessCallback(response);
      Em.keys(response).forEach(function (key) {
        expect(status.get(key)).to.equal(response[key]);
      });
    });
  });

  describe('#setClusterStatus', function () {

    afterEach(function () {
      App.get.restore();
    });

    it('should return false in test mode', function () {
      sinon.stub(App, 'get', function(k) {
        if (k === 'testMode') return true;
        return Em.get(App, k);
      });
      expect(status.setClusterStatus()).to.be.false;
    });

    it('should set cluster status in non-test mode', function () {
      sinon.stub(App, 'get', function(k) {
        if (k === 'testMode') return false;
        return Em.get(App, k);
      });
      var clusterStatus = status.setClusterStatus(newValue);
      expect(clusterStatus).to.eql(newValue);
    });

  });

  describe('#makeRequestAsync', function () {
    it('should be false after synchronous updateFromServer', function () {
      status.updateFromServer();
      expect(status.get('makeRequestAsync')).to.be.false;
    });
    it('should be true after asynchronous updateFromServer', function () {
      status.updateFromServer(true);
      expect(status.get('makeRequestAsync')).to.be.true;
    });
    it('should be false after synchronous setClusterStatus with no opt specified', function () {
      status.setClusterStatus({clusterName: 'name'});
      expect(status.get('makeRequestAsync')).to.be.false;
    });
  });

});

});

;require.register("test/models/config_group_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/config_group');
require('models/host');

var configGroup,
  hostRecord,
  hosts = [
    Em.Object.create({
      id: 'host0',
      hostName: 'host0'
    }),
    Em.Object.create({
      id: 'host1',
      hostName: 'host1'
    })
  ],
  host = {
    id: 'host0',
    host_name: 'host0'
  },
  properties = [
    {
      name: 'n0',
      value: 'v0'
    },
    {
      name: 'n1',
      value: 'v1'
    }
  ],
  setParentConfigGroup = function (configGroup, hosts) {
    configGroup.set('parentConfigGroup', App.ConfigGroup.create());
    configGroup.set('parentConfigGroup.hosts', hosts.mapProperty('hostName'));
  };

describe('App.ConfigGroup', function () {

  beforeEach(function () {
    configGroup = App.ConfigGroup.create();
  });

  describe('#displayName', function () {
    it('should equal name if maximum length is not exceeded', function () {
      configGroup.set('name', 'n');
      expect(configGroup.get('displayName')).to.equal(configGroup.get('name'));
    });
    it('should be shortened if maximum length is exceeded', function () {
      var maxLength = App.config.CONFIG_GROUP_NAME_MAX_LENGTH;
      for (var i = maxLength + 1, name = ''; i--; ) {
        name += 'n';
      }
      configGroup.set('name', name);
      expect(configGroup.get('displayName')).to.contain('...');
      expect(configGroup.get('displayName')).to.have.length(2 * Math.floor(maxLength / 2) + 3);
    });
  });

  describe('#displayNameHosts', function () {
    it('should indicate the number of hosts', function () {
      var displayName = configGroup.get('displayName');
      configGroup.set('hosts', []);
      expect(configGroup.get('displayNameHosts')).to.equal(displayName + ' (0)');
      configGroup.set('hosts', hosts);
      expect(configGroup.get('displayNameHosts')).to.equal(displayName + ' (2)');
    });
  });

  describe('#availableHosts', function () {

    beforeEach(function () {
      App.clusterStatus.set('clusterState', 'DEFAULT');
      App.store.load(App.Host, host);
      hostRecord = App.Host.find().findProperty('hostName', 'host0');
      setParentConfigGroup(configGroup, hosts);
    });

    afterEach(function () {
      modelSetup.deleteRecord(hostRecord);
    });

    it('should return an empty array as default', function () {
      configGroup.set('isDefault', true);
      expect(configGroup.get('availableHosts')).to.eql([]);
    });

    it('should return an empty array if there are no unused hosts', function () {
      configGroup.set('parentConfigGroup', App.ConfigGroup.create());
      expect(configGroup.get('availableHosts')).to.eql([]);
    });

    it('should take hosts from parentConfigGroup', function () {
      setParentConfigGroup(configGroup, hosts);
      expect(configGroup.get('availableHosts')).to.have.length(2);
    });
  });

  describe('#isAddHostsDisabled', function () {

    beforeEach(function () {
      hostRecord = App.Host.createRecord(host);
      setParentConfigGroup(configGroup, hosts);
      configGroup.set('isDefault', false);
      configGroup.set('availableHosts', []);
    });

    afterEach(function () {
      modelSetup.deleteRecord(hostRecord);
    });

    it('should be false', function () {
      expect(configGroup.get('isAddHostsDisabled')).to.be.false;
    });
    it('should be true', function () {
      App.clusterStatus.set('clusterState', 'DEFAULT');
      configGroup.set('isDefault', true);
      expect(configGroup.get('isAddHostsDisabled')).to.be.true;
      configGroup.set('availableHosts', hosts);
      expect(configGroup.get('isAddHostsDisabled')).to.be.true;
    });
  });

  describe('#propertiesList', function () {
    it('should be formed from properties', function () {
      configGroup.set('properties', properties);
      properties.forEach(function (item) {
        Em.keys(item).forEach(function (prop) {
          expect(configGroup.get('propertiesList')).to.contain(item[prop]);
        });
      });
      expect(configGroup.get('propertiesList')).to.have.length(24);
    });
  });

});

});

;require.register("test/models/dataset_job_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/dataset_job');

var dataSetJob,
  dataSetJobData = {
    id: 'job',
    name: 'job'
  },
  timeCases = [
    {
      property: 'startFormatted',
      dateProperty: 'startDate'
    },
    {
      property: 'endFormatted',
      dateProperty: 'endDate'
    }
  ],
  timeTestData = [
    {
      title: 'should calculate time period',
      time: function () {
        return App.dateTime();
      },
      result: 'less than a minute ago'
    },
    {
      title: 'should be empty',
      time: function () {
        return 0;
      },
      result: ''
    }
  ],
  healthCases = [
    {
      status: 'SUCCEEDED',
      className: 'icon-ok'
    },
    {
      status: 'SUSPENDED',
      className: 'icon-cog'
    },
    {
      status: 'WAITING',
      className: 'icon-time'
    },
    {
      status: 'RUNNING',
      className: 'icon-play'
    },
    {
      status: 'KILLED',
      className: 'icon-exclamation-sign'
    },
    {
      status: 'FAILED',
      className: 'icon-warning-sign'
    },
    {
      status: 'ERROR',
      className: 'icon-remove'
    },
    {
      status: '',
      className: 'icon-question-sign'
    }
  ];

describe('App.DataSetJob', function () {

  beforeEach(function () {
    dataSetJob = App.DataSetJob.createRecord(dataSetJobData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(dataSetJob);
  });

  describe('#statusFormatted', function () {
    it('should be in lower case and capitalized', function () {
      dataSetJob.set('status', 'RUNNING');
      expect(dataSetJob.get('statusFormatted')).to.equal('Running');
    });
  });

  describe('#isSuspended', function () {
    it('should be false', function () {
      dataSetJob.set('status', 'RUNNING');
      expect(dataSetJob.get('isSuspended')).to.be.false;
    });
    it('should be true', function () {
      dataSetJob.set('status', 'SUSPENDED');
      expect(dataSetJob.get('isSuspended')).to.be.true;
    });
  });

  timeCases.forEach(function (item) {
    describe('#' + item.property, function () {
      timeTestData.forEach(function (test) {
        it(test.title, function () {
          dataSetJob.set(item.dateProperty, test.time());
          expect(dataSetJob.get(item.property)).to.equal(test.result);
        });
      });
    });
  });

  describe('#healthClass', function () {
    healthCases.forEach(function (item) {
      it('should be ' + item.className, function () {
        dataSetJob.set('status', item.status);
        expect(dataSetJob.get('healthClass')).to.equal(item.className);
      });
    });
  });

});

});

;require.register("test/models/dataset_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/dataset');

var dataset,
  datasetData = {
    id: 'dataset',
    name: 'dataset'
  },
  statusCases = [
    {
      status: 'RUNNING',
      property: 'isRunning'
    },
    {
      status: 'SUSPENDED',
      property: 'isSuspended'
    },
    {
      status: 'SUBMITTED',
      property: 'isSubmitted'
    }
  ],
  healthCases = [
    {
      title: 'should be live',
      data: {
        datasetJobs: [
          Em.Object.create({
            status: 'SUCCESSFUL'
          })
        ]
      },
      className: 'health-status-LIVE',
      icon: App.healthIconClassGreen
    },
    {
      title: 'should be dead for failed first job',
      data: {
        datasetJobs: [
          Em.Object.create({
            status: 'SUSPENDED',
            endDate: 1
          }),
          Em.Object.create({
            status: 'FAILED',
            endDate: 0
          })
        ]
      },
      className: 'health-status-DEAD-RED',
      icon: App.healthIconClassRed
    },
    {
      title: 'should be for no jobs',
      data: {
        datasetJobs: []
      },
      className: 'health-status-LIVE',
      icon: App.healthIconClassGreen
    }
  ];

describe('App.Dataset', function () {

  beforeEach(function () {
    dataset = App.Dataset.createRecord(datasetData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(dataset);
  });

  describe('#prefixedName', function () {
    it('should add mirroring prefix before the name', function () {
      dataset.set('name', 'name');
      expect(dataset.get('prefixedName')).to.equal(App.mirroringDatasetNamePrefix + 'name');
    });
  });

  describe('#statusFormatted', function () {
    it('should be in lower case and capitalized', function () {
      dataset.set('status', 'RUNNING');
      expect(dataset.get('statusFormatted')).to.equal('Running');
    });
  });

  statusCases.forEach(function (item) {
    describe(item.property, function () {

      beforeEach(function () {
        dataset.set('status', item.status);
      });

      it('should be true', function () {
        expect(dataset.get(item.property)).to.be.true;
      });

      it('others should be false', function () {
        var falseProperties = statusCases.mapProperty('property').without(item.property);
        var falseStates = [];
        falseProperties.forEach(function (prop) {
          falseStates.push(dataset.get(prop));
        });
        expect(falseStates).to.eql([false, false]);
      });

    });
  });

  describe('#healthClass', function () {
    healthCases.forEach(function (item) {
      it(item.title, function () {
        dataset.reopen(item.data);
        expect(dataset.get('healthClass')).to.equal(item.className);
      });
    });
  });

  describe('#healthIconClass', function () {
    healthCases.forEach(function (item) {
      it(item.title, function () {
        dataset.reopen(item.data);
        expect(dataset.get('healthIconClass')).to.equal(item.icon);
      });
    });
  });

});

});

;require.register("test/models/form_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/form');

var form,
  field,
  formField,
  resultCases = [
    {
      text: Em.I18n.t('form.saveError'),
      result: -1
    },
    {
      text: Em.I18n.t('form.saveSuccess'),
      result: 1
    },
    {
      text: '',
      result: 0
    }
  ],
  displayTypeCases = [
    {
      type: 'checkbox',
      classString: 'Checkbox'
    },
    {
      type: 'select',
      classString: 'Select'
    },
    {
      type: 'textarea',
      classString: 'TextArea'
    },
    {
      type: 'password',
      classString: 'TextField'
    },
    {
      type: 'hidden',
      classString: 'TextField'
    }
  ],
  hiddenCases = [
    {
      displayType: 'password',
      type: 'hidden',
      value: false
    },
    {
      displayType: 'hidden',
      type: 'hidden',
      value: true
    }
  ],
  expectError = function (message) {
    formField.validate();
    expect(formField.get('errorMessage')).to.equal(message);
  };

describe('App.Form', function () {

  beforeEach(function () {
    form = App.Form.create({
      fieldsOptions: [
        {
          name: 'field0',
          value: 'value0',
          isRequired: false
        }
      ]
    });
    field = form.get('fields').objectAt(0);
  });

  describe('#fields', function () {
    it('should get data from formFields', function () {
      var fields = form.get('fields');
      expect(fields).to.have.length(1);
      expect(field.get('name')).to.equal('field0');
    });
  });

  describe('#field', function () {
    it('should get data from formFields', function () {
      var field0 = form.get('field.field0');
      expect(form.get('field')).to.not.be.empty;
      expect(field0.get('name')).to.equal('field0');
      expect(field0.get('form')).to.eql(form);
    });
  });

  describe('#getField', function () {
    it('should get field0', function () {
      expect(form.getField('field0')).to.eql(form.get('field.field0'));
    });
    it('should be empty', function () {
      form.set('fields', []);
      expect(form.getField()).to.be.empty;
    });
  });

  describe('#isValid', function () {
    it('should be true', function () {
      field.set('isRequired', false);
      expect(form.isValid()).to.be.true;
    });
    it('should be false', function () {
      field.setProperties({
        isRequired: true,
        value: ''
      });
      expect(form.isValid()).to.be.false;
    });
  });

  describe('#updateValues', function () {
    it('should update field0 value', function () {
      form.set('object', Em.Object.create({field0: 'value0upd'}));
      expect(field.get('value')).to.equal('value0upd');
    });
    it('should empty password value', function () {
      field.set('displayType', 'password');
      form.set('object', Em.Object.create());
      expect(field.get('value')).to.be.empty;
    });
    it('should clear values', function () {
      form.set('object', []);
      expect(field.get('value')).to.be.empty;
    });
  });

  describe('#clearValues', function () {
    it('should clear values', function () {
      var field0 = form.get('fields').objectAt(0);
      field0.set('value', 'value0');
      form.clearValues();
      expect(field0.get('value')).to.be.empty;
    });
  });

  describe('#resultText', function () {
    resultCases.forEach(function (item) {
      it('should be ' + item.text, function () {
        form.set('result', item.result);
        expect(form.get('resultText')).to.equal(item.text);
      });
    });
  });

});

describe('App.FormField', function () {

  beforeEach(function () {
    formField = App.FormField.create();
  });

  describe('#isValid', function () {
    it('should be true', function () {
      expect(formField.get('isValid')).to.be.true;
    });
    it('should be false', function () {
      formField.set('errorMessage', 'error');
      expect(formField.get('isValid')).to.be.false;
    });
  });

  describe('#viewClass', function () {
    displayTypeCases.forEach(function (item) {
      it('should be ' + item.classString, function () {
        formField.set('displayType', item.type);
        expect(formField.get('viewClass').toString()).to.contain(item.classString);
      });
    });
  });

  describe('#validate', function () {
    it('should return error message', function () {
      formField.set('isRequired', true);
      expectError('This is required');
    });
    it('should return empty error message', function () {
      formField.set('isRequired', false);
      expectError('');
      formField.set('value', 'value');
      expectError('');
    });
  });

  describe('#isHiddenField', function () {
    hiddenCases.forEach(function (item) {
      it('should be ' + item.value, function () {
        formField.setProperties(item);
        expect(formField.get('isHiddenField')).to.equal(item.value);
      });
    });
  });

});

});

;require.register("test/models/host_component_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/host_component');

describe('App.HostComponentStatus', function() {

  describe('#getStatusesList', function() {

    it('allowed statuses', function() {
      var statuses = ["STARTED","STARTING","INSTALLED","STOPPING","INSTALL_FAILED","INSTALLING","UPGRADE_FAILED","UNKNOWN","DISABLED","INIT"];
      expect(App.HostComponentStatus.getStatusesList()).to.include.members(statuses);
      expect(statuses).to.include.members(App.HostComponentStatus.getStatusesList());
    });
  });

});
});

;require.register("test/models/host_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/host');

describe('App.Host', function () {

  var data = [
    {
      id: 'host1',
      host_name: 'host1',
      memory: 200000,
      disk_total: 100.555,
      disk_free: 90.555,
      health_status: 'HEALTHY',
      last_heart_beat_time: (new Date()).getTime() - 18100000
    },
    {
      id: 'host2',
      host_name: 'host2',
      memory: 99999,
      disk_total: 90,
      disk_free: 90,
      health_status: 'HEALTHY',
      last_heart_beat_time: (new Date()).getTime() - 170000
    },
    {
      id: 'host3',
      host_name: 'host3',
      memory: 99999,
      disk_total: 99.999,
      disk_free: 0,
      health_status: 'UNKNOWN',
      last_heart_beat_time: (new Date()).getTime()
    }
  ];
  before(function() {
    App.set('testMode', false);
  });
  App.store.loadMany(App.Host, data);

  describe('#diskUsedFormatted', function () {

    it('host1 - 10GB ', function () {
      var host = App.Host.find().findProperty('hostName', 'host1');
      expect(host.get('diskUsedFormatted')).to.equal('10GB');
    });
    it('host2 - 0GB', function () {
      var host = App.Host.find().findProperty('hostName', 'host2');
      expect(host.get('diskUsedFormatted')).to.equal('0GB');
    });
    it('host3 - 100GB', function () {
      var host = App.Host.find().findProperty('hostName', 'host3');
      expect(host.get('diskUsedFormatted')).to.equal('100GB');
    });
  });

  describe('#diskTotalFormatted', function () {

    it('host1 - 100.56GB ', function () {
      var host = App.Host.find().findProperty('hostName', 'host1');
      expect(host.get('diskTotalFormatted')).to.equal('100.56GB');
    });
    it('host2 - 90GB', function () {
      var host = App.Host.find().findProperty('hostName', 'host2');
      expect(host.get('diskTotalFormatted')).to.equal('90GB');
    });
    it('host3 - 100GB', function () {
      var host = App.Host.find().findProperty('hostName', 'host3');
      expect(host.get('diskTotalFormatted')).to.equal('100GB');
    });
  });

  describe('#diskUsageFormatted', function () {

    it('host1 - 9.94% ', function () {
      var host = App.Host.find().findProperty('hostName', 'host1');
      expect(host.get('diskUsageFormatted')).to.equal('9.94%');
    });
    it('host2 - 0%', function () {
      var host = App.Host.find().findProperty('hostName', 'host2');
      expect(host.get('diskUsageFormatted')).to.equal('0%');
    });
    it('host3 - 100%', function () {
      var host = App.Host.find().findProperty('hostName', 'host3');
      expect(host.get('diskUsageFormatted')).to.equal('100%');
    });
  });

  describe('#isNotHeartBeating', function () {
    it('host2 - false', function () {
      var host = App.Host.find().findProperty('hostName', 'host2');
      expect(host.get('isNotHeartBeating')).to.equal(false);
    });
    it('host3 - false', function () {
      var host = App.Host.find().findProperty('hostName', 'host3');
      expect(host.get('isNotHeartBeating')).to.equal(true);
    });
  });

});

});

;require.register("test/models/hosts_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/hosts');

var hostInfo,
  statusCases = [
    {
      status: 'REGISTERED',
      bootStatusForDisplay: 'Success',
      bootBarColor: 'progress-success',
      bootStatusColor: 'text-success',
      isBootDone: true
    },
    {
      status: 'FAILED',
      bootStatusForDisplay: 'Failed',
      bootBarColor: 'progress-danger',
      bootStatusColor: 'text-error',
      isBootDone: true
    },
    {
      status: 'PENDING',
      bootStatusForDisplay: 'Preparing',
      bootBarColor: 'progress-info',
      bootStatusColor: 'text-info',
      isBootDone: false
    },
    {
      status: 'RUNNING',
      bootStatusForDisplay: 'Installing',
      bootBarColor: 'progress-info',
      bootStatusColor: 'text-info',
      isBootDone: false
    },
    {
      status: 'DONE',
      bootStatusForDisplay: 'Registering',
      bootBarColor: 'progress-info',
      bootStatusColor: 'text-info',
      isBootDone: false
    },
    {
      status: 'REGISTERING',
      bootStatusForDisplay: 'Registering',
      bootBarColor: 'progress-info',
      bootStatusColor: 'text-info',
      isBootDone: false
    }
  ],
  tests = ['bootStatusForDisplay', 'bootBarColor', 'bootStatusColor', 'isBootDone'];

describe('App.HostInfo', function () {

  beforeEach(function () {
    hostInfo = App.HostInfo.create();
  });

  tests.forEach(function (property) {
    describe('#' + property, function () {
      statusCases.forEach(function (testCase) {
        it('should be ' + testCase[property], function () {
          hostInfo.set('bootStatus', testCase.status);
          expect(hostInfo.get(property)).to.equal(testCase[property]);
        });
      });
    });
  });

});

});

;require.register("test/models/job_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/job');

var job,
  jobData = {
   id: 'job'
  };

describe('App.Job', function () {

  beforeEach(function () {
    job = App.Job.createRecord(jobData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(job);
  });

  describe('#duration', function () {
    it('should convert elapsedTime into time format', function () {
      job.set('elapsedTime', 1000);
      expect(job.get('duration')).to.equal('1.00 secs');
    });
  });

  describe('#inputFormatted', function () {
    it('should convert input into bandwidth format', function () {
      job.set('input', 1024);
      expect(job.get('inputFormatted')).to.equal('1.0KB');
    });
  });

  describe('#outputFormatted', function () {
    it('should convert output into bandwidth format', function () {
      job.set('output', 1024);
      expect(job.get('outputFormatted')).to.equal('1.0KB');
    });
  });

});

});

;require.register("test/models/jobs/job_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/jobs/job');

var job,
  jobData = {
    id: 'job'
  },
  timeCases = [
    {
      toSet: 'startTime',
      toExpect: 'startTimeDisplay'
    },
    {
      toSet: 'endTime',
      toExpect: 'endTimeDisplay'
    }
  ],
  timeDataCorrect = {
    startTime: 1000,
    endTime: 2000
  },
  timeDataRunning = {
    startTime: App.dateTime() - 1000,
    endTime: undefined
  },
  timeDataIncorrect = {
    startTime: App.dateTime() - 1000,
    endTime: 1
  };

describe('App.AbstractJob', function () {

  beforeEach(function () {
    job = App.AbstractJob.createRecord(jobData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(job);
  });

  timeCases.forEach(function (item) {
    var toSet = item.toSet,
      toExpect = item.toExpect;
    describe('#' + toExpect, function () {
      it('should be empty', function () {
        job.set(toSet, 0);
        expect(job.get(toExpect)).to.be.empty;
      });
      it('should return formatted time', function () {
        job.set(toSet, 1000000);
        expect(job.get(toExpect)).to.equal('Thu, Jan 01, 1970 00:16');
      });
    });
  });

  describe('#duration', function () {
    it('should calculate the difference between endTime and startTime', function () {
      job.setProperties(timeDataCorrect);
      expect(job.get('duration')).to.equal(1000);
    });
    it('should calculate the difference between current time and startTime if the job is running', function () {
      job.setProperties(timeDataRunning);
      expect(job.get('duration')).to.be.at.least(1000);
    });
    it('should calculate the difference between current time and startTime if endTime is incorrect', function () {
      job.setProperties(timeDataIncorrect);
      expect(job.get('duration')).to.be.at.least(1000);
    });
  });

  describe('#durationDisplay', function () {
    it('should return formatted string', function () {
      job.setProperties(timeDataCorrect);
      expect(job.get('durationDisplay')).to.equal('1.00 secs');
    });
  });

});

});

;require.register("test/models/jobs/tez_dag_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/jobs/tez_dag');

var vertex,
  vertexData = {
    id: 'vertex'
  },
  timeData = {
    startTime: 1000,
    endTime: 2000
  },
  tasksCases = [
    {
      count: 5,
      number: 5,
      title: 'should return tasks count'
    },
    {
      count: null,
      number: 0,
      title: 'should return 0'
    }
  ],
  dataSizeCases = [
    {
      file: 'fileReadBytes',
      hdfs: 'hdfsReadBytes',
      total: 'totalReadBytes',
      totalDisplay: 'totalReadBytesDisplay'
    },
    {
      file: 'fileWriteBytes',
      hdfs: 'hdfsWriteBytes',
      total: 'totalWriteBytes',
      totalDisplay: 'totalWriteBytesDisplay'
    }
  ],
  setDataSize = function (vertex, fileProp, fileVal, hdfsProp, hdfsVal) {
    vertex.set(fileProp, fileVal);
    vertex.set(hdfsProp, hdfsVal);
  };

describe('App.TezDagVertex', function () {

  beforeEach(function () {
    vertex = App.TezDagVertex.createRecord(vertexData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(vertex);
  });

  describe('#duration', function () {
    it('should calculate the difference between endTime and startTime', function () {
      vertex.setProperties(timeData);
      expect(vertex.get('duration')).to.equal(1000);
    });
  });

  tasksCases.forEach(function(item) {
    describe('#tasksNumber', function () {
      it(item.title, function () {
        vertex.set('tasksCount', item.count);
        expect(vertex.get('tasksNumber')).to.equal(item.number);
      });
    });
  });

  dataSizeCases.forEach(function (item) {
    describe('#' + item.total, function () {
      it('should sum ' + item.file + ' and ' + item.hdfs, function () {
        setDataSize(vertex, item.file, 1024, item.hdfs, 2048);
        expect(vertex.get(item.total)).to.equal(3072);
      });
    });
    describe('#' + item.totalDisplay, function () {
      it('should return formatted ' + item.total, function () {
        setDataSize(vertex, item.file, 1024, item.hdfs, 2048);
        expect(vertex.get(item.totalDisplay)).to.equal('3 KB');
      });
    });
  });

  describe('#durationDisplay', function () {
    it('should return formatted string', function () {
      vertex.setProperties(timeData);
      expect(vertex.get('durationDisplay')).to.equal('1.00 secs');
    });
  });

});

});

;require.register("test/models/rack_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/host');
require('models/rack');

describe('App.Rack', function () {

  var data = {
    id: 'rack1',
    name: 'rack1'
  };

  App.store.load(App.Rack, data);

  describe('#liveHostsCount', function () {

    it('rack1 has two live hosts', function () {
      var rack = App.Rack.find().findProperty('name', 'rack1');
      expect(rack.get('liveHostsCount')).to.equal(2);
    });

    it('rack1 has three live hosts', function () {
      App.store.load(App.Host, {
        id: 'host3',
        host_name: 'host3',
        health_status: 'HEALTHY'
      });
      var rack = App.Rack.find().findProperty('name', 'rack1');
      rack.set('name', 'rack1');
      expect(rack.get('liveHostsCount')).to.equal(3);
    });
  });


});

});

;require.register("test/models/run_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/run');

var run,
  job,
  runData = {
    id: 'run'
  },
  jobData = {
    id: 'job'
  },
  cases = [
    {
      id: 'pig_run',
      type: 'Pig'
    },
    {
      id: 'hive_run',
      type: 'Hive'
    },
    {
      id: 'mr_run',
      type: 'MapReduce'
    },
    {
      id: 'run_pig_hive_mr_id',
      type: ''
    }
  ];

describe('App.Run', function () {

  beforeEach(function () {
    run = App.Run.createRecord(runData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(run);
  });

  describe('#idFormatted', function () {
    it('should shorten id to 20 characters', function () {
      for (var i = 21, name = ''; i--; ) {
        name += 'n';
      }
      run.set('id', name);
      expect(run.get('idFormatted')).to.have.length(20);
    });
  });

  describe('#jobs', function () {

    beforeEach(function () {
      job = App.Job.createRecord(jobData);
      job.reopen({
        run: runData
      });
    });

    afterEach(function () {
      modelSetup.deleteRecord(job);
    });

    it('should load corresponding jobs from the store', function () {
      run.set('loadAllJobs', true);
      expect(run.get('jobs')).to.have.length(1);
      expect(run.get('jobs').objectAt(0).get('run.id')).to.equal('run');
    });

  });

  describe('#duration', function () {
    it('should convert elapsedTime into time format', function () {
      run.set('elapsedTime', 1000);
      expect(run.get('duration')).to.equal('1.00 secs');
    });
  });

  describe('#isRunning', function () {
    it('should be true', function () {
      run.setProperties({
        numJobsTotal: 5,
        numJobsCompleted: 0
      });
      expect(run.get('isRunning')).to.be.true;
    });
    it('should be false', function () {
      run.setProperties({
        numJobsTotal: 5,
        numJobsCompleted: 5
      });
      expect(run.get('isRunning')).to.be.false;
    });
  });

  describe('#inputFormatted', function () {
    it('should convert input into bandwidth format', function () {
      run.set('input', 1024);
      expect(run.get('inputFormatted')).to.equal('1.0KB');
    });
  });

  describe('#outputFormatted', function () {
    it('should convert output into bandwidth format', function () {
      run.set('output', 1024);
      expect(run.get('outputFormatted')).to.equal('1.0KB');
    });
  });

  describe('#lastUpdateTime', function () {
    it('should sum elapsedTime and startTime', function () {
      run.setProperties({
        elapsedTime: 1000,
        startTime: 2000
      });
      expect(run.get('lastUpdateTime')).to.equal(3000);
    });
  });

  describe('#lastUpdateTimeFormatted', function () {
    it('should form date from lastUpdateTime', function () {
      run.setProperties({
        elapsedTime: 1000,
        startTime: 100000000000
      });
      expect(run.get('lastUpdateTimeFormatted')).to.equal('Sat, Mar 03, 1973 09:46');
    });
  });

  describe('#lastUpdateTimeFormattedShort', function () {
    it('should form date and time from lastUpdateTime', function () {
      run.setProperties({
        elapsedTime: 1000,
        startTime: 100000000000
      });
      expect(run.get('lastUpdateTimeFormattedShort')).to.equal('Sat Mar 03 1973');
    });
  });

  describe('#type', function () {
    cases.forEach(function (item) {
      it('should be ' + (item.type ? item.type : 'empty'), function () {
        run.set('id', item.id);
        expect(run.get('type')).to.equal(item.type);
      });
    });
  });

});

});

;require.register("test/models/service/flume_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/service/flume');

var flumeAgent,
  flumeAgentData = {
    id: 'agent',
    name: 'agent'
  },
  cases = [
    {
      status: 'RUNNING',
      healthClass: App.healthIconClassGreen
    },
    {
      status: 'NOT_RUNNING',
      healthClass: App.healthIconClassRed
    },
    {
      status: 'UNKNOWN',
      healthClass: App.healthIconClassYellow
    },
    {
      status: 'ANOTHER_STATUS',
      healthClass: App.healthIconClassYellow
    }
  ];

describe('App.FlumeAgent', function () {

  beforeEach(function () {
    flumeAgent = App.FlumeAgent.createRecord(flumeAgentData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(flumeAgent);
  });

  describe('#healthClass', function () {
    cases.forEach(function (item) {
      var healthClass = item.healthClass;
      it('should be ' + healthClass, function () {
        flumeAgent.set('status', item.status);
        expect(flumeAgent.get('healthClass')).to.equal(healthClass);
      });
    });
  });

});

});

;require.register("test/models/service/hdfs_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * License); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/service/hdfs');

var hdfsService,
  hdfsServiceData = {
    id: 'hdfs'
  },
  hostComponentsData = [
    {
      id: 'journalnode',
      componentName: 'JOURNALNODE'
    }
  ],
  cases = [
    {
      propertyName: 'journalNodes',
      componentId: 'journalnode'
    }
  ];

describe('App.HDFSService', function () {

  beforeEach(function () {
    hdfsService = App.HDFSService.createRecord(hdfsServiceData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(hdfsService);
  });

  cases.forEach(function (item) {
    var propertyName = item.propertyName;
    describe('#' + propertyName, function () {
      it('should take one component from hostComponents', function () {
        hdfsService.reopen({
          hostComponents: hostComponentsData
        });
        expect(hdfsService.get(propertyName)).to.have.length(1);
        expect(hdfsService.get(propertyName)[0].id).to.equal(item.componentId);
      });
    });
  });

});

});

;require.register("test/models/service/yarn_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * License); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/service/yarn');

var yarnService,
  yarnServiceData = {
    id: 'yarn'
  },
  hostComponentsData = [
    {
      id: 'ats',
      componentName: 'APP_TIMELINE_SERVER',
      host: {
        id: 'host'
      }
    },
    {
      id: 'nodemanager',
      componentName: 'NODEMANAGER',
      host: {
        id: 'host'
      }
    },
    {
      id: 'yarnclient',
      componentName: 'YARN_CLIENT',
      host: {
        id: 'host'
      }
    }
  ],
  configs = [
    {
      properties: {
        'yarn.timeline-service.webapp.address': '0.0.0.0:0000'
      },
      tag: 'version2',
      type: 'yarn-site'
    }
  ],
  nodeCountCases = [
    {
      assets: {
        nodeManagersStarted: 0,
        nodeManagersInstalled: 1,
        nodeManagersTotal: 1,
        nodeManagersCountActive: 0,
        nodeManagersCountRebooted: 0,
        nodeManagersCountUnhealthy: 0,
        nodeManagersCountDecommissioned: 0
      },
      nodeManagersCountLost: 1
    },
    {
      assets: {
        nodeManagersStarted: 1,
        nodeManagersInstalled: 1,
        nodeManagersTotal: 1,
        nodeManagersCountActive: 1,
        nodeManagersCountRebooted: 1,
        nodeManagersCountUnhealthy: 0,
        nodeManagersCountDecommissioned: 0
      },
      nodeManagersCountLost: 0
    }
  ],
  setHostComponents = function () {
    yarnService.reopen({
      hostComponents: hostComponentsData
    });
  };

describe('App.YARNService', function () {

  beforeEach(function () {
    yarnService = App.YARNService.createRecord(yarnServiceData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(yarnService);
  });

  describe('#appTimelineServerNode', function () {
    it('should take one component from hostComponents', function () {
      yarnService.reopen({
        hostComponents: hostComponentsData
      });
      expect(yarnService.get('appTimelineServerNode.id')).to.equal('host');
    });
  });

  describe('#ahsWebPort', function () {

    afterEach(function () {
      App.db.setConfigs([]);
    });

    it('should be 8188 as default', function () {
      App.db.setConfigs([]);
      expect(yarnService.get('ahsWebPort')).to.equal('8188');
    });

    it('should get value from configs', function () {
      App.db.setConfigs(configs);
      expect(yarnService.get('ahsWebPort')).to.equal('0000');
    });

  });

  describe('#queueFormatted', function () {
    it('should return formatted string', function () {
      yarnService.set('queue', '{"root":{"default":{}}}');
      expect(yarnService.get('queueFormatted')).to.equal('default (/root)<br/>');
    });
  });

  describe('#queuesCount', function () {
    it('should be 1', function () {
      yarnService.set('queue', '{"root":{"default":{}}}');
      expect(yarnService.get('queuesCount')).to.equal(1);
    });
  });

  describe('#maxMemory', function () {
    it('should add availableMemory to allocatedMemory', function () {
      yarnService.set('allocatedMemory', 1024);
      yarnService.set('availableMemory', 2048);
      expect(yarnService.get('maxMemory')).to.equal(3072);
    });
  });

  describe('#allQueueNames', function () {
    it('should list all queue names as array', function () {
      yarnService.set('queue', '{"root":{"default":{}}}');
      expect(yarnService.get('allQueueNames')).to.eql(['root', 'root/default']);
    });
  });

  describe('#childQueueNames', function () {
    it('should list child queue names as array', function () {
      yarnService.set('queue', '{"root":{"default":{}}}');
      expect(yarnService.get('childQueueNames')).to.eql(['root/default']);
    });
  });

  describe('#nodeManagersCountLost', function () {
    nodeCountCases.forEach(function (item) {
      it('should be ' + item.nodeManagersCountLost, function () {
        setHostComponents();
        for (var prop in item.assets) {
          yarnService.set(prop, item.assets[prop]);
        };
        expect(yarnService.get('nodeManagersCountLost')).to.equal(item.nodeManagersCountLost);
      });
    });
  });

});

});

;require.register("test/models/service_config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/service_config');

var serviceConfig,
  serviceConfigCategory,
  group,
  serviceConfigProperty,
  serviceConfigPropertyInit,
  configsData = [
    {
      overrides: [
        {
          error: true,
          errorMessage: 'error'
        },
        {
          error: true
        },
        {}
      ]
    },
    {
      isValid: false,
      isVisible: true
    },
    {
      isValid: true,
      isVisible: true
    },    {
      isValid: false,
      isVisible: false
    }
  ],
  configCategoriesData = [
    Em.Object.create({
      slaveErrorCount: 1
    }),
    Em.Object.create({
      slaveErrorCount: 2
    })
  ],
  nameCases = [
    {
      name: 'DataNode',
      primary: 'DATANODE'
    },
    {
      name: 'TaskTracker',
      primary: 'TASKTRACKER'
    },
    {
      name: 'RegionServer',
      primary: 'HBASE_REGIONSERVER'
    },
    {
      name: 'name',
      primary: null
    }
  ],
  components = [
    {
      name: 'NameNode',
      master: true
    },
    {
      name: 'SNameNode',
      master: true
    },
    {
      name: 'JobTracker',
      master: true
    },
    {
      name: 'HBase Master',
      master: true
    },
    {
      name: 'Oozie Master',
      master: true
    },
    {
      name: 'Hive Metastore',
      master: true
    },
    {
      name: 'WebHCat Server',
      master: true
    },
    {
      name: 'ZooKeeper Server',
      master: true
    },
    {
      name: 'Nagios',
      master: true
    },
    {
      name: 'Ganglia',
      master: true
    },
    {
      name: 'DataNode',
      slave: true
    },
    {
      name: 'TaskTracker',
      slave: true
    },
    {
      name: 'RegionServer',
      slave: true
    }
  ],
  masters = components.filterProperty('master'),
  slaves = components.filterProperty('slave'),
  groupsData = {
    groups: [
      Em.Object.create({
        errorCount: 1
      }),
      Em.Object.create({
        errorCount: 2
      })
    ]
  },
  groupNoErrorsData = [].concat(configsData.slice(2)),
  groupErrorsData = [configsData[1]],
  overridableFalseData = [
    {
      isOverridable: false
    },
    {
      isEditable: false,
      overrides: configsData[0].overrides
    },
    {
      displayType: 'masterHost'
    }
  ],
  overridableTrueData = [
    {
      isOverridable: true,
      isEditable: true
    },    {
      isOverridable: true,
      overrides: []
    },
    {
      isOverridable: true
    }
  ],
  overriddenFalseData = [
    {
      overrides: null,
      isOriginalSCP: true
    },
    {
      overrides: [],
      isOriginalSCP: true
    }
  ],
  overriddenTrueData = [
    {
      overrides: configsData[0].overrides
    },
    {
      isOriginalSCP: false
    }
  ],
  removableFalseData = [
    {
      isEditable: false
    },
    {
      hasOverrides: true
    },
    {
      isUserProperty: false,
      isOriginalSCP: true
    }
  ],
  removableTrueData = [
    {
      isEditable: true,
      hasOverrides: false,
      isUserProperty: true
    },
    {
      isEditable: true,
      hasOverrides: false,
      isOriginalSCP: false
    }
  ],
  initPropertyData = [
    {
      initial: {
        displayType: 'password',
        value: 'value'
      },
      result: {
        retypedPassword: 'value'
      }
    },
    {
      initial: {
        id: 'puppet var',
        value: '',
        defaultValue: 'default'
      },
      result: {
        value: 'default'
      }
    }
  ],
  notDefaultFalseData = [
    {
      isEditable: false
    },
    {
      defaultValue: null
    },
    {
      value: 'value',
      defaultValue: 'value'
    }
  ],
  notDefaultTrueData = {
    isEditable: true,
    value: 'value',
    defaultValue: 'default'
  },
  types = ['masterHost', 'slaveHosts', 'masterHosts', 'slaveHost', 'radio button'],
  classCases = [
    {
      initial: {
        displayType: 'checkbox'
      },
      viewClass: App.ServiceConfigCheckbox
    },
    {
      initial: {
        displayType: 'password'
      },
      viewClass: App.ServiceConfigPasswordField
    },
    {
      initial: {
        displayType: 'combobox'
      },
      viewClass: App.ServiceConfigComboBox
    },
    {
      initial: {
        displayType: 'radio button'
      },
      viewClass: App.ServiceConfigRadioButtons
    },
    {
      initial: {
        displayType: 'directories'
      },
      viewClass: App.ServiceConfigTextArea
    },
    {
      initial: {
        displayType: 'content'
      },
      viewClass: App.ServiceConfigTextAreaContent

    },
    {
      initial: {
        displayType: 'multiLine'
      },
      viewClass: App.ServiceConfigTextArea
    },
    {
      initial: {
        displayType: 'custom'
      },
      viewClass: App.ServiceConfigBigTextArea
    },
    {
      initial: {
        displayType: 'masterHost'
      },
      viewClass: App.ServiceConfigMasterHostView
    },
    {
      initial: {
        displayType: 'masterHosts'
      },
      viewClass: App.ServiceConfigMasterHostsView
    },
    {
      initial: {
        displayType: 'slaveHosts'
      },
      viewClass: App.ServiceConfigSlaveHostsView
    },
    {
      initial: {
        unit: true,
        displayType: 'type'
      },
      viewClass: App.ServiceConfigTextFieldWithUnit
    },
    {
      initial: {
        unit: false,
        displayType: 'type'
      },
      viewClass: App.ServiceConfigTextField
    }
  ];


describe('App.ServiceConfig', function () {

  beforeEach(function () {
    serviceConfig = App.ServiceConfig.create();
  });

  describe('#errorCount', function () {
    it('should be 0', function () {
      serviceConfig.setProperties({
        configs: [],
        configCategories: []
      });
      expect(serviceConfig.get('errorCount')).to.equal(0);
    });
    it('should sum counts of all errors', function () {
      serviceConfig.setProperties({
        configs: configsData,
        configCategories: configCategoriesData
      });
      expect(serviceConfig.get('errorCount')).to.equal(6);
    });
  });

});

describe('App.ServiceConfigCategory', function () {

  beforeEach(function () {
    serviceConfigCategory = App.ServiceConfigCategory.create();
  });

  describe('#primaryName', function () {
    nameCases.forEach(function (item) {
      it('should return ' + item.primary, function () {
        serviceConfigCategory.set('name', item.name);
        expect(serviceConfigCategory.get('primaryName')).to.equal(item.primary);
      })
    });
  });

  describe('#isForMasterComponent', function () {
    masters.forEach(function (item) {
      it('should be true for ' + item.name, function () {
        serviceConfigCategory.set('name', item.name);
        expect(serviceConfigCategory.get('isForMasterComponent')).to.be.true;
      });
    });
    it('should be false', function () {
      serviceConfigCategory.set('name', 'name');
      expect(serviceConfigCategory.get('isForMasterComponent')).to.be.false;
    });
  });

  describe('#isForSlaveComponent', function () {
    slaves.forEach(function (item) {
      it('should be true for ' + item.name, function () {
        serviceConfigCategory.set('name', item.name);
        expect(serviceConfigCategory.get('isForSlaveComponent')).to.be.true;
      });
    });
    it('should be false', function () {
      serviceConfigCategory.set('name', 'name');
      expect(serviceConfigCategory.get('isForSlaveComponent')).to.be.false;
    });
  });

  describe('#slaveErrorCount', function () {
    it('should be 0', function () {
      serviceConfigCategory.set('slaveConfigs', []);
      expect(serviceConfigCategory.get('slaveErrorCount')).to.equal(0);
    });
    it('should sum all errorCount values', function () {
      serviceConfigCategory.set('slaveConfigs', groupsData);
      expect(serviceConfigCategory.get('slaveErrorCount')).to.equal(3);
    });
  });

  describe('#isAdvanced', function () {
    it('should be true', function () {
      serviceConfigCategory.set('name', 'Advanced');
      expect(serviceConfigCategory.get('isAdvanced')).to.be.true;
    });
    it('should be false', function () {
      serviceConfigCategory.set('name', 'name');
      expect(serviceConfigCategory.get('isAdvanced')).to.be.false;
    });
  });

});

describe('App.Group', function () {

  beforeEach(function () {
    group = App.Group.create();
  });

  describe('#errorCount', function () {
    it('should be 0', function () {
      group.set('properties', groupNoErrorsData);
      expect(group.get('errorCount')).to.equal(0);
    });
    it('should be 1', function () {
      group.set('properties', groupErrorsData);
      expect(group.get('errorCount')).to.equal(1);
    });
  });

});

describe('App.ServiceConfigProperty', function () {

  beforeEach(function () {
    serviceConfigProperty = App.ServiceConfigProperty.create();
  });

  describe('#overrideErrorTrigger', function () {
    it('should be an increment', function () {
      serviceConfigProperty.set('overrides', configsData[0].overrides);
      expect(serviceConfigProperty.get('overrideErrorTrigger')).to.equal(1);
      serviceConfigProperty.set('overrides', []);
      expect(serviceConfigProperty.get('overrideErrorTrigger')).to.equal(2);
    });
  });

  describe('#isPropertyOverridable', function () {
    overridableFalseData.forEach(function (item) {
      it('should be false', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isPropertyOverridable')).to.be.false;
      });
    });
    overridableTrueData.forEach(function (item) {
      it('should be true', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isPropertyOverridable')).to.be.true;
      });
    });
  });

  describe('#isOverridden', function () {
    overriddenFalseData.forEach(function (item) {
      it('should be false', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isOverridden')).to.be.false;
      });
    });
    overriddenTrueData.forEach(function (item) {
      it('should be true', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isOverridden')).to.be.true;
      });
    });
  });

  describe('#isRemovable', function () {
    removableFalseData.forEach(function (item) {
      it('should be false', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isRemovable')).to.be.false;
      });
    });
    removableTrueData.forEach(function (item) {
      it('should be true', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isRemovable')).to.be.true;
      });
    });
  });

  describe('#init', function () {
    initPropertyData.forEach(function (item) {
      it('should set initial data', function () {
        serviceConfigPropertyInit = App.ServiceConfigProperty.create(item.initial);
        Em.keys(item.result).forEach(function (prop) {
          expect(serviceConfigPropertyInit.get(prop)).to.equal(item.result[prop]);
        });
      });
    });
  });

  describe('#isNotDefaultValue', function () {
    notDefaultFalseData.forEach(function (item) {
      it('should be false', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isNotDefaultValue')).to.be.false;
      });
    });
    it('should be true', function () {
      Em.keys(notDefaultTrueData).forEach(function (prop) {
        serviceConfigProperty.set(prop, notDefaultTrueData[prop]);
      });
      expect(serviceConfigProperty.get('isNotDefaultValue')).to.be.true;
    });
  });

  describe('#cantBeUndone', function () {
    types.forEach(function (item) {
      it('should be true', function () {
        serviceConfigProperty.set('displayType', item);
        expect(serviceConfigProperty.get('cantBeUndone')).to.be.true;
      });
    });
    it('should be false', function () {
      serviceConfigProperty.set('displayType', 'type');
      expect(serviceConfigProperty.get('cantBeUndone')).to.be.false;
    });
  });

  describe('#setDefaultValue', function () {
    it('should change the default value', function () {
      serviceConfigProperty.set('defaultValue', 'value0');
      serviceConfigProperty.setDefaultValue(/\d/, '1');
      expect(serviceConfigProperty.get('defaultValue')).to.equal('value1');
    });
  });

  describe('#isValid', function () {
    it('should be true', function () {
      serviceConfigProperty.set('errorMessage', '');
      expect(serviceConfigProperty.get('isValid')).to.be.true;
    });
    it('should be false', function () {
      serviceConfigProperty.set('errorMessage', 'message');
      expect(serviceConfigProperty.get('isValid')).to.be.false;
    });
  });

  describe('#viewClass', function () {
    classCases.forEach(function (item) {
      it ('should be ' + item.viewClass, function () {
        Em.keys(item.initial).forEach(function (prop) {
          serviceConfigProperty.set(prop, item.initial[prop]);
        });
        expect(serviceConfigProperty.get('viewClass')).to.eql(item.viewClass);
      });
    });
  });

  describe('#validate', function () {
    it('not required', function () {
      serviceConfigProperty.setProperties({
        isRequired: false,
        value: ''
      });
      expect(serviceConfigProperty.get('errorMessage')).to.be.empty;
      expect(serviceConfigProperty.get('error')).to.be.false;
    });
    it('should validate', function () {
      serviceConfigProperty.setProperties({
        isRequired: true,
        value: 'value'
      });
      expect(serviceConfigProperty.get('errorMessage')).to.be.empty;
      expect(serviceConfigProperty.get('error')).to.be.false;
    });
    it('should fail', function () {
      serviceConfigProperty.setProperties({
        isRequired: true,
        value: 'value'
      });
      serviceConfigProperty.set('value', '');
      expect(serviceConfigProperty.get('errorMessage')).to.equal('This is required');
      expect(serviceConfigProperty.get('error')).to.be.true;
    });
  });

});

});

;require.register("test/models/service_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/service');

var service,
  serviceData = {
    id: 'service'
  },
  healthCases = [
    {
      status: 'STARTED',
      health: 'green'
    },
    {
      status: 'STARTING',
      health: 'green-blinking'
    },
    {
      status: 'INSTALLED',
      health: 'red'
    },
    {
      status: 'STOPPING',
      health: 'red-blinking'
    },
    {
      status: 'UNKNOWN',
      health: 'yellow'
    },
    {
      status: 'ANOTHER',
      health: 'yellow'
    }
  ],
  statusPropertiesCases = [
    {
      status: 'INSTALLED',
      property: 'isStopped'
    },
    {
      status: 'STARTED',
      property: 'isStarted'
    }
  ],
  services = [
    {
      name: 'HDFS',
      configurable: true
    },
    {
      name: 'YARN',
      configurable: true
    },
    {
      name: 'MAPREDUCE',
      configurable: true
    },
    {
      name: 'MAPREDUCE2',
      configurable: true
    },
    {
      name:'TEZ',
      clientOnly: true,
      configurable: true
    },
    {
      name: 'HBASE',
      configurable: true
    },
    {
      name: 'HIVE',
      configurable: true
    },
    {
      name: 'HCATALOG',
      clientOnly: true
    },
    {
      name: 'WEBHCAT',
      configurable: true
    },
    {
      name: 'FLUME',
      configurable: true
    },
    {
      name: 'FALCON',
      configurable: true
    },
    {
      name: 'STORM',
      configurable: true
    },
    {
      name: 'OOZIE',
      configurable: true
    },
    {
      name: 'GANGLIA',
      configurable: true
    },
    {
      name: 'NAGIOS',
      configurable: true
    },
    {
      name: 'ZOOKEEPER',
      configurable: true
    },
    {
      name: 'PIG',
      configurable: true,
      clientOnly: true
    },
    {
      name: 'SQOOP',
      clientOnly: true
    },
    {
      name: 'HUE',
      configurable: true
    }
  ],
  clientsOnly = services.filterProperty('clientOnly').mapProperty('name'),
  configurable = services.filterProperty('configurable').mapProperty('name'),
  hostComponentsDataFalse = [
    [],
    [
      {
        staleConfigs: false
      }
    ],
    [
      {
        serviceName: 'HIVE',
        staleConfigs: false
      }
    ]
  ],
  hostComponentsDataTrue = [
    [
      Em.Object.create({
        staleConfigs: true,
        displayName: 'service0'
      })
    ],
    [
      Em.Object.create({
        host: {
          publicHostName: 'host0'
        },
        staleConfigs: true,
        displayName: 'service1'
      })
    ]
  ],
  restartData = {
    host0: ['service0', 'service1']
};

describe('App.Service', function () {

  beforeEach(function () {
    service = App.Service.createRecord(serviceData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(service);
  });

  describe('#isInPassive', function () {
    it('should be true', function () {
      service.set('passiveState', 'ON');
      expect(service.get('isInPassive')).to.be.true;
    });
    it('should be false', function () {
      service.set('passiveState', 'OFF');
      expect(service.get('isInPassive')).to.be.false;
    });
  });

  describe('#healthStatus', function () {
    healthCases.forEach(function (item) {
      it('should be ' + item.health, function () {
        service.set('workStatus', item.status);
        expect(service.get('healthStatus')).to.equal(item.health);
      });
    });
  });

  statusPropertiesCases.forEach(function (item) {
    var status = item.status,
      property = item.property;
    describe('#' + property, function () {
      it('status ' + status + ' is for ' + property, function () {
        service.set('workStatus', status);
        expect(service.get(property)).to.be.true;
        var falseStates = statusPropertiesCases.mapProperty('property').without(property);
        var falseStatuses = [];
        falseStates.forEach(function (state) {
          falseStatuses.push(service.get(state));
        });
        expect(falseStatuses).to.eql([false]);
      });
    });
  });

  describe('#isClientsOnly', function () {
    clientsOnly.forEach(function (item) {
      it('should be true', function () {
        service.set('serviceName', item);
        expect(service.get('isClientsOnly')).to.be.true;
      });
    });
    it('should be false', function () {
      service.set('serviceName', 'HDFS');
      expect(service.get('isClientsOnly')).to.be.false;
    });
  });

  describe('#isConfigurable', function () {
    configurable.forEach(function (item) {
      it('should be true', function () {
        service.set('serviceName', item);
        expect(service.get('isConfigurable')).to.be.true;
      });
    });
    it('should be false', function () {
      service.set('serviceName', 'SQOOP');
      expect(service.get('isConfigurable')).to.be.false;
    });
  });

  describe('#displayName', function () {
    services.forEach(function (item) {
      var displayName = App.Service.DisplayNames[item.name];
      it('should return ' + displayName, function () {
        service.set('serviceName', item.name);
        expect(service.get('displayName')).to.equal(displayName);
      });
    });
  });

  describe('#isRestartRequired', function () {
    hostComponentsDataFalse.forEach(function (item) {
      it('should be false', function () {
        service.reopen({
          hostComponents: item
        });
        expect(service.get('isRestartRequired')).to.be.false;
      });
    });
    hostComponentsDataTrue.forEach(function (item) {
      it('should be true', function () {
        service.reopen({
          hostComponents: item
        });
        expect(service.get('isRestartRequired')).to.be.true;
      });
    });
  });

  describe('#restartRequiredMessage', function () {
    it('should form message for 2 services on 1 host', function () {
      service.set('restartRequiredHostsAndComponents', restartData);
      expect(service.get('restartRequiredMessage')).to.contain('host0');
      expect(service.get('restartRequiredMessage')).to.contain('service0');
      expect(service.get('restartRequiredMessage')).to.contain('service1');
    });
  });

});

});

;require.register("test/models/stack_service_component_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/stack_service_component');

var stackServiceComponent,
  stackServiceComponentData = {
    id: 'ssc'
  },
  components = [
    {
      name: 'NAMENODE',
      isReassignable: true
    },
    {
      name: 'SECONDARY_NAMENODE',
      isReassignable: true
    },
    {
      name: 'JOBTRACKER',
      isReassignable: true
    },
    {
      name: 'RESOURCEMANAGER',
      isReassignable: true
    },
    {
      name: 'SUPERVISOR',
      isDeletable: true,
      isRollinRestartAllowed: true,
      isAddableToHost: true
    },
    {
      name: 'HBASE_MASTER',
      isDeletable: true,
      isAddableToHost: true
    },
    {
      name: 'DATANODE',
      isDeletable: true,
      isRollinRestartAllowed: true,
      isDecommissionAllowed: true,
      isAddableToHost: true
    },
    {
      name: 'TASKTRACKER',
      isDeletable: true,
      isRollinRestartAllowed: true,
      isDecommissionAllowed: true,
      isAddableToHost: true
    },
    {
      name: 'NODEMANAGER',
      isDeletable: true,
      isRollinRestartAllowed: true,
      isDecommissionAllowed: true,
      isAddableToHost: true
    },
    {
      name: 'HBASE_REGIONSERVER',
      isDeletable: true,
      isRollinRestartAllowed: true,
      isDecommissionAllowed: true,
      isAddableToHost: true
    },
    {
      name: 'GANGLIA_MONITOR',
      isDeletable: true,
      isAddableToHost: true
    },
    {
      name: 'FLUME_HANDLER',
      isRefreshConfigsAllowed: true
    },
    {
      name: 'ZOOKEEPER_SERVER',
      isAddableToHost: true
    },
    {
      name: 'MYSQL_SERVER',
      mastersNotShown: true
    },
    {
      name: 'JOURNALNODE',
      mastersNotShown: true
    }
  ],
  reassignable = components.filterProperty('isReassignable').mapProperty('name'),
  deletable = components.filterProperty('isDeletable').mapProperty('name'),
  rollingRestartable = components.filterProperty('isRollinRestartAllowed').mapProperty('name'),
  decommissionable = components.filterProperty('isDecommissionAllowed').mapProperty('name'),
  refreshable = components.filterProperty('isRefreshConfigsAllowed').mapProperty('name'),
  addable = components.filterProperty('isAddableToHost').mapProperty('name'),
  mastersNotShown = components.filterProperty('mastersNotShown').mapProperty('name');

describe('App.StackServiceComponent', function () {

  beforeEach(function () {
    stackServiceComponent = App.StackServiceComponent.createRecord(stackServiceComponentData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(stackServiceComponent);
  });

  describe('#displayName', function () {
    components.forEach(function (item) {
      var displayName = App.format.components[item.name];
      it('should be ' + displayName, function () {
        stackServiceComponent.set('componentName', item.name);
        expect(stackServiceComponent.get('displayName')).to.equal(displayName);
      });
    });
  });

  describe('#isSlave', function () {
    it('should be true', function () {
      stackServiceComponent.set('componentCategory', 'SLAVE');
      expect(stackServiceComponent.get('isSlave')).to.be.true;
    });
    it('should be false', function () {
      stackServiceComponent.set('componentCategory', 'cc');
      expect(stackServiceComponent.get('isSlave')).to.be.false;
    });
  });

  describe('#isRestartable', function () {
    it('should be true', function () {
      stackServiceComponent.set('isClient', false);
      expect(stackServiceComponent.get('isRestartable')).to.be.true;
    });
    it('should be false', function () {
      stackServiceComponent.set('isClient', true);
      expect(stackServiceComponent.get('isRestartable')).to.be.false;
    });
  });

  describe('#isReassignable', function () {
    reassignable.forEach(function (item) {
      it('should be true', function () {
        stackServiceComponent.set('componentName', item);
        expect(stackServiceComponent.get('isReassignable')).to.be.true;
      });
    });
    it('should be false', function () {
      stackServiceComponent.set('componentName', 'name');
      expect(stackServiceComponent.get('isReassignable')).to.be.false;
    });
  });

  describe('#isDeletable', function () {
    deletable.forEach(function (item) {
      it('should be true', function () {
        stackServiceComponent.set('componentName', item);
        expect(stackServiceComponent.get('isDeletable')).to.be.true;
      });
    });
    it('should be false', function () {
      stackServiceComponent.set('componentName', 'name');
      expect(stackServiceComponent.get('isDeletable')).to.be.false;
    });
  });

  describe('#isRollinRestartAllowed', function () {
    rollingRestartable.forEach(function (item) {
      it('should be true', function () {
        stackServiceComponent.set('componentName', item);
        expect(stackServiceComponent.get('isRollinRestartAllowed')).to.be.true;
      });
    });
    it('should be false', function () {
      stackServiceComponent.set('componentName', 'name');
      expect(stackServiceComponent.get('isRollinRestartAllowed')).to.be.false;
    });
  });

  describe('#isDecommissionAllowed', function () {
    decommissionable.forEach(function (item) {
      it('should be true', function () {
        stackServiceComponent.set('componentName', item);
        expect(stackServiceComponent.get('isDecommissionAllowed')).to.be.true;
      });
    });
    it('should be false', function () {
      stackServiceComponent.set('componentName', 'name');
      expect(stackServiceComponent.get('isDecommissionAllowed')).to.be.false;
    });
  });

  describe('#isRefreshConfigsAllowed', function () {
    refreshable.forEach(function (item) {
      it('should be true', function () {
        stackServiceComponent.set('componentName', item);
        expect(stackServiceComponent.get('isRefreshConfigsAllowed')).to.be.true;
      });
    });
    it('should be false', function () {
      stackServiceComponent.set('componentName', 'name');
      expect(stackServiceComponent.get('isRefreshConfigsAllowed')).to.be.false;
    });
  });

  describe('#isAddableToHost', function () {
    addable.forEach(function (item) {
      it('should be true', function () {
        stackServiceComponent.set('componentName', item);
        expect(stackServiceComponent.get('isAddableToHost')).to.be.true;
      });
    });
    it('should be false', function () {
      stackServiceComponent.set('componentName', 'name');
      expect(stackServiceComponent.get('isAddableToHost')).to.be.false;
    });
  });

  describe('#isShownOnInstallerAssignMasterPage', function () {
    mastersNotShown.forEach(function (item) {
      it('should be false', function () {
        stackServiceComponent.set('componentName', item);
        expect(stackServiceComponent.get('isShownOnInstallerAssignMasterPage')).to.be.false;
      });
    });
    it('should be true', function () {
      stackServiceComponent.set('componentName', 'APP_TIMELINE_SERVER');
      expect(stackServiceComponent.get('isShownOnInstallerAssignMasterPage')).to.be.true;
    });
    it('should be true', function () {
      stackServiceComponent.setProperties({
        componentName: 'name',
        isMaster: true
      });
      expect(stackServiceComponent.get('isShownOnInstallerAssignMasterPage')).to.be.true;
    });
  });

});

});

;require.register("test/models/user_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/user');

var user,
  form,
  userNameField,
  userData = {
    id: 'user'
  },
  objectData = Em.Object.create({
    userName: 'name',
    isLdap: true
  });

describe('App.User', function () {

  beforeEach(function () {
    user = App.User.createRecord(userData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(user);
  });

  describe('#id', function () {
    it('should take value from userName', function () {
      user.set('userName', 'name');
      expect(user.get('id')).to.equal('name');
    });
  });

  describe('#type', function () {
    it('should be LDAP', function () {
      user.set('isLdap', true);
      expect(user.get('type')).to.equal('LDAP');
    });
    it('should be Local', function () {
      user.set('isLdap', false);
      expect(user.get('type')).to.equal('Local');
    });
  });

});

describe('App.EditUserForm', function () {

  beforeEach(function () {
    form = App.EditUserForm.create();
  });

  describe('#object', function () {

    before(function () {
      sinon.stub(App.router, 'get', function (k) {
        if (k === 'mainAdminUserEditController.content') return userData;
        return Em.get(App.router, k);
      });
    });

    after(function () {
      App.router.get.restore();
    });

    it('should take data from controller', function () {
      expect(form.get('object')).to.eql(userData);
    });

  });

  describe('#disableUsername', function () {
    it('should update userName field', function () {
      form.set('object', userData);
      expect(form.get('field.userName.disabled')).to.equal('disabled');
    });
  });

  describe('#disableAdminCheckbox', function () {

    before(function () {
      sinon.stub(App, 'get', function(k) {
        switch (k) {
          case 'router':
            return {
              getLoginName: Em.K
            };
          case 'supports.ldapGroupMapping':
            return true;
          default:
            return Em.get(App, k);
        }
      });
      sinon.stub(App.router, 'get', function (k) {
        if (k === 'mainAdminUserEditController.content') return objectData;
        return Em.get(App.router, k);
      });
    });

    after(function () {
      App.get.restore();
      App.router.get.restore();
    });

    it('should not disable', function () {
      expect(form.get('field.admin.disabled')).to.be.false;
    });

    it('should disable', function () {
      form.set('object', objectData);
      expect(form.get('field.admin.disabled')).to.be.true;
    });

  });

  describe('#isValid', function () {
    it('should be true as default', function () {
      expect(form.isValid()).to.be.true;
    });
    it('should be false', function () {
      form.set('field.new_password.isRequired', true);
      expect(form.isValid()).to.be.false;
    });
  });

  describe('#save', function () {

    before(function () {
      sinon.stub(App.router, 'get', function (k) {
        if (k === 'mainAdminUserEditController.content') return objectData;
        return Em.get(App.router, k);
      });
    });

    after(function () {
      App.router.get.restore();
    });

    it('should record form values to object', function () {
      form.set('field.userName.value', 'name');
      form.save();
      expect(form.get('object.userName')).to.equal('name');
    });
  });

});

describe('App.CreateUserForm', function () {

  beforeEach(function () {
    form = App.CreateUserForm.create();
  });

  describe('#object', function () {

    before(function () {
      sinon.stub(App.router, 'get', function (k) {
        if (k === 'mainAdminUserCreateController.content') return userData;
        return Em.get(App, k);
      });
    });

    after(function () {
      App.router.get.restore();
    });

    it('should take data from controller', function () {
      expect(form.get('object')).to.eql(userData);
    });

  });

  describe('#field.userName.toLowerCase', function () {
    it('should convert userName into lower case', function () {
      userNameField = form.getField('userName');
      userNameField.set('value', 'NAME');
      expect(userNameField.get('value')).to.equal('name');
    });
  });

  describe('#isValid', function () {
    it('should be false as default', function () {
      expect(form.isValid()).to.be.false;
    });
    it('should be true', function () {
      form.get('fields').forEach(function (item) {
        if (item.get('isRequired')) {
          item.set('value', 'value');
        }
      });
      expect(form.isValid()).to.be.true;
    });
  });

  describe('#isWarn', function () {
    it('should be false as default', function () {
      expect(form.isWarn()).to.be.false;
    });
    it('should be true', function () {
      form.getField('userName').set('value', '1');
      expect(form.isWarn()).to.be.true;
    });
    it('should be false', function () {
      form.getField('userName').set('value', 'name');
      expect(form.isWarn()).to.be.false;
    });
  });

});

});

;require.register("test/service_components", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = {
  "items" : [
    {
      "StackServices" : {
        "comments" : "Apache Hadoop Distributed Processing Framework",
        "service_name" : "MAPREDUCE",
        "service_version" : "1.2.0.1.3.3.0",
        "stack_name" : "HDP",
        "stack_version" : "1.3.2"
      },
      "serviceComponents" : [
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "HISTORYSERVER",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "MAPREDUCE",
            "stack_name" : "HDP",
            "stack_version" : "1.3.2"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "JOBTRACKER",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "MAPREDUCE",
            "stack_name" : "HDP",
            "stack_version" : "1.3.2"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "CLIENT",
            "component_name" : "MAPREDUCE_CLIENT",
            "is_client" : true,
            "is_master" : false,
            "service_name" : "MAPREDUCE",
            "stack_name" : "HDP",
            "stack_version" : "1.3.2"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "SLAVE",
            "component_name" : "TASKTRACKER",
            "is_client" : false,
            "is_master" : false,
            "service_name" : "MAPREDUCE",
            "stack_name" : "HDP",
            "stack_version" : "1.3.2"
          }
        }
      ]
    },
    {
      "StackServices" : {
        "comments" : "Data management and processing platform",
        "service_name" : "FALCON",
        "service_version" : "0.4.0.2.1.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1"
      },
      "serviceComponents" : [
        {
          "StackServiceComponents" : {
            "component_category" : "CLIENT",
            "component_name" : "FALCON_CLIENT",
            "is_client" : true,
            "is_master" : false,
            "service_name" : "FALCON",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "FALCON_SERVER",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "FALCON",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        }
      ]
    },
    {
      "StackServices" : {
        "comments" : "Ganglia Metrics Collection system",
        "service_name" : "GANGLIA",
        "service_version" : "3.5.0",
        "stack_name" : "HDP",
        "stack_version" : "2.1"
      },
      "serviceComponents" : [
        {
          "StackServiceComponents" : {
            "component_category" : "SLAVE",
            "component_name" : "GANGLIA_MONITOR",
            "is_client" : false,
            "is_master" : false,
            "service_name" : "GANGLIA",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "GANGLIA_SERVER",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "GANGLIA",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        }
      ]
    },
    {
      "StackServices" : {
        "comments" : "Non-relational distributed database and centralized service for configuration management &\n        synchronization\n      ",
        "service_name" : "HBASE",
        "service_version" : "0.96.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1"
      },
      "serviceComponents" : [
        {
          "StackServiceComponents" : {
            "component_category" : "CLIENT",
            "component_name" : "HBASE_CLIENT",
            "is_client" : true,
            "is_master" : false,
            "service_name" : "HBASE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "HBASE_MASTER",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HBASE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "SLAVE",
            "component_name" : "HBASE_REGIONSERVER",
            "is_client" : false,
            "is_master" : false,
            "service_name" : "HBASE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        }
      ]
    },
    {
      "StackServices" : {
        "comments" : "This is comment for HCATALOG service",
        "service_name" : "HCATALOG",
        "service_version" : "0.12.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1"
      },
      "serviceComponents" : [
        {
          "StackServiceComponents" : {
            "component_category" : "CLIENT",
            "component_name" : "HCAT",
            "is_client" : true,
            "is_master" : false,
            "service_name" : "HCATALOG",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        }
      ]
    },
    {
      "StackServices" : {
        "comments" : "Apache Hadoop Distributed File System",
        "service_name" : "HDFS",
        "service_version" : "2.1.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1"
      },
      "serviceComponents" : [
        {
          "StackServiceComponents" : {
            "component_category" : "SLAVE",
            "component_name" : "DATANODE",
            "is_client" : false,
            "is_master" : false,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "CLIENT",
            "component_name" : "HDFS_CLIENT",
            "is_client" : true,
            "is_master" : false,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "JOURNALNODE",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "NAMENODE",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "SECONDARY_NAMENODE",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "SLAVE",
            "component_name" : "ZKFC",
            "is_client" : false,
            "is_master" : false,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        }
      ]
    },
    {
      "StackServices" : {
        "comments" : "Data warehouse system for ad-hoc queries & analysis of large datasets and table & storage management service",
        "service_name" : "HIVE",
        "service_version" : "0.12.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1"
      },
      "serviceComponents" : [
        {
          "StackServiceComponents" : {
            "component_category" : "CLIENT",
            "component_name" : "HIVE_CLIENT",
            "is_client" : true,
            "is_master" : false,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "HIVE_METASTORE",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "HIVE_SERVER",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "MYSQL_SERVER",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        }
      ]
    },
    {
      "StackServices" : {
        "comments" : "Apache Hadoop NextGen MapReduce (YARN)",
        "service_name" : "MAPREDUCE2",
        "service_version" : "2.1.0.2.0.6.0",
        "stack_name" : "HDP",
        "stack_version" : "2.1"
      },
      "serviceComponents" : [
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "HISTORYSERVER",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "MAPREDUCE2",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "CLIENT",
            "component_name" : "MAPREDUCE2_CLIENT",
            "is_client" : true,
            "is_master" : false,
            "service_name" : "MAPREDUCE2",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        }
      ]
    },
    {
      "StackServices" : {
        "comments" : "Nagios Monitoring and Alerting system",
        "service_name" : "NAGIOS",
        "service_version" : "3.5.0",
        "stack_name" : "HDP",
        "stack_version" : "2.1"
      },
      "serviceComponents" : [
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "NAGIOS_SERVER",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "NAGIOS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        }
      ]
    },
    {
      "StackServices" : {
        "comments" : "System for workflow coordination and execution of Apache Hadoop jobs.  This also includes the installation of the optional Oozie Web Console which relies on and will install the <a target=\"_blank\" href=\"http://www.sencha.com/products/extjs/license/\">ExtJS</a> Library.\n      ",
        "service_name" : "OOZIE",
        "service_version" : "4.0.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1"
      },
      "serviceComponents" : [
        {
          "StackServiceComponents" : {
            "component_category" : "CLIENT",
            "component_name" : "OOZIE_CLIENT",
            "is_client" : true,
            "is_master" : false,
            "service_name" : "OOZIE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "OOZIE_SERVER",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "OOZIE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        }
      ]
    },
    {
      "StackServices" : {
        "comments" : "Scripting platform for analyzing large datasets",
        "service_name" : "PIG",
        "service_version" : "0.12.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1"
      },
      "serviceComponents" : [
        {
          "StackServiceComponents" : {
            "component_category" : "CLIENT",
            "component_name" : "PIG",
            "is_client" : true,
            "is_master" : false,
            "service_name" : "PIG",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        }
      ]
    },
    {
      "StackServices" : {
        "comments" : "Tool for transferring bulk data between Apache Hadoop and\n        structured data stores such as relational databases\n      ",
        "service_name" : "SQOOP",
        "service_version" : "1.4.4.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1"
      },
      "serviceComponents" : [
        {
          "StackServiceComponents" : {
            "component_category" : "CLIENT",
            "component_name" : "SQOOP",
            "is_client" : true,
            "is_master" : false,
            "service_name" : "SQOOP",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        }
      ]
    },
    {
      "StackServices" : {
        "comments" : "Apache Hadoop Stream processing framework",
        "service_name" : "STORM",
        "service_version" : "0.9.0.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1"
      },
      "serviceComponents" : [
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "DRPC_SERVER",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "LOGVIEWER_SERVER",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "NIMBUS",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "STORM_REST_API",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "STORM_UI_SERVER",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "SLAVE",
            "component_name" : "SUPERVISOR",
            "is_client" : false,
            "is_master" : false,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        }
      ]
    },
    {
      "StackServices" : {
        "comments" : "Tez is the next generation Hadoop Query Processing framework written on top of YARN.",
        "service_name" : "TEZ",
        "service_version" : "0.4.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1"
      },
      "serviceComponents" : [
        {
          "StackServiceComponents" : {
            "component_category" : "CLIENT",
            "component_name" : "TEZ_CLIENT",
            "is_client" : true,
            "is_master" : false,
            "service_name" : "TEZ",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        }
      ]
    },
    {
      "StackServices" : {
        "comments" : "This is comment for WEBHCAT service",
        "service_name" : "WEBHCAT",
        "service_version" : "0.12.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1"
      },
      "serviceComponents" : [
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "WEBHCAT_SERVER",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "WEBHCAT",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        }
      ]
    },
    {
      "StackServices" : {
        "comments" : "Apache Hadoop NextGen MapReduce (YARN)",
        "service_name" : "YARN",
        "service_version" : "2.1.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1"
      },
      "serviceComponents" : [
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "APP_TIMELINE_SERVER",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "YARN",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "SLAVE",
            "component_name" : "NODEMANAGER",
            "is_client" : false,
            "is_master" : false,
            "service_name" : "YARN",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "RESOURCEMANAGER",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "YARN",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "CLIENT",
            "component_name" : "YARN_CLIENT",
            "is_client" : true,
            "is_master" : false,
            "service_name" : "YARN",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        }
      ]
    },
    {
      "StackServices" : {
        "comments" : "Centralized service which provides highly reliable distributed\n        coordination.",
        "service_name" : "ZOOKEEPER",
        "service_version" : "3.4.5.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1"
      },
      "serviceComponents" : [
        {
          "StackServiceComponents" : {
            "component_category" : "CLIENT",
            "component_name" : "ZOOKEEPER_CLIENT",
            "is_client" : true,
            "is_master" : false,
            "service_name" : "ZOOKEEPER",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        },
        {
          "StackServiceComponents" : {
            "component_category" : "MASTER",
            "component_name" : "ZOOKEEPER_SERVER",
            "is_client" : false,
            "is_master" : true,
            "service_name" : "ZOOKEEPER",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          }
        }
      ]
    }
  ]
};
});

;require.register("test/utils/ajax/ajax_queue_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var ajaxQueue;

describe('App.ajaxQueue', function () {

  beforeEach(function() {
    ajaxQueue = App.ajaxQueue.create();
    sinon.spy(ajaxQueue, 'runNextRequest');
    sinon.spy(ajaxQueue, 'finishedCallback');
    sinon.spy(App.ajax, 'send');
  });

  afterEach(function() {
    ajaxQueue.clear();
    ajaxQueue.runNextRequest.restore();
    ajaxQueue.finishedCallback.restore();
    App.ajax.send.restore();
  });

  describe('#clear', function() {
    it('should clear queue', function() {
      ajaxQueue.addRequest({name:'some', sender: Em.Object.create()});
      ajaxQueue.clear();
      expect(ajaxQueue.get('queue.length')).to.equal(0);
    });
  });

  describe('#addRequest', function() {
    it('should add request', function() {
      ajaxQueue.addRequest({name:'some', sender: Em.Object.create()});
      expect(ajaxQueue.get('queue.length')).to.equal(1);
    });
    it('should throw `name` error', function() {
      expect(function() {ajaxQueue.addRequest({name:'', sender: Em.Object.create()})}).to.throw(Error);
    });
    it('should throw `sender` error', function() {
      expect(function() {ajaxQueue.addRequest({name:'some', sender: {}})}).to.throw(Error);
    });
  });

  describe('#addRequests', function() {
    it('should add requests', function() {
      ajaxQueue.addRequests(Em.A([
        {name:'some', sender: Em.Object.create()},
        {name:'some2', sender: Em.Object.create()}
      ]));
      expect(ajaxQueue.get('queue.length')).to.equal(2);
    });

    it('should throw `name` error', function() {
      expect(function() {ajaxQueue.addRequests(Em.A([
        {name:'some', sender: Em.Object.create()},
        {name:'', sender: Em.Object.create()}
      ]));}).to.throw(Error);
    });

    it('should throw `sender` error', function() {
      expect(function() {ajaxQueue.addRequests(Em.A([
        {name:'some', sender: Em.Object.create()},
        {name:'some2', sender: {}}
      ]));}).to.throw(Error);
    });

  });

  describe('#start', function() {
    it('should call runNextRequest', function() {
      ajaxQueue.start();
      expect(ajaxQueue.runNextRequest.called).to.equal(true);
    });
  });

  describe('#runNextRequest', function() {
    it('for empty queue App.ajax.send shouldn\'t be called', function() {
      ajaxQueue.clear();
      ajaxQueue.runNextRequest();
      expect(App.ajax.send.called).to.equal(false);
    });
    it('when queue is empty finishedCallback should be called', function() {
      ajaxQueue.clear();
      ajaxQueue.runNextRequest();
      expect(ajaxQueue.finishedCallback.called).to.equal(true);
    });
    it('if abortOnError is false queue shouldn\'t be interrupted', function() {
      ajaxQueue.clear();
      ajaxQueue.set('abortOnError', false);
      ajaxQueue.addRequest({name:'some_fake', sender: Em.Object.create()}).addRequest({name: 'some_fake2', sender: Em.Object.create()}).start();
      expect(ajaxQueue.runNextRequest.callCount).to.equal(3); // One for empty-queue
    });
  });

});

});

;require.register("test/utils/ajax/ajax_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/ajax/ajax');

describe('App.ajax', function() {

  beforeEach(function() {
    App.set('apiPrefix', '/api/v1');
    App.set('clusterName', 'tdk');
    sinon.spy($, 'ajax');
  });

  afterEach(function() {
    $.ajax.restore();
  });

  describe('#send', function() {

    it('Without sender', function() {
      expect(App.ajax.send({})).to.equal(null);
      expect($.ajax.called).to.equal(false);
    });

    it('Invalid config.name', function() {
      expect(App.ajax.send({name:'fake_name', sender: this})).to.equal(null);
      expect($.ajax.called).to.equal(false);
    });

    it('With proper data', function() {
      App.ajax.send({name: 'router.logoff', sender: this});
      expect($.ajax.calledOnce).to.equal(true);
    });

  });

  describe('#formatUrl', function() {

    var tests = [
      {
        url: null,
        data: {},
        e: null,
        m: 'url is null'
      },
      {
        url: 'site/{param}',
        data: null,
        e: 'site/',
        m: 'url with one param, but data is null'
      },
      {
        url: 'clean_url',
        data: {},
        e: 'clean_url',
        m: 'url without placeholders'
      },
      {
        url: 'site/{param}',
        data: {},
        e: 'site/',
        m: 'url with param, but there is no such param in the data'
      },
      {
        url: 'site/{param}/{param}',
        data: {param: 123},
        e: 'site/123/123',
        m: 'url with param which appears two times'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        var r = App.ajax.fakeFormatUrl(test.url, test.data);
        expect(r).to.equal(test.e);
      });
    });
  });

  describe('Check "real" and "mock" properties for each url object', function() {
    var names = App.ajax.fakeGetUrlNames();
    names.forEach(function(name) {
      it(name, function() {
        var url = App.ajax.fakeGetUrl(name);
        expect(url.real).to.be.a('string');
        expect(url.real.length > 0).to.equal(true);
        expect(url.mock).to.be.a('string');
      });
    });
  });

  describe('#formatRequest', function() {

    beforeEach(function() {
      App.testMode = false;
    });
    afterEach(function() {
      App.testMode = true;
    });

    it('App.testMode = true', function() {
      App.testMode = true;
      var r = App.ajax.fakeFormatRequest({real:'/', mock: '/some_url'}, {});
      expect(r.type).to.equal('GET');
      expect(r.url).to.equal('/some_url');
      expect(r.dataType).to.equal('json');
    });
    var tests = [
      {
        urlObj: {
          real: '/real_url',
          format: function() {
            return {
              type: 'PUT'
            }
          }
        },
        data: {},
        m: '',
        e: {type: 'PUT', url: '/api/v1/real_url'}
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        var r = App.ajax.fakeFormatRequest(test.urlObj, test.data);
        expect(r.type).to.equal(test.e.type);
        expect(r.url).to.equal(test.e.url);
      });
    });
  });

});

});

;require.register("test/utils/batch_scheduled_requests_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('utils/helper');
require('views/common/rolling_restart_view');
var batchUtils = require('utils/batch_scheduled_requests');
var modelSetup = require('test/init_model_test');
describe('batch_scheduled_requests', function() {

  beforeEach(function(){
    modelSetup.setupStackServiceComponent();
  });
  afterEach(function(){
    modelSetup.cleanStackServiceComponent();
  });

  describe('#getRollingRestartComponentName', function() {
    var tests = [
      {serviceName: 'HDFS', componentName: 'DATANODE'},
      {serviceName: 'YARN', componentName: 'NODEMANAGER'},
      {serviceName: 'MAPREDUCE', componentName: 'TASKTRACKER'},
      {serviceName: 'HBASE', componentName: 'HBASE_REGIONSERVER'},
      {serviceName: 'STORM', componentName: 'SUPERVISOR'},
      {serviceName: 'SOME_INVALID_SERVICE', componentName: null}
    ];

    tests.forEach(function(test) {
      it(test.serviceName + ' - ' + test.componentName, function() {
        expect(batchUtils.getRollingRestartComponentName(test.serviceName)).to.equal(test.componentName);
      });
    });

  });

  describe('#getBatchesForRollingRestartRequest', function() {
    var tests = [
      {
        hostComponents: Em.A([
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host1'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host2'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host3'}})
        ]),
        batchSize: 2,
        m: 'DATANODES on three hosts, batchSize = 2',
        e: {
          batchCount: 2
        }
      },
      {
        hostComponents: Em.A([
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host1'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host2'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host3'}})
        ]),
        batchSize: 3,
        m: 'DATANODES on 3 hosts, batchSize = 3',
        e: {
          batchCount: 1
        }
      },
      {
        hostComponents: Em.A([
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host1'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host2'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host3'}})
        ]),
        batchSize: 1,
        m: 'DATANODES on 3 hosts, batchSize = 1',
        e: {
          batchCount: 3
        }
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        expect(batchUtils.getBatchesForRollingRestartRequest(test.hostComponents, test.batchSize).length).to.equal(test.e.batchCount);
      });
    });
  });

  describe('#launchHostComponentRollingRestart', function() {

    beforeEach(function() {
      sinon.spy(batchUtils, 'showRollingRestartPopup');
      sinon.spy(batchUtils, 'showWarningRollingRestartPopup');
    });

    afterEach(function() {
      batchUtils.showRollingRestartPopup.restore();
      batchUtils.showWarningRollingRestartPopup.restore();
    });

    var tests = Em.A([
      {componentName: 'DATANODE', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'TASKTRACKER', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'NODEMANAGER', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'HBASE_REGIONSERVER', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'SUPERVISOR', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'SOME_OTHER_COMPONENT', e:{showRollingRestartPopup:false, showWarningRollingRestartPopup:true}}
    ]);

    tests.forEach(function(test) {
      it(test.componentName, function() {
        batchUtils.launchHostComponentRollingRestart(test.componentName);
        expect(batchUtils.showRollingRestartPopup.calledOnce).to.equal(test.e.showRollingRestartPopup);
        expect(batchUtils.showWarningRollingRestartPopup.calledOnce).to.equal(test.e.showWarningRollingRestartPopup);
      });
    });

  });

  describe('#restartHostComponents', function() {

    beforeEach(function() {
      sinon.spy($, 'ajax');
      App.testMode = true;
    });

    afterEach(function() {
      $.ajax.restore();
      App.testMode = false;
    });

    var tests = Em.A([
      {
        hostComponentList: Em.A([
          Em.Object.create({
            componentName: 'n1',
            host: Em.Object.create({
              hostName: 'h1'
            })
          }),
          Em.Object.create({
            componentName: 'n1',
            host: Em.Object.create({
              hostName: 'h2'
            })
          })
        ]),
        e: {
          ajaxCalledOnce: true,
          resource_filters: [{"component_name":"n1","hosts":"h1,h2"}]
        },
        m: '1 component on 2 hosts'
      },
      {
        hostComponentList: Em.A([
          Em.Object.create({
            componentName: 'n1',
            host: Em.Object.create({
              hostName: 'h1'
            })
          }),
          Em.Object.create({
            componentName: 'n1',
            host: Em.Object.create({
              hostName: 'h2'
            })
          }),
          Em.Object.create({
            componentName: 'n2',
            host: Em.Object.create({
              hostName: 'h2'
            })
          })
        ]),
        e: {
          ajaxCalledOnce: true,
          resource_filters: [{"component_name":"n1","hosts":"h1,h2"},{"component_name":"n2","hosts":"h2"}]
        },
        m: '1 component on 2 hosts, 1 on 1 host'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        batchUtils.restartHostComponents(test.hostComponentList);
        expect($.ajax.calledOnce).to.equal(test.e.ajaxCalledOnce);
        expect( JSON.parse($.ajax.args[0][0].data)['Requests/resource_filters']).to.eql(test.e.resource_filters);
      });
    });

    it('Empty data', function() {
      batchUtils.restartHostComponents([]);
      expect($.ajax.called).to.equal(false);
    });

  });

});

});

;require.register("test/utils/component_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var component = require('utils/component');
require('models/host_component');
require('models/stack_service_component');

describe('utils/component', function(){
  describe('#loadStackServiceComponentModel()', function(){
    var data = {
      "items": [
        {
          "serviceComponents": [
            {
              "StackServiceComponents": {
                "component_category": "CLIENT",
                "component_name": "FALCON_CLIENT",
                "is_client": true,
                "is_master": false,
                "service_name": "FALCON",
                "stack_name": "HDP",
                "stack_version": "2.1"
              }
            },
            {
              "StackServiceComponents": {
                "component_category": "MASTER",
                "component_name": "FALCON_SERVER",
                "is_client": false,
                "is_master": true,
                "service_name": "FALCON",
                "stack_name": "HDP",
                "stack_version": "2.1"
              }
            }
          ]
        },
        {
          "serviceComponents": [
            {
              "StackServiceComponents": {
                "component_category": "SLAVE",
                "component_name": "GANGLIA_MONITOR",
                "is_client": false,
                "is_master": false,
                "service_name": "GANGLIA",
                "stack_name": "HDP",
                "stack_version": "2.1"
              }
            },
            {
              "StackServiceComponents": {
                "component_category": "MASTER",
                "component_name": "GANGLIA_SERVER",
                "is_client": false,
                "is_master": true,
                "service_name": "GANGLIA",
                "stack_name": "HDP",
                "stack_version": "2.1"
              }
            }
          ]
        }
      ]
    };

    afterEach(function(){
      App.StackServiceComponent.find().set('content', []);
    });

    it('should return 4 components', function(){
      expect(component.loadStackServiceComponentModel(data).items.length).to.eql(4);
    });

    it('should load data to StackServiceComponent model', function(){
      component.loadStackServiceComponentModel(data);
      expect(App.StackServiceComponent.find().get('content')).have.length(4);
    });
  });
});

});

;require.register("test/utils/config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('config');
require('utils/config');
require('models/service/hdfs');
var setups = require('test/init_model_test');
var modelSetup = setups.configs;

describe('App.config', function () {

  App.supports.capacitySchedulerUi = true;

  var loadServiceSpecificConfigs = function(context, serviceName) {
    context.configGroups = modelSetup.setupConfigGroupsObject(serviceName);
    context.advancedConfigs = modelSetup.setupAdvancedConfigsObject();
    context.tags = modelSetup.setupServiceConfigTagsObject(serviceName);
    context.result = App.config.mergePreDefinedWithLoaded(context.configGroups, context.advancedConfigs, context.tags, App.Service.find().findProperty('id', serviceName).get('serviceName'));
  };

  var loadAllServicesConfigs = function(context, serviceNames) {
    context.configGroups = modelSetup.setupConfigGroupsObject();
  }

  var loadServiceModelsData = function(serviceNames) {
    serviceNames.forEach(function(serviceName) {
      App.store.load(App.Service, {
        id: serviceName,
        service_name: serviceName
      });
    });
  };

  var setupContentForMergeWithStored = function(context) {
    loadServiceModelsData(context.installedServiceNames);
    loadAllServicesConfigs(context);
    setups.setupStackVersion(this, 'HDP-2.1');
    context.result = App.config.mergePreDefinedWithStored(context.storedConfigs, modelSetup.setupAdvancedConfigsObject(), context.installedServiceNames);
  };

  var removeServiceModelData = function(serviceIds) {
    serviceIds.forEach(function(serviceId) {
      var record = App.Service.find(serviceId);
      record.deleteRecord();
      record.get('stateManager').transitionTo('loading');
    });
  };

  describe('#identifyCategory', function () {
    var data = {};
    it('should return null if config doesn\'t have category', function () {
      expect(App.config.identifyCategory(data)).to.equal(null);
    });
    it('should return "AdvancedCoreSite" if filename "core-site.xml" and serviceName "HDFS"', function () {
      data = {
        serviceName: 'HDFS',
        filename: 'core-site.xml'
      };
      expect(App.config.identifyCategory(data).name).to.equal('AdvancedCoreSite');
    });
    it('should return "CapacityScheduler" if filename "capacity-scheduler.xml" and serviceName "YARN"', function () {
      data = {
        serviceName: 'YARN',
        filename: 'capacity-scheduler.xml'
      };
      expect(App.config.identifyCategory(data).name).to.equal('CapacityScheduler');
    });
  });

  describe('#handleSpecialProperties', function () {
    var config = {};
    it('value should be transformed to "1024" from "1024m"', function () {
      config = {
        displayType: 'int',
        value: '1024m',
        defaultValue: '1024m'
      };
      App.config.handleSpecialProperties(config);
      expect(config.value).to.equal('1024');
      expect(config.defaultValue).to.equal('1024');
    });
    it('value should be transformed to true from "true"', function () {
      config = {
        displayType: 'checkbox',
        value: 'true',
        defaultValue: 'true'
      };
      App.config.handleSpecialProperties(config);
      expect(config.value).to.equal(true);
      expect(config.defaultValue).to.equal(true);
    });
    it('value should be transformed to false from "false"', function () {
      config = {
        displayType: 'checkbox',
        value: 'false',
        defaultValue: 'false'
      };
      App.config.handleSpecialProperties(config);
      expect(config.value).to.equal(false);
      expect(config.defaultValue).to.equal(false);
    });
  });

  describe('#calculateConfigProperties', function () {
    var config = {};
    var isAdvanced = false;
    var advancedConfigs = [];
    it('isUserProperty should be true if config is custom(site.xml) and not advanced', function () {
      config = {
        serviceName: 'HDFS',
        filename: 'core-site.xml'
      };
      App.config.calculateConfigProperties(config, isAdvanced, advancedConfigs);
      expect(config.isUserProperty).to.equal(true);
    });

    it('isUserProperty should be false if config from "capacity-scheduler.xml" or "mapred-queue-acls.xml" ', function () {
      config = {
        name: 'test',
        serviceName: 'MAPREDUCE',
        filename: 'capacity-scheduler.xml',
        isUserProperty: false
      };
      isAdvanced = true;
      App.config.calculateConfigProperties(config, isAdvanced, advancedConfigs);
      expect(config.isUserProperty).to.equal(false);
    });

    it('isRequired should be false if config is advanced"', function () {
      config = {
        name: 'test',
        serviceName: 'HDFS',
        filename: 'core-site.xml'
      };
      isAdvanced = true;
      advancedConfigs = [{name:'test', filename: 'core-site.xml'}];
      App.config.calculateConfigProperties(config, isAdvanced, advancedConfigs);
      expect(config.category).to.equal('Advanced');
      expect(config.isRequired).to.equal(true);
      expect(config.filename).to.equal('core-site.xml');
    });
  });

  describe('#capacitySchedulerFilter', function() {
    var testMessage = 'filter should {0} detect `{1}` property';
    describe('Stack version >= 2.0', function() {
      before(function() {
        setups.setupStackVersion(this, 'HDP-2.1');
      });
      var tests = [
        {
          config: {
            name: 'yarn.scheduler.capacity.maximum-am-resource-percent'
          },
          e: false
        },
        {
          config: {
            name: 'yarn.scheduler.capacity.root.capacity'
          },
          e: false
        },
        {
          config: {
            name: 'yarn.scheduler.capacity.root.default.capacity'
          },
          e: true
        }
      ];

      tests.forEach(function(test){
        it(testMessage.format( !!test.e ? '' : 'not', test.config.name), function() {
          expect(App.config.get('capacitySchedulerFilter')(test.config)).to.eql(test.e);
        });
      });
      after(function() {
        setups.restoreStackVersion(this);
      })
    });

    describe('Stack version < 2.0', function() {
      before(function() {
        setups.setupStackVersion(this, 'HDP-1.3');
      });
      var tests = [
        {
          config: {
            name: 'mapred.capacity-scheduler.maximum-system-jobs'
          },
          e: false
        },
        {
          config: {
            name: 'yarn.scheduler.capacity.root.capacity'
          },
          e: false
        },
        {
          config: {
            name: 'mapred.capacity-scheduler.queue.default.capacity'
          },
          e: true
        },
        {
          config: {
            name: 'mapred.queue.default.acl-administer-jobs'
          },
          e: true
        }
      ];

      tests.forEach(function(test){
        it(testMessage.format( !!test.e ? '' : 'not', test.config.name), function() {
          expect(App.config.get('capacitySchedulerFilter')(test.config)).to.eql(test.e);
        });
      });

      after(function() {
        setups.restoreStackVersion(this);
      });
    });
  });

  describe('#fileConfigsIntoTextarea', function () {
    var filename = 'capacity-scheduler.xml';
    var configs = [
      {
        name: 'config1',
        value: 'value1',
        defaultValue: 'value1',
        filename: 'capacity-scheduler.xml'
      },
      {
        name: 'config2',
        value: 'value2',
        defaultValue: 'value2',
        filename: 'capacity-scheduler.xml'
      }
    ];
    it('two configs into textarea', function () {
      var result = App.config.fileConfigsIntoTextarea.call(App.config, configs, filename);
      expect(result.length).to.equal(1);
      expect(result[0].value).to.equal('config1=value1\nconfig2=value2\n');
      expect(result[0].defaultValue).to.equal('config1=value1\nconfig2=value2\n');
    });
    it('three config into textarea', function () {
      configs.push({
        name: 'config3',
        value: 'value3',
        defaultValue: 'value3',
        filename: 'capacity-scheduler.xml'
      });
      var result = App.config.fileConfigsIntoTextarea.call(App.config, configs, filename);
      expect(result.length).to.equal(1);
      expect(result[0].value).to.equal('config1=value1\nconfig2=value2\nconfig3=value3\n');
      expect(result[0].defaultValue).to.equal('config1=value1\nconfig2=value2\nconfig3=value3\n');
    });
    it('one of three configs has different filename', function () {
      configs[1].filename = 'another filename';
      var result = App.config.fileConfigsIntoTextarea.call(App.config, configs, filename);
      //result contains two configs: one with different filename and one textarea config
      expect(result.length).to.equal(2);
      expect(result[1].value).to.equal('config1=value1\nconfig3=value3\n');
      expect(result[1].defaultValue).to.equal('config1=value1\nconfig3=value3\n');
    });
    it('none configs into empty textarea', function () {
      filename = 'capacity-scheduler.xml';
      configs.clear();
      var result = App.config.fileConfigsIntoTextarea.call(App.config, configs, filename);
      expect(result.length).to.equal(1);
      expect(result[0].value).to.equal('');
      expect(result[0].defaultValue).to.equal('');
    });

  });

  describe('#textareaIntoFileConfigs', function () {
    var filename = 'capacity-scheduler.xml';
    var testData = [
      {
        configs: [Em.Object.create({
          "name": "capacity-scheduler",
          "value": "config1=value1",
          "filename": "capacity-scheduler.xml"
        })]
      },
      {
        configs: [Em.Object.create({
          "name": "capacity-scheduler",
          "value": "config1=value1\nconfig2=value2\n",
          "filename": "capacity-scheduler.xml"
        })]
      },
      {
        configs: [Em.Object.create({
          "name": "capacity-scheduler",
          "value": "config1=value1,value2\n",
          "filename": "capacity-scheduler.xml"
        })]
      },
      {
        configs: [Em.Object.create({
          "name": "capacity-scheduler",
          "value": "config1=value1 config2=value2\n",
          "filename": "capacity-scheduler.xml"
        })]
      }
    ];

    it('config1=value1 to one config', function () {
      var result = App.config.textareaIntoFileConfigs.call(App.config, testData[0].configs, filename);
      expect(result.length).to.equal(1);
      expect(result[0].value).to.equal('value1');
      expect(result[0].name).to.equal('config1');
    });
    it('config1=value1\\nconfig2=value2\\n to two configs', function () {
      var result = App.config.textareaIntoFileConfigs.call(App.config, testData[1].configs, filename);
      expect(result.length).to.equal(2);
      expect(result[0].value).to.equal('value1');
      expect(result[0].name).to.equal('config1');
      expect(result[1].value).to.equal('value2');
      expect(result[1].name).to.equal('config2');
    });
    it('config1=value1,value2\n to one config', function () {
      var result = App.config.textareaIntoFileConfigs.call(App.config, testData[2].configs, filename);
      expect(result.length).to.equal(1);
      expect(result[0].value).to.equal('value1,value2');
      expect(result[0].name).to.equal('config1');
    });
    it('config1=value1 config2=value2 to two configs', function () {
      var result = App.config.textareaIntoFileConfigs.call(App.config, testData[3].configs, filename);
      expect(result.length).to.equal(1);
    });
  });

  describe('#escapeXMLCharacters', function () {

    var testConfigs = [
      {
        html: '&>"',
        json: '&>"'
      },
      {
        html: '&amp;&gt;&quot;&apos;',
        json: '&>"\''
      },
      {
        html: '&&gt;',
        json: '&>'
      },
      {
        html: '&&&amp;',
        json: '&&&'
      },
      {
        html: 'LD_LIBRARY_PATH=/usr/lib/hadoop/lib/native:/usr/lib/hadoop/lib/native/`$JAVA_HOME/bin/java -d32 -version &amp;&gt; /dev/null;if [ $? -eq 0 ]; then echo Linux-i386-32; else echo Linux-amd64-64;fi`',
        json: 'LD_LIBRARY_PATH=/usr/lib/hadoop/lib/native:/usr/lib/hadoop/lib/native/`$JAVA_HOME/bin/java -d32 -version &> /dev/null;if [ $? -eq 0 ]; then echo Linux-i386-32; else echo Linux-amd64-64;fi`'
      },
      {
        html: '&&&amp;',
        json: '&amp;&amp;&amp;',
        toXml: true
      }
    ];
    testConfigs.forEach(function(t){
      it('parsing html ' + t.html + ' `toXml` param passed ' + !!t.toXml, function () {
        expect(t.json).to.equal(App.config.escapeXMLCharacters(t.html, t.toXml));
      });
    });
  });

  describe('#mergePreDefinedWithLoaded()', function() {
    before(function() {
      loadServiceModelsData(['HDFS','STORM','ZOOKEEPER']);
      setups.setupStackVersion(this, 'HDP-2.1');
    });

    describe('Load STORM configs: global, storm-site', function() {
      before(function() {
        loadServiceSpecificConfigs(this, "STORM");
      });

      it('site property with `masterHosts` display type should pass value validation', function() {
        var property = this.result.configs.findProperty('name', 'storm.zookeeper.servers');
        expect(property).to.be.ok;
        expect(property.displayType).to.eql('masterHosts');
        expect(property.value).to.eql(["c6401.ambari.apache.org", "c6402.ambari.apache.org"]);
        expect(property.category).to.eql('General')
      });
      it('non-predefined global properties should not be displayed on UI', function() {
        var property = this.result.globalConfigs.findProperty('name', 'nonexistent_property');
        expect(property).to.be.a('object');
        expect(property.isVisible).to.be.false;
      });
      it('non-predefined site properties should have displayType advanced/multiLine', function() {
        var tests = [
          {
            property: 'single_line_property',
            e: 'advanced'
          },
          {
            property: 'multi_line_property',
            e: 'multiLine'
          }
        ];
        tests.forEach(function(test) {
          var property = this.result.configs.findProperty('name', test.property);
          expect(property).to.be.ok;
          expect(property.displayType).to.eql(test.e);
        }, this);

      });
    });

    describe('Load HDFS configs: global, hdfs-site, core-site', function() {
      before(function() {
        loadServiceSpecificConfigs(this, "HDFS");
      });

      it('Data Node, Name Node, SName Node directory properties should have sorted values', function() {
        var tests = [
          {
            property: "dfs.datanode.data.dir",
            e: '/a,/b'
          },
          {
            property: "dfs.namenode.name.dir",
            e: '/a,/b,/c'
          },
          {
            property: "dfs.namenode.checkpoint.dir",
            e: '/a'
          }
        ];
        tests.forEach(function(test) {
          var property = this.result.configs.findProperty('name', test.property);
          expect(property).to.be.ok;
          expect(property.value).to.eql(test.e);
        }, this);
      });
    });

    describe('Load ZOOKEEPER configs: global, zoo.cfg', function() {
      before(function() {
        loadServiceSpecificConfigs(this, "ZOOKEEPER");
      });

      it('zoo.cfg configs should have non xml filename', function() {
        expect(this.result.configs.findProperty('name', 'custom.zoo.cfg').filename).to.eql('zoo.cfg');
      });
    });

    after(function() {
      removeServiceModelData(['HDFS','STORM','ZOOKEEPER']);
      setups.restoreStackVersion(this);
    });
  });

  describe('#syncOrderWithPredefined()', function() {
    before(function() {
      setups.setupStackVersion(this, 'HDP-2.1');
      loadServiceModelsData(['HDFS','STORM','ZOOKEEPER']);
      loadServiceSpecificConfigs(this, 'HDFS');
    });
    it('properties should be ordered according to position in predefined data', function() {
      var result = App.config.syncOrderWithPredefined(this.result);
      expect(result).to.be.a('object');
      expect(result.configs.filterProperty('category','DataNode').mapProperty('name')).to.eql(['dfs.datanode.failed.volumes.tolerated', 'dfs.datanode.data.dir']);
    });
    after(function() {
      removeServiceModelData(['HDFS','STORM','ZOOKEEPER']);
    });
  });

  describe('#mergePreDefinedWithStored()', function() {
    describe('without `storedConfigs` parameter', function() {
      before(function() {
        this.installedServiceNames = ['HDFS','STORM', 'ZOOKEEPER'];
        setupContentForMergeWithStored(this);
      });

      var tests = [
        {
          property: 'dfs.datanode.data.dir',
          e: '/hadoop/hdfs/data'
        },
        {
          property: 'dfs.datanode.failed.volumes.tolerated',
          e: '2'
        }
      ];

      tests.forEach(function(test) {
        it('should set value and defaultValue to ' + test.e + ' for `' + test.property + '`', function() {
          expect(this.result.findProperty('name', test.property).value).to.eql(test.e);
          expect(this.result.findProperty('name', test.property).defaultValue).to.eql(test.e);
        });
      });

      after(function() {
        removeServiceModelData(this.installedServiceNames);
        setups.restoreStackVersion(this);
      });
    });

    describe('with `storedConfigs` parameter', function() {
      before(function() {
        this.installedServiceNames = ['HDFS','STORM','ZOOKEEPER'];
        this.storedConfigs = modelSetup.setupStoredConfigsObject();
        setupContentForMergeWithStored(this);
      });

      var tests = [
        {
          property: 'nonexistent_property',
          stored: true,
          e: {
            value: 'some value',
            isVisible: false,
            category: 'Advanced',
            displayType: 'advanced',
            isRequired: true,
            isOverridable: true
          }
        },
        {
          property: 'content',
          filename: 'hdfs-log4j.xml',
          stored: true,
          predefined: true,
          e: {
            value: 'hdfs log4j content',
            defaultValue: 'hdfs log4j content',
            displayType: 'content'
          }
        },
        {
          property: 'content',
          filename: 'zookeeper-log4j.xml',
          stored: false,
          predefined: true,
          e: {
            value: 'zookeeper log4j.xml content',
            defaultValue: 'zookeeper log4j.xml content',
            displayType: 'content'
          }
        }
      ];

      tests.forEach(function(test) {
        it('`{0}` should pass validation. stored/predefined: {1}/{2}'.format(test.property, !!test.stored, !!test.predefined), function() {
          var property = test.property == 'content' ? this.result.filterProperty('name', 'content').findProperty('filename', test.filename) : this.result.findProperty('name', test.property);
          for (var key in test.e) {
            expect(property[key]).to.be.eql(test.e[key]);
          }
        });
      });

      after(function(){
        removeServiceModelData(this.installedServiceNames);
        setups.restoreStackVersion(this);
      });
    });
  });

  describe('#addAvancedConfigs()', function() {
    before(function() {
      this.storedConfigs = modelSetup.setupStoredConfigsObject();
    });

    it('`custom.zoo.cfg` absent in stored configs', function() {
      expect(this.storedConfigs.findProperty('name', 'custom.zoo.cfg')).to.be.undefined;
    });

    it('`custom.zoo.cfg.` from advanced configs should be added to stored configs', function() {
      App.config.addAdvancedConfigs(this.storedConfigs, modelSetup.setupAdvancedConfigsObject(), 'ZOOKEEPER');
      var property = this.storedConfigs.findProperty('name', 'custom.zoo.cfg');
      expect(property).to.be.ok;
      expect(property.category).to.eql('Advanced');
    });

    it('`capacity-scheduler.xml` configs related to `YARN` service should have category `CapacityScheduler`', function() {
      App.config.addAdvancedConfigs(this.storedConfigs, modelSetup.setupAdvancedConfigsObject(), 'YARN');
      expect(this.storedConfigs.filterProperty('filename', 'capacity-scheduler.xml').mapProperty('category').uniq()).to.eql(['CapacityScheduler']);
    });
    it('`capacity-scheduler.xml` property with name `content` should have `displayType` `multiLine`', function() {
      expect(this.storedConfigs.filterProperty('filename', 'capacity-scheduler.xml').findProperty('name','content').displayType).to.eql('multiLine');
    });
  });

  describe('#addCustomConfigs()', function() {
    before(function() {
      setups.setupStackVersion(this, 'HDP-2.1');
      this.storedConfigs = modelSetup.setupStoredConfigsObject();
      App.config.addAdvancedConfigs(this.storedConfigs, modelSetup.setupAdvancedConfigsObject(), 'ZOOKEEPER');
      App.config.addAdvancedConfigs(this.storedConfigs, modelSetup.setupAdvancedConfigsObject(), 'YARN');
    });

    it('`yarn.scheduler.capacity.root.default.capacity` should have `isQueue` flag on', function() {
      App.config.addCustomConfigs(this.storedConfigs);
      expect(this.storedConfigs.findProperty('name','yarn.scheduler.capacity.root.default.capacity').isQueue).to.be.ok;
    });

    after(function() {
      setups.restoreStackVersion(this);
    });
  });

  describe('#createServiceConfig()', function() {
    it('should create valid object for `HDFS`', function() {
      var ServiceConfig = App.config.createServiceConfig('HDFS');
      expect(ServiceConfig.configCategories.mapProperty('name')).to.include.members(["NameNode","SNameNode","DataNode"]);
    });
    it('should create valid object for `YARN` with capacity scheduler flag `on`', function() {
      var ServiceConfig = App.config.createServiceConfig('YARN');
      expect(ServiceConfig.configCategories.mapProperty('name')).to.include.members(["ResourceManager","NodeManager"]);
      expect(ServiceConfig.configCategories.findProperty('name', 'CapacityScheduler').customView).to.be.a('Function');
      expect(ServiceConfig.configCategories.findProperty('name', 'CapacityScheduler').isCustomView).to.true;
    });
    it('should create valid object for `YARN` with capacity scheduler flag `off`', function() {
      App.supports.capacitySchedulerUi = false;
      var ServiceConfig = App.config.createServiceConfig('YARN');
      expect(ServiceConfig.configCategories.mapProperty('name')).to.include.members(["ResourceManager","NodeManager"]);
      expect(ServiceConfig.configCategories.findProperty('name', 'CapacityScheduler').isCustomView).to.false;
      App.supports.capacitySchedulerUi = true;
    });
  });

  describe('#trimProperty',function() {
    var testMessage = 'displayType `{0}`, value `{1}`{3} should return `{2}`';
    var tests = [
      {
        config: {
          displayType: 'directory',
          value: ' /a /b /c'
        },
        e: '/a,/b,/c'
      },
      {
        config: {
          displayType: 'directories',
          value: ' /a /b '
        },
        e: '/a,/b'
      },
      {
        config: {
          displayType: 'host',
          value: ' localhost '
        },
        e: 'localhost'
      },
      {
        config: {
          displayType: 'password',
          value: ' passw ord '
        },
        e: ' passw ord '
      },
      {
        config: {
          displayType: 'advanced',
          value: ' value'
        },
        e: ' value'
      },
      {
        config: {
          displayType: 'advanced',
          value: ' value'
        },
        e: ' value'
      },
      {
        config: {
          displayType: 'advanced',
          value: 'http://localhost ',
          name: 'javax.jdo.option.ConnectionURL'
        },
        e: 'http://localhost'
      },
      {
        config: {
          displayType: 'advanced',
          value: 'http://localhost    ',
          name: 'oozie.service.JPAService.jdbc.url'
        },
        e: 'http://localhost'
      },
      {
        config: {
          displayType: 'custom',
          value: ' custom value '
        },
        e: ' custom value'
      },
      {
        config: {
          displayType: 'masterHosts',
          value: ['host1.com', 'host2.com']
        },
        e: ['host1.com', 'host2.com']
      }
    ];

    tests.forEach(function(test) {
      it(testMessage.format(test.config.displayType, test.config.value, test.e, !!test.config.name ? ', name `' + test.config.name + '`' : ''), function() {
        expect(App.config.trimProperty(test.config)).to.eql(test.e);
        expect(App.config.trimProperty(Em.Object.create(test.config), true)).to.eql(test.e);
      });
    });
  });

  describe('#OnNnHAHideSnn()', function() {
    it('`SNameNode` category present in `ServiceConfig`. It should be removed.', function() {
      App.store.load(App.HDFSService, {
        'id': 'HDFS'
      });
      var ServiceConfig = Em.Object.create({
        configCategories: [ { name: 'SNameNode' } ]
      });
      expect(ServiceConfig.get('configCategories').findProperty('name','SNameNode')).to.ok;
      App.config.OnNnHAHideSnn(ServiceConfig);
      expect(ServiceConfig.get('configCategories').findProperty('name','SNameNode')).to.undefined;
      var record = App.HDFSService.find('HDFS');
      record.deleteRecord();
      record.get('stateManager').transitionTo('loading');
    });
    it('`SNameNode` category absent in `ServiceConfig`. Nothing to do.', function() {
      App.store.load(App.HDFSService, {
        'id': 'HDFS'
      });
      var ServiceConfig = Em.Object.create({
        configCategories: [ { name: 'DataNode' } ]
      });
      App.config.OnNnHAHideSnn(ServiceConfig);
      expect(ServiceConfig.get('configCategories').findProperty('name','DataNode')).to.ok;
      expect(ServiceConfig.get('configCategories.length')).to.eql(1);
    });
  });
});
});

;require.register("test/utils/configs/defaults_providers/hive_defaults_provider_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('utils/configs/defaults_providers/defaultsProvider');
require('utils/configs/defaults_providers/yarn_defaults_provider');

describe('HiveDefaultsProvider', function() {

  describe('#getDefaults', function() {
    var tests = Em.A([
      {
        localDB: {},
        m: 'Empty localDB',
        e: null
      },
      {
        localDB: {
          "masterComponentHosts": []
        },
        m: 'localDB without hosts',
        e: null
      },
      {
        localDB: {
          "hosts": {}
        },
        m: 'localDB without masterComponentHosts amd slaveComponentHosts',
        e: null
      },
      {
        localDB: {
          "hosts": {
            "host1": {"name": "host1","cpu": 8,"memory": "25165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]},
            "host2": {"name": "host2","cpu": 4,"memory": "25165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]}
          },
          "masterComponentHosts": [],
          "slaveComponentHosts": [
            {
              "componentName": "NODEMANAGER",
              "hosts": [{"hostName": "host2"}]
            }
          ]
        },
        m: 'Without HBase',
        e: {
          'mapreduce.map.java.opts': '-Xmx2048m',
          'mapreduce.map.memory.mb': 2560,
          'mapreduce.reduce.java.opts': '-Xmx2048m',
          'mapreduce.reduce.memory.mb': 2560,
          'yarn.app.mapreduce.am.command-opts': '-Xmx2048m',
          'yarn.app.mapreduce.am.resource.mb': 2560,
          'yarn.nodemanager.resource.memory-mb': 20480,
          'yarn.scheduler.maximum-allocation-mb': 20480,
          'yarn.scheduler.minimum-allocation-mb': 2560,
          'mapreduce.task.io.sort.mb': 1024,
          'hive.tez.container.size': 2560,
          'hive.auto.convert.join.noconditionaltask.size': 894435328,
          'hive.tez.java.opts': '-server -Xmx2048m -Djava.net.preferIPv4Stack=true -XX:NewRatio=8 -XX:+UseNUMA -XX:+UseParallelGC'
        }
      },
      {
        localDB: {
          "hosts": {
            "host1": {"name": "host1","cpu": 8,"memory": "25165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]},
            "host2": {"name": "host2","cpu": 4,"memory": "12582912.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]}
          },
          "masterComponentHosts": [
            {"component": "HBASE_MASTER","hostName": "host1","serviceId": "HDFS"}
          ],
          "slaveComponentHosts": [
            {
              "componentName": "NODEMANAGER",
              "hosts": [{"hostName": "host2"}]
            }
          ]
        },
        m: 'With HBase (low memory - pick mapreduce.reduce.memory.mb)',
        e: {
          'mapreduce.map.java.opts': '-Xmx819m',
          'mapreduce.map.memory.mb': 1024,
          'mapreduce.reduce.java.opts': '-Xmx819m',
          'mapreduce.reduce.memory.mb': 1024,
          'yarn.app.mapreduce.am.command-opts': '-Xmx819m',
          'yarn.app.mapreduce.am.resource.mb': 1024,
          'yarn.nodemanager.resource.memory-mb': 8192,
          'yarn.scheduler.maximum-allocation-mb': 8192,
          'yarn.scheduler.minimum-allocation-mb': 1024,
          'mapreduce.task.io.sort.mb': 410,
          'hive.tez.container.size': 1024,
          'hive.auto.convert.join.noconditionaltask.size': 357564416,
          'hive.tez.java.opts': '-server -Xmx819m -Djava.net.preferIPv4Stack=true -XX:NewRatio=8 -XX:+UseNUMA -XX:+UseParallelGC'
        }
      },
      {
        localDB: {
          "hosts": {
            "host1": {"name": "host1","cpu": 8,"memory": "100165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]},
            "host2": {"name": "host2","cpu": 4,"memory": "100165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]}
          },
          "masterComponentHosts": [
            {"component": "HBASE_MASTER","hostName": "host1","serviceId": "HDFS"}
          ],
          "slaveComponentHosts": [
            {
              "componentName": "NODEMANAGER",
              "hosts": [{"hostName": "host2"}]
            }
          ]
        },
        m: 'With HBase (high memory - pick mapreduce.map.memory.mb)',
        e: {
          'mapreduce.map.java.opts': '-Xmx6963m',
          'mapreduce.map.memory.mb': 8704,
          'mapreduce.reduce.java.opts': '-Xmx6963m',
          'mapreduce.reduce.memory.mb': 8704,
          'yarn.app.mapreduce.am.command-opts': '-Xmx6963m',
          'yarn.app.mapreduce.am.resource.mb': 8704,
          'yarn.nodemanager.resource.memory-mb': 69632,
          'yarn.scheduler.maximum-allocation-mb': 69632,
          'yarn.scheduler.minimum-allocation-mb': 8704,
          'mapreduce.task.io.sort.mb': 1024,
          'hive.tez.container.size': 8704,
          'hive.auto.convert.join.noconditionaltask.size': 3041918976,
          'hive.tez.java.opts': '-server -Xmx6963m -Djava.net.preferIPv4Stack=true -XX:NewRatio=8 -XX:+UseNUMA -XX:+UseParallelGC'
        }
      }
    ]);
    tests.forEach(function(test) {
      describe(test.m, function() {
        var defaultsProvider = App.HiveDefaultsProvider.create();
        defaultsProvider.set('clusterData', null);
        var configs = defaultsProvider.getDefaults(test.localDB);
        Em.keys(configs).forEach(function(config) {
          it(config, function() {
            if (test.e) {
              expect(configs[config]).to.equal(test.e[config]);
            }
            else {
              expect(configs[config] == 0 || configs[config] == null).to.equal(true);
            }
          })
        });
      });
    });
  });

});

});

;require.register("test/utils/configs/defaults_providers/tez_defaults_provider_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('utils/configs/defaults_providers/defaultsProvider');
require('utils/configs/defaults_providers/yarn_defaults_provider');

describe('TezDefaultsProvider', function() {

  describe('#getDefaults', function() {
    var tests = [
      {
        localDB: {},
        m: 'Empty localDB',
        e: null
      },
      {
        localDB: {
          "masterComponentHosts": []
        },
        m: 'localDB without hosts',
        e: null
      },
      {
        localDB: {
          "hosts": {}
        },
        m: 'localDB without masterComponentHosts amd slaveComponentHosts',
        e: null
      },
      {
        localDB: {
          "hosts": {
            "host1": {"name": "host1","cpu": 8,"memory": "25165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]},
            "host2": {"name": "host2","cpu": 4,"memory": "25165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]}
          },
          "masterComponentHosts": [],
          "slaveComponentHosts": [
            {
              "componentName": "NODEMANAGER",
              "hosts": [{"hostName": "host2"}]
            }
          ]
        },
        m: 'Without HBase',
        e: {
          'mapreduce.map.java.opts': '-Xmx2048m',
          'mapreduce.map.memory.mb': 2560,
          'mapreduce.reduce.java.opts': '-Xmx2048m',
          'mapreduce.reduce.memory.mb': 2560,
          'yarn.app.mapreduce.am.command-opts': '-Xmx2048m',
          'yarn.app.mapreduce.am.resource.mb': 2560,
          'yarn.nodemanager.resource.memory-mb': 20480,
          'yarn.scheduler.maximum-allocation-mb': 20480,
          'yarn.scheduler.minimum-allocation-mb': 2560,
          'mapreduce.task.io.sort.mb': 1024,
          'tez.am.resource.memory.mb': 2560,
          'tez.am.java.opts': '-server -Xmx2048m -Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC'
        }
      },
      {
        localDB: {
          "hosts": {
            "host1": {"name": "host1","cpu": 8,"memory": "25165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]},
            "host2": {"name": "host2","cpu": 4,"memory": "12582912.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]}
          },
          "masterComponentHosts": [
            {"component": "HBASE_MASTER","hostName": "host1","serviceId": "HDFS"}
          ],
          "slaveComponentHosts": [
            {
              "componentName": "NODEMANAGER",
              "hosts": [{"hostName": "host2"}]
            }
          ]
        },
        m: 'With HBase',
        e: {
          'mapreduce.map.java.opts': '-Xmx819m',
          'mapreduce.map.memory.mb': 1024,
          'mapreduce.reduce.java.opts': '-Xmx819m',
          'mapreduce.reduce.memory.mb': 1024,
          'yarn.app.mapreduce.am.command-opts': '-Xmx819m',
          'yarn.app.mapreduce.am.resource.mb': 1024,
          'yarn.nodemanager.resource.memory-mb': 8192,
          'yarn.scheduler.maximum-allocation-mb': 8192,
          'yarn.scheduler.minimum-allocation-mb': 1024,
          'mapreduce.task.io.sort.mb': 410,
          'tez.am.resource.memory.mb': 1024,
          'tez.am.java.opts': '-server -Xmx819m -Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC'
        }
      }
    ];
    tests.forEach(function(test) {
      describe(test.m, function() {
        var defaultsProvider = App.TezDefaultsProvider.create();
        defaultsProvider.set('clusterData', null);
        var configs = defaultsProvider.getDefaults(test.localDB);
        Em.keys(configs).forEach(function(config) {
          it(config, function() {
            if (test.e) {
              expect(configs[config]).to.equal(test.e[config]);
            } else {
              expect(configs[config] == 0 || configs[config] == null).to.equal(true);
            }
          });
        });
      });
    });
  });

});

});

;require.register("test/utils/configs/defaults_providers/yarn_defaults_provider_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('utils/configs/defaults_providers/defaultsProvider');
require('utils/configs/defaults_providers/yarn_defaults_provider');

var yarnDefaultProvider;

describe('YARNDefaultsProvider', function() {

  beforeEach(function() {
    yarnDefaultProvider = App.YARNDefaultsProvider.create();
  });

  afterEach(function() {
    yarnDefaultProvider.set('clusterData', null);
    yarnDefaultProvider.set('reservedRam', null);
    yarnDefaultProvider.set('hBaseRam', null);
    yarnDefaultProvider.set('containers', null);
    yarnDefaultProvider.set('recommendedMinimumContainerSize', null);
    yarnDefaultProvider.set('ramPerContainer', null);
    yarnDefaultProvider.set('mapMemory', null);
    yarnDefaultProvider.set('reduceMemory', null);
    yarnDefaultProvider.set('amMemory', null);
  });

  describe('#clusterDataIsValid', function() {
    var tests = Em.A([
      {clusterData: {disk: 12,ram: 48,cpu: 12,hBaseInstalled: false},e: true},
      {clusterData: {disk: null,ram: 48,cpu: 12,hBaseInstalled: false},e: false},
      {clusterData: {disk: 12,ram: null,cpu: 12,hBaseInstalled: false},e: false},
      {clusterData: {disk: 12,ram: 48,cpu: null,hBaseInstalled: false},e: false},
      {clusterData: {disk: 12,ram: 48,cpu: 12,hBaseInstalled: null},e: false},
      {clusterData: {disk: 12,ram: 48,cpu: 12},e: false},
      {clusterData: {disk: 12,ram: 48,hBaseInstalled: true},e: false},
      {clusterData: {disk: 12,cpu: 12,hBaseInstalled: true},e: false},
      {clusterData: {ram: 48,cpu: 12,hBaseInstalled: false},e: false}
    ]);
    tests.forEach(function(test) {
      it((test.e?'valid':'invalid') + ' clusterData', function() {
        yarnDefaultProvider.set('clusterData', test.clusterData);
        expect(yarnDefaultProvider.clusterDataIsValid()).to.equal(test.e);
      });
    });
  });

  describe('#reservedMemoryRecommendations', function() {
    var tests = Em.A([
      {ram: null, e: {os: 1, hbase: 1}},
      {ram: 2, e: {os: 1, hbase: 1}},
      {ram: 4, e: {os: 1, hbase: 1}},
      {ram: 6, e: {os: 2, hbase: 1}},
      {ram: 8, e: {os: 2, hbase: 1}},
      {ram: 12, e: {os: 2, hbase: 2}},
      {ram: 16, e: {os: 2, hbase: 2}},
      {ram: 20, e: {os: 4, hbase: 4}},
      {ram: 24, e: {os: 4, hbase: 4}},
      {ram: 36, e: {os: 6, hbase: 8}},
      {ram: 48, e: {os: 6, hbase: 8}},
      {ram: 56, e: {os: 8, hbase: 8}},
      {ram: 64, e: {os: 8, hbase: 8}},
      {ram: 68, e: {os: 8, hbase: 8}},
      {ram: 72, e: {os: 8, hbase: 8}},
      {ram: 84, e: {os: 12, hbase: 16}},
      {ram: 96, e: {os: 12, hbase: 16}},
      {ram: 112, e: {os: 24, hbase: 24}},
      {ram: 128, e: {os: 24, hbase: 24}},
      {ram: 196, e: {os: 32, hbase: 32}},
      {ram: 256, e: {os: 32, hbase: 32}},
      {ram: 384, e: {os: 64, hbase: 64}},
      {ram: 512, e: {os: 64, hbase: 64}},
      {ram: 756, e: {os: 64, hbase: 64}}
    ]);
    tests.forEach(function(test) {
      it('ram: ' + test.ram + ' GB', function() {
        sinon.spy(yarnDefaultProvider, 'reservedMemoryRecommendations');
        yarnDefaultProvider.set('clusterData', {
          disk: 12,
          ram: test.ram,
          cpu: 12,
          hBaseInstalled: false
        });
        expect(yarnDefaultProvider.get('reservedRam')).to.equal(test.e.os);
        expect(yarnDefaultProvider.get('hBaseRam')).to.equal(test.e.hbase);
        expect(yarnDefaultProvider.reservedMemoryRecommendations.calledOnce).to.equal(true);
        yarnDefaultProvider.reservedMemoryRecommendations.restore();
      });
    });
  });

  describe('#recommendedMinimumContainerSize', function() {
    it('No clusterData', function() {
      yarnDefaultProvider.set('clusterData', null);
      expect(yarnDefaultProvider.get('recommendedMinimumContainerSize')).to.equal(null);
    });
    it('No clusterData.ram', function() {
      yarnDefaultProvider.set('clusterData', {});
      expect(yarnDefaultProvider.get('recommendedMinimumContainerSize')).to.equal(null);
    });

    var tests = Em.A([
      {ram: 3, e: 256},
      {ram: 4, e: 256},
      {ram: 6, e: 512},
      {ram: 8, e: 512},
      {ram: 12, e: 1024},
      {ram: 24, e: 1024}
    ]);

    tests.forEach(function(test) {
      it('ram: ' + test.ram + ' GB', function() {
       yarnDefaultProvider.set('clusterData', {
          disk: 12,
          ram: test.ram,
          cpu: 12,
          hBaseInstalled: false
        });
        expect(yarnDefaultProvider.get('recommendedMinimumContainerSize')).to.equal(test.e);
      });
    });

  });

  describe('#containers', function() {
    it('No clusterData', function() {
      yarnDefaultProvider.set('clusterData', null);
      expect(yarnDefaultProvider.get('containers')).to.equal(null);
    });
    it('Some clusterData metric is null', function() {
      yarnDefaultProvider.set('clusterData', {disk: null, cpu: 1, ram: 1});
      expect(yarnDefaultProvider.get('containers')).to.equal(null);
      yarnDefaultProvider.set('clusterData', {disk: 1, cpu: null, ram: 1});
      expect(yarnDefaultProvider.get('containers')).to.equal(null);
      yarnDefaultProvider.set('clusterData', {disk:1, cpu: 1, ram: null});
      expect(yarnDefaultProvider.get('containers')).to.equal(null);
    });

    var tests = Em.A([
      {
        clusterData: {
          disk: 12,
          ram: 48,
          cpu: 12,
          hBaseInstalled: false
        },
        e: 21
      },
      {
        clusterData: {
          disk: 6,
          ram: 48,
          cpu: 6,
          hBaseInstalled: true
        },
        e: 11
      }
    ]);

    tests.forEach(function(test) {
      it((test.hBaseInstalled?'With':'Without') + ' hBase', function() {
        yarnDefaultProvider.set('clusterData', test.clusterData);
        expect(yarnDefaultProvider.get('containers')).to.equal(test.e);
      });
    });

  });

  describe('#ramPerContainer', function() {
    it('No clusterData', function() {
      yarnDefaultProvider.set('clusterData', null);
      expect(yarnDefaultProvider.get('ramPerContainer')).to.equal(null);
    });
    var tests = Em.A([
      {
        clusterData: {
          disk: 12,
          ram: 48,
          cpu: 12,
          hBaseInstalled: false
        },
        e: 2048
      },
      {
        clusterData: {
          disk: 12,
          ram: 16,
          cpu: 12,
          hBaseInstalled: true
        },
        e: 1024
      }
    ]);

    tests.forEach(function(test) {
      it((test.hBaseInstalled?'With':'Without') + ' hBase', function() {
        yarnDefaultProvider.set('clusterData', test.clusterData);
        expect(yarnDefaultProvider.get('ramPerContainer')).to.equal(test.e);
      });
    });
  });

  describe('#getDefaults', function() {
    var tests = Em.A([
      {
        localDB: {},
        m: 'Empty localDB',
        e: null
      },
      {
        localDB: {
          "masterComponentHosts": []
        },
        m: 'localDB without hosts',
        e: null
      },
      {
        localDB: {
          "hosts": {}
        },
        m: 'localDB without masterComponentHosts amd slaveComponentHosts',
        e: null
      },
      {
        localDB: {
          "hosts": {
            "host1": {"name": "host1","cpu": 8,"memory": "25165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]},
            "host2": {"name": "host2","cpu": 4,"memory": "25165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]}
          },
          "masterComponentHosts": [],
          "slaveComponentHosts": [
            {
              "componentName": "NODEMANAGER",
              "hosts": [{"hostName": "host2"}]
            }
          ]
        },
        m: 'Without HBase',
        e: {
          'mapreduce.map.java.opts': '-Xmx2048m',
          'mapreduce.map.memory.mb': 2560,
          'mapreduce.reduce.java.opts': '-Xmx2048m',
          'mapreduce.reduce.memory.mb': 2560,
          'yarn.app.mapreduce.am.command-opts': '-Xmx2048m',
          'yarn.app.mapreduce.am.resource.mb': 2560,
          'yarn.nodemanager.resource.memory-mb': 20480,
          'yarn.scheduler.maximum-allocation-mb': 20480,
          'yarn.scheduler.minimum-allocation-mb': 2560,
          'mapreduce.task.io.sort.mb': 1024
        }
      },
      {
        localDB: {
          "hosts": {
            "host1": {"name": "host1","cpu": 8,"memory": "25165824.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]},
            "host2": {"name": "host2","cpu": 4,"memory": "12582912.00","disk_info": [{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'},{mountpoint:'/'}]}
          },
          "masterComponentHosts": [
            {"component": "HBASE_MASTER","hostName": "host1","serviceId": "HDFS"}
          ],
          "slaveComponentHosts": [
            {
              "componentName": "NODEMANAGER",
              "hosts": [{"hostName": "host2"}]
            }
          ]
        },
        m: 'With HBase',
        e: {
          'mapreduce.map.java.opts': '-Xmx819m',
          'mapreduce.map.memory.mb': 1024,
          'mapreduce.reduce.java.opts': '-Xmx819m',
          'mapreduce.reduce.memory.mb': 1024,
          'yarn.app.mapreduce.am.command-opts': '-Xmx819m',
          'yarn.app.mapreduce.am.resource.mb': 1024,
          'yarn.nodemanager.resource.memory-mb': 8192,
          'yarn.scheduler.maximum-allocation-mb': 8192,
          'yarn.scheduler.minimum-allocation-mb': 1024,
          'mapreduce.task.io.sort.mb': 410
        }
      }
    ]);
    tests.forEach(function(test) {
      yarnDefaultProvider = App.YARNDefaultsProvider.create();
      describe(test.m, function() {
        yarnDefaultProvider.set('clusterData', null);
        var configs = yarnDefaultProvider.getDefaults(test.localDB);

        Em.keys(configs).forEach(function(config) {
          it(config, function() {
            if (test.e) {
              expect(configs[config]).to.equal(test.e[config]);
            }
            else {
              expect(configs[config] == 0 || configs[config] == null).to.equal(true);
            }
          });
        });
      });
    });
  });

});

});

;require.register("test/utils/configs/validators/service_configs_validator_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('utils/configs/validators/service_configs_validator');

describe('App.ServiceConfigsValidator', function() {

  describe('#validateConfig', function() {
    it('No config validator', function() {
      var v = App.ServiceConfigsValidator.create({});
      expect(v.validateConfig(Em.Object.create({name:'name'}))).to.equal(null);
    });
  });

  describe('#validatorLessThenDefaultValue', function() {
    var tests = Em.A([
      {
        recommendedDefaults: {
          'property1': 100500
        },
        config: Em.Object.create({
          value: 100000,
          name: 'property1'
        }),
        m: 'Numeric value',
        e: 'string'
      },
      {
        recommendedDefaults: {
          'property1': 'xx100500x'
        },
        config: Em.Object.create({
          value: 'xx100000x',
          name: 'property1'
        }),
        m: 'String value',
        e: 'string'
      },
      {
        recommendedDefaults: {
          'property1': null
        },
        config: Em.Object.create({
          value: 100000,
          name: 'property1'
        }),
        m: 'No default value for property',
        e: null
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        var v = App.ServiceConfigsValidator.create({});
        v.set('recommendedDefaults', test.recommendedDefaults);
        var r = v.validatorLessThenDefaultValue(test.config);
        if (test.e) {
          expect(r).to.be.a(test.e);
        }
        else {
          expect(r).to.equal(null)
        }
      });
    });
  });

  describe('#_checkXmxValueFormat', function() {
    var tests = Em.A([
      {value: '',e: false},
      {value: '-',e: false},
      {value: '100',e: false},
      {value: '-Xmx',e: false},
      {value: '-XMX1',e: false},
      {value: '-Xmxb',e: false},
      {value: '-Xmxk',e: false},
      {value: '-Xmxm',e: false},
      {value: '-Xmxg',e: false},
      {value: '-Xmxp',e: false},
      {value: '-Xmxt',e: false},
      {value: '-XmxB',e: false},
      {value: '-XmxK',e: false},
      {value: '-XmxM',e: false},
      {value: '-XmxG',e: false},
      {value: '-XmxP',e: false},
      {value: '-XmxT',e: false},
      {value: '-Xmx1',e: true},
      {value: '-Xmx1b',e: true},
      {value: '-Xmx1k',e: true},
      {value: '-Xmx1m',e: true},
      {value: '-Xmx1g',e: true},
      {value: '-Xmx1t',e: true},
      {value: '-Xmx1p',e: true},
      {value: '-Xmx1B',e: true},
      {value: '-Xmx1K',e: true},
      {value: '-Xmx1M',e: true},
      {value: '-Xmx1G',e: true},
      {value: '-Xmx1T',e: true},
      {value: '-Xmx1P',e: true},
      {value: '-Xmx100',e: true},
      {value: '-Xmx100b',e: true},
      {value: '-Xmx100k',e: true},
      {value: '-Xmx100m',e: true},
      {value: '-Xmx100g',e: true},
      {value: '-Xmx100t',e: true},
      {value: '-Xmx100p',e: true},
      {value: '-Xmx100B',e: true},
      {value: '-Xmx100K',e: true},
      {value: '-Xmx100M',e: true},
      {value: '-Xmx100G',e: true},
      {value: '-Xmx100T',e: true},
      {value: '-Xmx100P',e: true},
      {value: '-Xmx100Psome',e: false},
      {value: '-Xmx100P-Xmx',e: false},
      {value: '-Xmx100P -Xmx',e: false},
      {value: '-Xmx100P -XMX',e: false},
      {value: '-server -Xmx1024m -Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: true},
      {value: '-server -Xmx1024 -Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: true},
      {value: '-server -Xmx1024', e: true},
      {value: '-Xmx1024 -Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: true},
      {value: '-server -Xmx1024m-Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: false},
      {value: '-server -Xmx1024-Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: false},
      {value: '-server-Xmx1024m -Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: false},
      {value: '-server-Xmx1024 -Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: false},
      {value: '-server-Xmx1024m-Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: false},
      {value: '-server-Xmx1024-Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: false},
      {value: '-Xmx1024-Djava.net.preferIPv4Stack=true -XX:+UseNUMA -XX:+UseParallelGC', e: false},
      {value: '-server-Xmx1024', e: false},
      {value: '-server    -Xmx1024m   -Da=b',e: true},
      {value: '-server -Xmx1024m -Da=b',e: true},
      {value: '-server -XMx1024m -Da=b',e: false},
      {value: '-server -Xmx1024M -Da=b',e: true},
      {value: '-server -Xmx1 -Da=b',e: true},
      {value: '-server -Xmx1100MBPS -Da=b',e: false},
      {value: '-server -Xmx1100M -Xmx200 -Da=b',e: false},
      {value: '-server --Xmx1100M -Da=b',e: false},
      {value: '-Xmx1024m -server -Da=b',e: true},
      {value: ' -server -Da=b -Xmx1024m',e: true}
    ]);
    tests.forEach(function(test) {
      it(test.value, function() {
        var v = App.ServiceConfigsValidator.create({});
        expect(v._checkXmxValueFormat(test.value)).to.equal(test.e);
      });
    });
  });

  describe('#_getXmxSize', function() {
    var tests = Em.A([
      {value: '-Xmx1', e: '1'},
      {value: '-Xmx1b', e: '1b'},
      {value: '-Xmx1k', e: '1k'},
      {value: '-Xmx1m', e: '1m'},
      {value: '-Xmx1g', e: '1g'},
      {value: '-Xmx1t', e: '1t'},
      {value: '-Xmx1p', e: '1p'},
      {value: '-Xmx1B', e: '1b'},
      {value: '-Xmx1K', e: '1k'},
      {value: '-Xmx1M', e: '1m'},
      {value: '-Xmx1G', e: '1g'},
      {value: '-Xmx1T', e: '1t'},
      {value: '-Xmx1P', e: '1p'},
      {value: '-Xmx100b', e: '100b'},
      {value: '-Xmx100k', e: '100k'},
      {value: '-Xmx100m', e: '100m'},
      {value: '-Xmx100g', e: '100g'},
      {value: '-Xmx100t', e: '100t'},
      {value: '-Xmx100p', e: '100p'},
      {value: '-Xmx100B', e: '100b'},
      {value: '-Xmx100K', e: '100k'},
      {value: '-Xmx100M', e: '100m'},
      {value: '-Xmx100G', e: '100g'},
      {value: '-Xmx100T', e: '100t'},
      {value: '-Xmx100P', e: '100p'}
    ]);
    tests.forEach(function(test) {
      it(test.value, function() {
        var v = App.ServiceConfigsValidator.create({});
        expect(v._getXmxSize(test.value)).to.equal(test.e);
      });
    });
  });

  describe('#_formatXmxSizeToBytes', function() {
    var tests = Em.A([
      {value: '1', e: 1},
      {value: '1 ', e: 1},
      {value: '100', e: 100},
      {value: '100 ', e: 100},
      {value: '100b', e: 100},
      {value: '100B', e: 100},
      {value: '100k', e: 100 * 1024},
      {value: '100K', e: 100 * 1024},
      {value: '100m', e: 100 * 1024 * 1024},
      {value: '100M', e: 100 * 1024 * 1024},
      {value: '100g', e: 100 * 1024 * 1024 * 1024},
      {value: '100G', e: 100 * 1024 * 1024 * 1024},
      {value: '100t', e: 100 * 1024 * 1024 * 1024 * 1024},
      {value: '100T', e: 100 * 1024 * 1024 * 1024 * 1024},
      {value: '100p', e: 100 * 1024 * 1024 * 1024 * 1024 * 1024},
      {value: '100P', e: 100 * 1024 * 1024 * 1024 * 1024 * 1024}
    ]);
    tests.forEach(function(test) {
      it(test.value, function() {
        var v = App.ServiceConfigsValidator.create({});
        expect(v._formatXmxSizeToBytes(test.value)).to.equal(test.e);
      });
    });
  });

  describe('#validateXmxValue', function() {
    var tests = Em.A([
      {
        recommendedDefaults: {
          'property1': '-Xmx1024m'
        },
        config: Em.Object.create({
          value: '-Xmx2g',
          name: 'property1'
        }),
        e: null
      },
      {
        recommendedDefaults: {
          'property1': '-Xmx12'
        },
        config: Em.Object.create({
          value: '-Xmx24',
          name: 'property1'
        }),
        e: null
      },
      {
        recommendedDefaults: {
          'property1': '-Xmx333k'
        },
        config: Em.Object.create({
          value: '-Xmx134k',
          name: 'property1'
        }),
        e: 'string'
      },
      {
        recommendedDefaults: {
          'property1': '-Xmx333k'
        },
        config: Em.Object.create({
          value: '-Xmx534',
          name: 'property1'
        }),
        e: 'string'
      },
      {
        recommendedDefaults: {},
        config: Em.Object.create({
          defaultValue: '-Xmx123',
          value: '-Xmx123',
          name: 'name'
        }),
        e: null
      },
      {
        recommendedDefaults: {},
        config: Em.Object.create({
          defaultValue: '-Xmx124',
          value: '-Xmx123',
          name: 'name'
        }),
        e: 'string'
      }
    ]);
    tests.forEach(function(test) {
      it(test.config.get('value'), function() {
        var v = App.ServiceConfigsValidator.create({});
        v.set('recommendedDefaults', test.recommendedDefaults);
        var r = v.validateXmxValue(test.config);
        if (test.e) {
          expect(r).to.be.a(test.e);
        }
        else {
          expect(r).to.equal(null)
        }
      });
    });

    it('Error should be thrown', function() {
      var v = App.ServiceConfigsValidator.create({});
      v.set('recommendedDefaults', {});
      expect(function() {v.validateXmxValue(Em.Object.create({value:''}));}).to.throw(Error);
    });

  });

});

});

;require.register("test/utils/date_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

var validator = require('utils/validator');
var date = require('utils/date');

describe('date', function () {

  var correct_tests = Em.A([
    {t: 1349752195000, e: 'Tue, Oct 09, 2012 03:09', e2: 'Tue Oct 09 2012'},
    {t: 1367752195000, e: 'Sun, May 05, 2013 11:09', e2: 'Sun May 05 2013'},
    {t: 1369952195000, e: 'Thu, May 30, 2013 22:16', e2: 'Thu May 30 2013'},
    {t: 1369952195000, e: 'Thu, May 30, 2013 22:16:35', e2: 'Thu May 30 2013', showSeconds: true },
    {t: 1369952195000, e: 'Thu, May 30, 2013 22:16:35:000', e2: 'Thu May 30 2013', showSeconds: true, showMilliseconds: true }
  ]);

  var incorrect_tests = Em.A([
    {t: null},
    {t: ''},
    {t: false},
    {t: []},
    {t: {}},
    {t: undefined},
    {t: function(){}}
  ]);

  describe('#dateFormatZeroFirst()', function() {
    var tests = [
      {
        t: 2,
        e: '02',
        m: 'should convert to `02`'
      },
      {
        t: 10,
        e: '10',
        m: 'should convert to `10`'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        expect(date.dateFormatZeroFirst(test.t)).to.eql(test.e);
      });
    });
  });

  describe('#dateFormat', function() {
    describe('Correct timestamps', function(){
      correct_tests.forEach(function(test) {
        var testMessage = test.t + ' `showSeconds` ' + !!test.showSeconds + '`showMilliseconds` ' + !!test.showMilliseconds;
        it(testMessage, function() {
          expect(date.dateFormat(test.t, test.showSeconds, test.showMilliseconds)).to.equal(test.e);
        });
      });
    });
    describe('Incorrect timestamps', function() {
      incorrect_tests.forEach(function(test) {
        it(test.t, function() {
          expect(date.dateFormat(test.t)).to.equal(test.t);
        });
      });
    });
  });

  describe('#dateFormatShort', function() {
    describe('Correct timestamps', function() {
      correct_tests.forEach(function(test) {
        it(test.t, function() {
          expect(date.dateFormatShort(test.t)).to.equal(test.e2);
        });
      });
    });
    it('Today timestamp', function() {
      var now = new Date();
      var then = new Date(now.getFullYear(),now.getUTCMonth(),now.getUTCDate(),0,0,0);
      expect(date.dateFormatShort(then.getTime() + 10*3600*1000)).to.equal('Today 10:00:00');
    });
    describe('Incorrect timestamps', function() {
      incorrect_tests.forEach(function(test) {
        it(test.t, function() {
          expect(date.dateFormatShort(test.t)).to.equal(test.t);
        });
      });
    });
  });

  describe('#startTime()', function() {
    var today = new Date();
    var tests = [
      { t: 1349752195000, e: 'Tue Oct 09 2012 06:09' },
      { t: -10000000, e: 'Not started' },
      { t: today.getTime(), e: 'Today {0}:{1}'.format(date.dateFormatZeroFirst(today.getHours()), date.dateFormatZeroFirst(today.getMinutes())) },
      { t: today, e: ''}
    ];
    tests.forEach(function(test) {
      var testMessage = 'should conver {0} to {1}'.format(test.t, test.e);
      it(testMessage, function() {
        expect(date.startTime(test.t)).to.be.eql(test.e);
      });
    });
  });

  describe('#timingFormat', function() {
    var tests = Em.A([
      {i: '30', e:'30 ms'},
      {i: '300', e:'300 ms'},
      {i: '999', e:'999 ms'},
      {i: '1000', e:'1.00 secs'},
      {i: '3000', e:'3.00 secs'},
      {i: '35000', e:'35.00 secs'},
      {i: '350000', e:'350.00 secs'},
      {i: '999999', e:'1000.00 secs'},
      {i: '1000000', e:'16.67 mins'},
      {i: '3500000', e:'58.33 mins'},
      {i: '35000000', e:'9.72 hours'},
      {i: '350000000', e:'4.05 days'},
      {i: '3500000000', e:'40.51 days'},
      {i: '35000000000', e:'405.09 days'}
    ]);

    describe('Correct data', function(){
      tests.forEach(function(test) {
        it(test.t, function() {
          expect(date.timingFormat(test.i)).to.equal(test.e);
        });
      });
    });

    describe('Incorrect data', function(){
      incorrect_tests.forEach(function(test) {
        it(test.t, function() {
          expect(date.timingFormat(test.t)).to.equal(null);
        });
      });
    });

  });

  describe('#duration', function() {
    var tests = Em.A([
      {startTime: 1, endTime: 2, e: 1},
      {startTime: 0, endTime: 2000, e: 0},
      {startTime: 200, endTime: 0, e: 19800}
    ]);

    beforeEach(function() {
      sinon.stub(App, 'dateTime', function () { return 20000; });
    });

    tests.forEach(function(test) {
      it(test.startTime + ' ' + test.endTime, function() {
        expect(date.duration(test.startTime, test.endTime)).to.equal(test.e);
      });
    });

    afterEach(function() {
      App.dateTime.restore();
    });
  });

  describe('#durationSummary()', function() {
    var tests = [
      {
        startTimestamp: 1349752195000,
        endTimestamp: 1349752199000,
        e: '4.00 secs'
      },
      {
        startTimestamp: 1349752195000,
        endTimestamp: 1367752195000,
        e: '208.33 days'
      },
      {
        startTimestamp: -10000000,
        endTimestamp: 1367752195000,
        e: Em.I18n.t('common.na')
      },
      {
        startTimestamp: 1349752195000,
        endTimestamp: -1,
        stubbed: true,
        e: '0 secs'
      },
      {
        startTimestamp: 1000,
        endTimestamp: -1,
        stubbed: true,
        e: '19.00 secs'
      }
    ];

    beforeEach(function() {
      sinon.stub(App, 'dateTime', function () { return 20000; });
    });

    tests.forEach(function(test) {
      var testMessage = 'duration between {0} and {1} is {2}'.format(test.startTimestamp, test.endTimestamp, test.e) + (test.stubbed ? " App.dateTime() is stubbed" : "");
      it(testMessage, function() {
        expect(date.durationSummary(test.startTimestamp, test.endTimestamp)).to.be.eql(test.e);
      });
    });

    afterEach(function() {
      App.dateTime.restore();
    });
  });

});
});

;require.register("test/utils/form_field_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/form');


/*
 * formField.isValid property doesn't update correctly, so I have to work with errorMessage property
 */
describe('App.FormField', function () {

  describe('#validate()', function () {
    /*NUMBER TYPE END*/
    /*REQUIRE*/
    it('Required field shouldn\'t be empty', function () {
      var formField = App.FormField.create();
      formField.set('displayType', 'string');
      formField.set('value', '');
      formField.set('isRequired', true);
      formField.validate();
      expect(formField.get('errorMessage') === '').to.equal(false);
    });
    /*REQUIRE END*/

  });
});
});

;require.register("test/utils/helper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var App = require('app');
require('utils/helper');

describe('utils/helper', function() {
  describe('String helpers', function() {
    describe('#trim()', function(){
      it('should replace first space', function() {
        expect(' as d f'.trim()).to.eql('as d f');
      });
    });
    describe('#endsWith()', function() {
      it('`abcd` ends with `d`', function(){
        expect('abcd'.endsWith('d')).to.eql(true);
      });
      it('`abcd` doesn\'t end with `f`', function(){
        expect('abcd'.endsWith('f')).to.eql(false);
      });
    });
    describe('#contains()', function() {
      it('`abc` contains b', function(){
        expect('abc'.contains('b')).to.eql(true);
      });
      it('`abc` doesn\'t contain d', function() {
        expect('abc'.contains('d')).to.eql(false);
      });
    });
    describe('#capitalize()',function() {
      it('`abc d` should start with `A`', function() {
        expect('abc d'.capitalize()).to.eql('Abc d');
      });
    });
    describe('#findIn()', function(){
      var obj = {
        a: {
          a1: 'AVal1'
        },
        b: 'BVal',
        c: {
          c1: {
            c2: 'Cval2'
          },
          b: 'BVal'
        }
      };
      var testValue = function(key, value) {
        it('key `' + key + '` should have `' + JSON.stringify(value) + '` value', function() {
          expect(key.findIn(obj)).to.eql(value);
        });
      };
      it('expect return `null` on non-object input', function(){
        expect('a'.findIn('b')).to.null;
      });
      testValue('a', obj.a);
      testValue('c2', obj.c.c1.c2);
      testValue('b', obj.b);
      testValue('d', null);
    });
    describe('#format()', function(){
      it('should replace string correctly', function(){
        expect("{0} world{1}".format("Hello","!")).to.eql("Hello world!");
      });
    });
    describe('#highlight()', function() {
      var str = "Hello world! I want to highlight this word!";
      it('should highlight `word` with default template', function() {
        var result = str.highlight(['word']);
        expect(result).to.eql("Hello world! I want to highlight this <b>word</b>!");
      });
      it('should highlight `world` and `word` with template `<span class="yellow">{0}</span>`', function() {
        var result = str.highlight(["world", "word"], '<span class="yellow">{0}</span>');
        expect(result).to.eql('Hello <span class="yellow">world</span>! I want to highlight this <span class="yellow">word</span>!')
      });
      var str2 = "First word, second word";
      it('should highlight `word` multiply times with default template', function() {
        var result = str2.highlight(["word"]);
        expect(result).to.eql("First <b>word</b>, second <b>word</b>");
      });
    });
  });
  describe('Number helpers', function(){
    describe('#toDaysHoursMinutes()', function(){
      var time = 1000000000;
      var minute = 1000*60;
      var hour = 60*minute;
      var day = 24*hour;
      var result = time.toDaysHoursMinutes();
      var testDays = Math.floor(time/day);
      it('should correct convert days', function(){
        expect(testDays).to.eql(result.d);
      });
      it('should correct convert hours', function(){
        expect(Math.floor((time - testDays * day)/hour)).to.eql(result.h);
      });
      it('should correct convert minutes', function(){
        expect(((time - Math.floor((time - testDays*day)/hour)*hour - testDays*day)/minute).toFixed(2)).to.eql(result.m);
      });
    });
  });
  describe('Array helpers', function(){
    describe('#sortPropertyLight()', function(){
      var testable = [
        { a: 2 },
        { a: 1 },
        { a: 6},
        { a: 64},
        { a: 3},
        { a: 3}
      ];
      var result = testable.sortPropertyLight('a');
      it('should return array with same length', function(){
        expect(testable.length).to.eql(result.length);
      });
      it('should sort array', function() {
        result.forEach(function(resultObj, index, resultArr) {
          if (index > resultArr.length - 1)
            expect(resultObj.a < resultArr[index + 1].a).to.eql(false);
        });
      });
      it('should try to sort without throwing exception', function(){
        expect(testable.sortPropertyLight(['a'])).to.ok;
      });
    });
  });
  describe('App helpers', function(){
    var appendDiv = function() {
      $('body').append('<div id="tooltip-test"></div>');
    };
    var removeDiv = function() {
      $('body').remove('#tooltip-test');
    };
    describe('#isEmptyObject', function(){
      it('should return true on empty object', function() {
        expect(App.isEmptyObject({})).to.eql(true);
      });
      it('should return false on non-empty object', function() {
        expect(App.isEmptyObject({ a: 1 })).to.eql(false);
      });
    });
    describe('#parseJSON()', function(){
      var testable = '{"hello": "world"}';
      expect(App.parseJSON(testable).hello).to.eql('world');
    });
    describe('#tooltip()', function() {
      beforeEach(appendDiv);
      afterEach(removeDiv);
      it('should add tooltip', function() {
        var tooltip = App.tooltip($('#tooltip-test'));
        expect($('#tooltip-test').data('tooltip').enabled).to.eql(true);
      });
    });
    describe('#popover()', function() {
      beforeEach(appendDiv);
      afterEach(removeDiv);
      it('should add popover', function() {
        var tooltip = App.popover($('#tooltip-test'));
        expect($('#tooltip-test').data('popover').enabled).to.eql(true);
      });
    });
    describe('#App.format', function(){
      describe('#commandDetail()', function() {
        var command = "GANGLIA_MONITOR STOP";
        var ignored = "DECOMMISSION, NAMENODE";
        var removeString = "SERVICE/HDFS STOP";
        var nagiosState = "nagios_update_ignore ACTIONEXECUTE";
        it('should convert command to readable info', function() {
          expect(App.format.commandDetail(command)).to.eql(' Ganglia Monitor Stop');
        });
        it('should ignore decommission command', function(){
          expect(App.format.commandDetail(ignored)).to.eql('  NameNode');
        });
        it('should remove SERVICE string from command', function(){
          expect(App.format.commandDetail(removeString)).to.eql(' HDFS Stop');
        });
        it('should return maintenance message', function() {
          expect(App.format.commandDetail(nagiosState)).to.eql(' Toggle Maintenance Mode');
        });
      });
      describe('#taskStatus()', function(){
        var testable = [
          { status: 'PENDING', expectable: 'pending'},
          { status: 'QUEUED', expectable: 'queued'},
          { status: 'COMPLETED', expectable: 'completed'}
        ];
        testable.forEach(function(testObj){
          it('should convert `' + testObj.status + '` to `' + testObj.expectable + '`', function(){
            expect(App.format.taskStatus(testObj.status)).to.eql(testObj.expectable);
          });
        });
      });
    });
  });
  describe('#App.permit()', function() {
    var obj = {
      a1: 'v1',
      a2: 'v2',
      a3: 'v3'
    }

    var tests = [
      {
        keys: 'a1',
        e: {
          a1: 'v1'
        }
      },
      {
        keys: ['a2','a3','a4'],
        e: {
          a2: 'v2',
          a3: 'v3'
        }
      }
    ];

    tests.forEach(function(test) {
      it('should return object `{0}` permitted keys `{1}`'.format(JSON.stringify(test.e), JSON.stringify(test.keys)), function() {
        expect(App.permit(obj, test.keys)).to.deep.eql(test.e);
      });
    });


  });
});

});

;require.register("test/utils/host_progress_popup_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('controllers/global/background_operations_controller');
require('views/common/modal_popup');
require('utils/helper');
require('utils/host_progress_popup');

describe('App.HostPopup', function () {

  var services = [
    {
      displayName: "Start service WebHCat",
      hosts: [
        {
          logTasks: [
            {
              Tasks: {
                command: "START",
                host_name: "ip-10-12-123-90.ec2.internal",
                role: "WEBHCAT_SERVER",
                status: "QUEUED"
              },
              href: "http://ec2-54-224-233-43.compute-1.amazonaws.com:8080/api/v1/clusters/mycluster/requests/23/tasks/94"
            }
          ],
          name: "ip-10-12-123-90.ec2.internal",
          publicName: "ip-10-12-123-90.ec2.internal",
          serviceName: "Start service WebHCat"
        }
      ],
      isRunning: false
    },
    {
      displayName: "Start service Hive/HCat",
      hosts: [
        {
          logTasks: [
            {
              Tasks: {
                command: "INSTALL",
                host_name: "ip-10-12-123-90.ec2.internal",
                status: "COMPLETED"
              },
              href: "http://ec2-54-224-233-43.compute-1.amazonaws.com:8080/api/v1/clusters/mycluster/requests/15/tasks/76"
            }
          ],
          name: "ip-10-12-123-90.ec2.internal",
          publicName: "ip-10-12-123-90.ec2.internal",
          serviceName: "Start service Hive/HCat"
        },
        {
          logTasks: [
            {
              Tasks: {
                command: "START",
                host_name: "ip-10-33-7-23.ec2.internal",
                status: "COMPLETED"
              },
              href: "http://ec2-54-224-233-43.compute-1.amazonaws.com:8080/api/v1/clusters/mycluster/requests/15/tasks/78"
            },
            {
              Tasks: {
                command: "START",
                host_name: "ip-10-33-7-23.ec2.internal",
                status: "COMPLETED"
              },
              href: "http://ec2-54-224-233-43.compute-1.amazonaws.com:8080/api/v1/clusters/mycluster/requests/15/tasks/79"
            }
          ],
          name: "ip-10-33-7-23.ec2.internal",
          publicName: "ip-10-33-7-23.ec2.internal",
          serviceName: "Start service Hive/HCat"
        }
      ],
      isRunning: false
    }
  ];

  var bgController = App.BackgroundOperationsController.create();
  bgController.set('services', services);

  describe('#initPopup', function() {
    App.HostPopup.initPopup("", bgController, true);
    it('services loaded', function() {
      expect(App.HostPopup.get('inputData').length).to.equal(services.length);
    });
  });

  var test_tasks = [
    {
      t: [
        {
          Tasks: {
            status: 'COMPLETED',
            id: 2
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 3
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 1
          }
        }
      ],
      m: 'All COMPLETED',
      r: 'SUCCESS',
      p: 100,
      ids: [1,2,3]
    },
    {
      t: [
        {
          Tasks: {
            status: 'FAILED',
            id: 2
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 1
          }
        }
        ,
        {
          Tasks: {
            status: 'COMPLETED',
            id: 3
          }
        }
      ],
      m: 'One FAILED',
      r: 'FAILED',
      p: 100,
      ids: [1,2,3]
    },
    {
      t: [
        {
          Tasks: {
            status: 'ABORTED',
            id: 1
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 2
          }
        }
      ],
      m: 'One ABORTED',
      r: 'CANCELLED',
      p: 100,
      ids: [1,2]
    },
    {
      t: [
        {
          Tasks: {
            status: 'TIMEDOUT',
            id: 3
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 1
          }
        }
      ],
      m: 'One TIMEDOUT',
      r: 'TIMEDOUT',
      p: 100,
      ids: [1,3]
    },
    {
      t: [
        {
          Tasks: {
            status: 'IN_PROGRESS',
            id: 1
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 2
          }
        }
      ],
      m: 'One IN_PROGRESS',
      r: 'IN_PROGRESS',
      p: 68,
      ids: [1,2]
    },
    {
      t: [
        {
          Tasks: {
            status: 'QUEUED',
            id: 2
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 3
          }
        }
      ],
      m: 'Something else',
      r: 'PENDING',
      p: 55,
      ids: [2,3]
    }
  ];

  describe('#setSelectCount', function () {
    var itemsForStatusTest = [
      {
        title: 'Empty',
        data: [],
        result: [0, 0, 0, 0, 0, 0, 0]
      },
      {
        title: 'All Pending',
        data: [
          {status: 'pending'},
          {status: 'queued'}
        ],
        result: [2, 2, 0, 0, 0, 0, 0]
      },
      {
        title: 'All Completed',
        data: [
          {status: 'success'},
          {status: 'completed'}
        ],
        result: [2, 0, 0, 0, 2, 0, 0]
      },
      {
        title: 'All Failed',
        data: [
          {status: 'failed'},
          {status: 'failed'}
        ],
        result: [2, 0, 0, 2, 0, 0, 0]
      },
      {
        title: 'All InProgress',
        data: [
          {status: 'in_progress'},
          {status: 'in_progress'}
        ],
        result: [2, 0, 2, 0, 0, 0, 0]
      },
      {
        title: 'All Aborted',
        data: [
          {status: 'aborted'},
          {status: 'aborted'}
        ],
        result: [2, 0, 0, 0, 0, 2, 0]
      },
      {
        title: 'All Timedout',
        data: [
          {status: 'timedout'},
          {status: 'timedout'}
        ],
        result: [2, 0, 0, 0, 0, 0, 2]
      },
      {
        title: 'Every Category',
        data: [
          {status: 'pending'},
          {status: 'queued'},
          {status: 'success'},
          {status: 'completed'},
          {status: 'failed'},
          {status: 'in_progress'},
          {status: 'aborted'},
          {status: 'timedout'}
        ],
        result: [8, 2, 1, 1, 2, 1, 1]
      }
    ];
    var categories = [
      Ember.Object.create({value: 'all'}),
      Ember.Object.create({value: 'pending'}),
      Ember.Object.create({value: 'in_progress'}),
      Ember.Object.create({value: 'failed'}),
      Ember.Object.create({value: 'completed'}),
      Ember.Object.create({value: 'aborted'}),
      Ember.Object.create({value: 'timedout'})
    ];
    itemsForStatusTest.forEach(function(statusTest) {
      it(statusTest.title, function() {
        App.HostPopup.setSelectCount(statusTest.data, categories);
        expect(categories.mapProperty('count')).to.deep.equal(statusTest.result);
      });
    });
  });

  describe('#getStatus', function() {
    test_tasks.forEach(function(test_task) {
      it(test_task.m, function() {
        expect(App.HostPopup.getStatus(test_task.t)[0]).to.equal(test_task.r);
      });
    });
  });

  describe('#getProgress', function() {
    test_tasks.forEach(function(test_task) {
      it(test_task.m, function() {
        expect(App.HostPopup.getProgress(test_task.t)).to.equal(test_task.p);
      });
    });
  });

});

});

;require.register("test/utils/lazy_loading_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var lazyLoading = require('utils/lazy_loading');

describe('lazy_loading', function () {

  describe('#run', function () {
    var context = Em.Object.create({isLoaded: false});
    var options = {
      destination: [],
      source: [{'test':'test'}],
      context: context
    };
    it('load one item', function () {
      lazyLoading.run(options);
      expect(options.destination[0]).to.eql(options.source[0]);
      expect(context.get('isLoaded')).to.equal(true);
    });

    var testsInfo = [
      {
        title: 'load 11 item with initSize - 11',
        result: true,
        initSize: 11,
        destinationLength: 11,
        destination: [],
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        context: Em.Object.create()
      },
      {
        title: 'load 11 item with initSize - 12',
        result: true,
        initSize: 12,
        destinationLength: 11,
        destination: [],
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        context: Em.Object.create()
      },
      {//items will be completely loaded on next iteration of pushing chunk
        title: 'load 11 item with initSize - 10',
        result: false,
        initSize: 10,
        destinationLength: 10,
        destination: [],
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        context: Em.Object.create({isLoaded: false})
      }
    ];
    testsInfo.forEach(function(test){
      it(test.title, function () {
        lazyLoading.run(test);
        expect(test.destinationLength).to.equal(test.destination.length);
        expect(test.context.get('isLoaded')).to.equal(test.result);
      });
    });
  });

  describe('#divideIntoChunks', function () {
    var testsInfo = [
      {
        title: 'load 11 item with chunkSize - 3',
        chunkSize: 3,
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        chunks: [[{i:1}, {i:2}, {i:3}], [{i:4}, {i:5}, {i:6}], [{i:7}, {i:8}, {i:9}], [{i:10},{i:11}]]
      },
      {
        title: 'load 11 item with chunkSize - 0',
        chunkSize: 0,
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        chunks: [[{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}]]
      },
      {
        title: 'load 11 item with chunkSize - 1',
        chunkSize: 1,
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        chunks: [[{i:1}], [{i:2}], [{i:3}], [{i:4}], [{i:5}], [{i:6}], [{i:7}], [{i:8}], [{i:9}], [{i:10}], [{i:11}]]
      },
      {
        title: 'load 11 item with chunkSize - 11',
        chunkSize: 0,
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        chunks: [[{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}]]
      }
    ];
    testsInfo.forEach(function(test){
      it(test.title, function () {
        var chunks = lazyLoading.divideIntoChunks(test.source, test.chunkSize);
        expect(chunks).to.eql(test.chunks);
      });
    });
  });


});

});

;require.register("test/utils/misc_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var misc = require('utils/misc');

describe('misc', function () {

  describe('#formatBandwidth', function () {
    var tests = Em.A([
      {m:'undefined to undefined',i:undefined,e:undefined},
      {m:'0 to <1KB',i:'0',e:'<1KB'},
      {m:'1000 to <1KB',i:'1000',e:'<1KB'},
      {m:'1024 to 1.0KB',i:'1024',e:'1.0KB'},
      {m:'2048 to 2.0KB',i:'2048',e:'2.0KB'},
      {m:'1048576 to 1.0MB',i:'1048576',e:'1.0MB'},
      {m:'1782579 to 1.7MB',i:'1782579',e:'1.7MB'},
      {m:'1546188226 to 1.44GB',i:'1546188226',e:'1.44GB'}
    ]);
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(misc.formatBandwidth(test.i)).to.equal(test.e);
      });
    });
    it('NaN to NaN' + ' ', function () {
      expect(isNaN(misc.formatBandwidth(NaN))).to.equal(true);
    });
  });

  describe('#ipToInt', function () {
    var tests = Em.A([
      {m:'0.0.0.0 to 0',i:'0.0.0.0',e:0},
      {m:'255.255.255.255 to 4294967295',i:'255.255.255.255',e:4294967295},
      {m:'"" to false',i:'',e:false},
      {m:'255.255.255.256 to false',i:'255.255.255.256',e:false},
      {m:'255.255.255 to false',i:'255.255.255',e:false}
    ]);
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(misc.ipToInt(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#sortByOrder', function() {
    var tests = Em.A([
      {
        sortOrder: ['b', 'c', 'a'],
        array: [{id:'a'}, {id:'b'}, Em.Object.create({id:'c'})],
        e: [{id:'b'}, Em.Object.create({id:'c'}), {id:'a'}],
        m: 'Array with Ember and native objects'
      },
      {
        sortOrder: ['b', 'c', 'a'],
        array: [{id:'a'}, {id:'b'}, {id:'c'}],
        e: [{id:'b'}, {id:'c'}, {id:'a'}],
        m: 'Array with native objects'
      },
      {
        sortOrder: ['b', 'c', 'a'],
        array: [Em.Object.create({id:'a'}), Em.Object.create({id:'b'}), Em.Object.create({id:'c'})],
        e: [Em.Object.create({id:'b'}), Em.Object.create({id:'c'}), Em.Object.create({id:'a'})],
        m: 'Array with Ember objects'
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        expect(misc.sortByOrder(test.sortOrder, test.array)).to.eql(test.e);
      });
    });
  });

  describe('#xmlToObject()', function(){
    var xml = '<!-- Edited by XMLSpy -->'+
      '<stacks name="HDP-2.1">'+
      '<service>'+
      '<name>NAGIOS</name>'+
      '<name>OOZIE</name>'+
      '<name>HDFS</name>'+
      '<component>NAGIOS_SERVER</component>'+
      '</service>'+
      '</stacks>';
    xml = new DOMParser().parseFromString(xml,"text/xml");
    var converted = misc.xmlToObject(xml);
    it('should be an object', function(){
      expect(converted).to.a('object');
    });
    it('`attribute` name should be present', function(){
      expect(converted.stacks).to.ok;
    });
    it('`stacks.service.name` should be an array', function() {
      expect(converted.stacks.service.name).to.a('array');
    });
  });

});

});

;require.register("test/utils/number_utils_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var numberUtils = require('utils/number_utils');

describe('', function() {

  describe('#bytesToSize', function() {

    describe('check bytes', function() {
      var tests = Em.A([
        {
          bytes: null,
          precision: null,
          parseType: null,
          multiplyBy: null,
          e: 'n/a',
          m: '"n/a" if bytes is null'
        },
        {
          bytes: undefined,
          precision: null,
          parseType: null,
          multiplyBy: null,
          e: 'n/a',
          m: '"n/a" if bytes is undefined'
        },
        {
          bytes: 200,
          precision: null,
          parseType: undefined,
          multiplyBy: null,
          e: '0 Bytes',
          m: '0 if multiply is `null`'
        },
        {
          bytes: 200,
          precision: null,
          parseType: undefined,
          multiplyBy: undefined,
          e: '200 Bytes',
          m: '"200 Bytes" if `multiplyBy` and `parseType` are `undefined`'
        },
        {
          bytes: 200,
          precision: null,
          parseType: undefined,
          multiplyBy: 1,
          e: '200 Bytes',
          m: '`200 Bytes` if `parsetype` is `undefined`'
        }
      ]);

      tests.forEach(function(test) {
        it(test.m, function() {
          expect(numberUtils.bytesToSize(test.bytes, test.precision, test.parseType, test.multiplyBy)).to.equal(test.e);
        });
      });
    });

    describe('check sizes', function() {
      var tests = Em.A([
        {
          bytes: 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'Bytes',
          m: 'Bytes'
        },
        {
          bytes: 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'KB',
          m: 'KB'
        },
        {
          bytes: 1024 * 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'MB',
          m: 'MB'
        },
        {
          bytes: 1024 * 1024 * 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'GB',
          m: 'GB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'TB',
          m: 'TB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 1024 * 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'PB',
          m: 'PB'
        }
      ]);

      tests.forEach(function(test) {
        it(test.m, function() {
          expect(numberUtils.bytesToSize(test.bytes, test.precision, test.parseType, test.multiplyBy).endsWith(test.e)).to.equal(true);
        });
      });
    });

    describe('check calculated result', function() {
      var tests = Em.A([
        {
          bytes: 42,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '42',
          m: 'Bytes'
        },
        {
          bytes: 1024 * 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '12',
          m: 'KB'
        },
        {
          bytes: 1024 * 1024 * 23,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '23',
          m: 'MB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 34,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '34',
          m: 'GB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 1024 * 45,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '45',
          m: 'TB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 1024 * 1024 * 56,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '56',
          m: 'PB'
        }
      ]);

      tests.forEach(function(test) {
        it(test.m, function() {
          expect(numberUtils.bytesToSize(test.bytes, test.precision, test.parseType, test.multiplyBy).startsWith(test.e)).to.equal(true);
        });
      });
    });

  });
  describe('#validateInteger()', function() {
    var tests = [
      {
        str: null,
        min: null,
        max: null,
        m: 'all params null to' + Em.I18n.t('number.validate.empty'),
        e: Em.I18n.t('number.validate.empty')
      },
      {
        str: "string",
        min: null,
        max: null,
        m: 'try to validate `string` should return ' + Em.I18n.t('number.validate.empty'),
        e: Em.I18n.t('number.validate.notValidNumber')
      },
      {
        str: "string",
        min: null,
        max: null,
        m: 'try to validate `string` should return ' + Em.I18n.t('number.validate.notValidNumber'),
        e: Em.I18n.t('number.validate.notValidNumber')
      },
      {
        str: "1abc",
        min: null,
        max: null,
        m: 'try to validate `1abc` should return ' + Em.I18n.t('number.validate.notValidNumber'),
        e: Em.I18n.t('number.validate.notValidNumber')
      },
      {
        str: "1",
        min: null,
        max: null,
        m: 'try to validate `1` should return ' + Em.I18n.t('number.validate.moreThanMaximum').format(null),
        e: Em.I18n.t('number.validate.moreThanMaximum').format(null)
      },
      {
        str: "1",
        min: 2,
        max: 0,
        m: 'try to validate `1` with max = 0 and min = 2 should return ' + Em.I18n.t('number.validate.lessThanMinumum').format(2),
        e: Em.I18n.t('number.validate.lessThanMinumum').format(2)
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function(){
        expect(numberUtils.validateInteger(test.str, test.min, test.max)).to.eql(test.e);
      });
    });
  });

});
});

;require.register("test/utils/object_utils_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var objectUtils = require('utils/object_utils');

describe('utils/object_utils', function() {
  describe('#recursiveTree()', function() {
    var testObj = {
      a1: {
        a2: 'v1',
        a3: {
          a4: {
            a5: {
              a6: 'v2',
              a7: 'v3'
            }
          }
        }
      }
    };
    it('should return correct tree of childs', function(){
      var result = objectUtils.recursiveTree(testObj);
      expect(result).to.eql('a2 (/a1)<br/>a5 (/a1/a3/a4)<br/>');
    });

    it('should return `null` if type missed', function() {
      var result = objectUtils.recursiveTree('{ a1: "v1"}');
      expect(result).to.be.null;
    });
  });
  describe('#recursiveKeysCount()', function() {
    var tests = [
      {
        m: 'should return 1 child',
        e: 3,
        obj: {
          a1: {
            a2: 'v1',
            a3: 'v2',
            a4: {
              a5: 'v3'
            }
          }
        }
      },
      {
        m: 'should return 1 childs',
        e: 1,
        obj: {
          a1: 'c1'
        }
      },
      {
        m: 'should return `null`',
        e: null,
        obj: 'a1'
      }
    ];
    tests.forEach(function(test){
      it(test.m, function() {
        expect(objectUtils.recursiveKeysCount(test.obj)).to.be.eql(test.e);
      });
    });
  });
});

});

;require.register("test/utils/string_utils_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var string_utils = require('utils/string_utils');
require('utils/helper');

describe('string_utils', function () {

  describe('#underScoreToCamelCase', function () {
    var tests = [
      {m:'a_b_c to aBC',i:'a_b_c',e:'aBC'},
      {m:'a_bc to aBc',i:'a_bc',e:'aBc'},
      {m:'ab_c to abC',i:'ab_c',e:'abC'},
      {m:'_b_c to BC',i:'_b_c',e:'BC'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(string_utils.underScoreToCamelCase(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#pad', function () {
    var tests = [
      {m: '"name" to "    name"', i: 'name', l: 8, a: 1, f: ' ', e: '    name'},
      {m: '"name" to "name    "', i: 'name', l: 8, a: 2, f: ' ', e: 'name    '},
      {m: '"name" to "  name  "', i: 'name', l: 8, a: 3, f: ' ', e: '  name  '},
      {m: '"name" to "name    "', i: 'name', l: 8, a: 0, f: ' ', e: 'name    '},
      {m: '"name" to "name    "', i: 'name', l: 8, a:-1, f: ' ', e: 'name    '},
      {m: '"name" to "name"', i: 'name', l: 4, a: 1, f: ' ', e: 'name'},
      {m: '"name" to "||||||||name"', i: 'name', l: 8, a:1, f: '||', e: '||||||||name'},
      {m: '"name" to "||||name||||"', i: 'name', l: 8, a:3, f: '||', e: '||||name||||'},
      {m: '"name" to "name||||||||"', i: 'name', l: 8, a:2, f: '||', e: 'name||||||||'},
      {m: '"name" to "name" `str` param passed only', i: 'name', e: 'name'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(string_utils.pad(test.i, test.l, test.f, test.a)).to.equal(test.e);
      });
    });
  });

  describe('#compareVersions', function () {
    var tests = [
      {m: '1.2 equal to 1.2', v1:'1.2', v2:'1.2', e: 0},
      {m: '1.2 lower than 1.3', v1:'1.2', v2:'1.3', e: -1},
      {m: '1.3 higher than 1.2', v1:'1.3', v2:'1.2', e: 1},
      {m: '1.2.1 higher than 1.2', v1:'1.2.1', v2:'1.2', e: 1},
      {m: '11.2 higher than 2.2', v1:'11.2', v2:'2.2', e: 1},
      {m: '0.9 higher than 0.8', v1:'0.9', v2:'0.8', e: 1},
      {m: 'return false if no string passed', v1: '0.9', e: false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(string_utils.compareVersions(test.v1, test.v2)).to.equal(test.e);
      });
    });
  });

  describe('#isSingleLine', function () {
    var tests = [
      {m: 'is single line text', t: 'a b', e: true},
      {m: 'is single line text', t: 'a b\n', e: true},
      {m: 'is single line text', t: '\na b', e: true},
      {m: 'is not single line text', t: 'a\nb', e: false}
    ];
    tests.forEach(function(test) {
      it(test.t + ' ' + test.m + ' ', function () {
        expect(string_utils.isSingleLine(test.t)).to.equal(test.e);
      });
    });
  });

  describe('#arrayToCSV', function() {
    var test = [{a: 1, b:2, c:3}, {a: 1, b:2, c:3}, {a: 1, b:2, c:3}];
    it('array of object to csv-string', function () {
      expect(string_utils.arrayToCSV(test)).to.equal("1,2,3\n1,2,3\n1,2,3\n");
    });
  });

  describe('#getFileFromPath', function() {
    var tests = [
      {t: undefined, e: ''},
      {t: {}, e: ''},
      {t: [], e: ''},
      {t: '', e: ''},
      {t: function(){}, e: ''},
      {t: '/path/to/file.ext', e: 'file.ext'},
      {t: 'file.ext', e: 'file.ext'},
      {t: 'file', e: 'file'},
      {t: '/path/to/file', e: 'file'}
    ];
    tests.forEach(function(test) {
      it('Check ' + typeof test.t, function () {
        expect(string_utils.getFileFromPath(test.t)).to.equal(test.e);
      });
    });
  });

  describe('#getPath', function() {
      var tests = [
        {t: undefined, e: ''},
        {t: {}, e: ''},
        {t: [], e: ''},
        {t: '', e: ''},
        {t: function(){}, e: ''},
        {t: '/path/to/filename', e: '/path/to'},
        {t: '/path/to/', e: '/path/to'},
        {t: '/filename', e: '/'},
        {t: 'filename', e: ''},
        {t: '/path/', e: '/path'},
        {t: 'filename/', e: ''}
      ];
      tests.forEach(function(test) {
          it('Check ' + typeof test.t, function () {
            expect(string_utils.getPath(test.t)).to.equal(test.e);
          });
      });
  });

  describe('#getCamelCase', function () {
    var tests = [
      {i:'a',e:'A'},
      {i:'aB',e:'Ab'},
      {i:'a b',e:'A B'},
      {i:'a.b',e:'A.B'},
      {i:'a,b',e:'A,B'},
      {i:'a;b',e:'A;B'},
      {i:'a. b',e:'A. B'},
      {i:'a   b',e:'A   B'},
      {i:'aaa. bbb',e:'Aaa. Bbb'},
      {i:'aAA. bBB',e:'Aaa. Bbb'},
      {i:'STARTING',e:'Starting'},
      {i:'starting',e:'Starting'},
      {i:'starting,ending',e:'Starting,Ending'},
      {i: null, e: null},
      {i: undefined, e: undefined}
    ];
    tests.forEach(function(test) {
      it(test.i + ' to ' + test.e + ' ', function () {
        expect(string_utils.getCamelCase(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#findIn', function () {
    var tests = [
      {
        obj: {
          a: '1',
          b: '2'
        },
        key: 'a',
        index: 0,
        e: '1'
      }, {
        obj: {
          a: '1',
          b: '2'
        },
        key: 'a',
        index: 1,
        e: null
      }, {
        obj: {
          a: '1',
          b: '2',
          c: {
            a: '11',
            aa: '12'
          }
        },
        key: 'a',
        index: 1,
        e: '11'
      }, {
        obj: {
          a: '1',
          b: '2',
          c: {
            a: '11',
            aa: {
              a: '22'
            }
          }
        },
        key: 'a',
        index: 2,
        e: '22'
      }, {
        obj: {
          a: '1',
          b: '2',
          c: {
            a: '11',
            aa: {
              a: '22'
            }
          }
        },
        key: 'a',
        index: 0,
        e: '1'
      }, {
        obj: {
          a: '1',
          b: '2',
          c: {
            a: '11',
            aa: {
              a: '22'
            }
          }
        },
        key: 'g',
        index: 0,
        e: null
      }
    ];
    tests.forEach(function(test) {
      it(test.key + ' @ ' + test.index + ' = ' + test.e, function () {
        expect(test.key.findIn(test.obj, test.index)).to.equal(test.e);
      });
    });
  });
});

});

;require.register("test/utils/ui_effects_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var ui_utils = require('utils/ui_effects');
var App = require('app');

describe('utils/ui_effects', function(){
  describe('#pulsate()', function(){
    beforeEach(function(){
      $('body').append('<div id="pulsate-test-dom"></div>');
      this.clock = sinon.useFakeTimers();
    });

    it('opacity should be 0.2 on 5-th iteration', function() {
      var domEl = $('#pulsate-test-dom');
      ui_utils.pulsate(domEl, 1000);
      this.clock.tick(300);
      expect(parseFloat(domEl.css('opacity')).toFixed(1)).to.eql('0.2');
    });
    it('should call callback at the end', function() {
      var domEl = $('#pulsate-test-dom');
      var stub = sinon.stub();
      ui_utils.pulsate(domEl, 1000, stub);
      this.clock.tick(2000);
      expect(stub.calledOnce).to.be.ok;
    });

    afterEach(function(){
      $('#pulsate-test-dom').remove();
      this.clock.restore();
    });
  });
});

});

;require.register("test/utils/updater_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('utils/updater', function() {
  describe('#App.updater', function() {
    beforeEach(function() {
      this.clock = sinon.useFakeTimers();
    });

    var tests = {
      t1: {
        obj: Em.Object.create({
          method: sinon.spy(),
          isWorking: true
        }),
        m: 'method called once with default interval in 15 000 ms'
      },
      t2: {
        obj: Em.Object.create({
          method: function() {}
        }),
        m: 'should return false if key name is invalid or absent'
      },
      t3: {
        obj: Em.Object.create({
          method2: sinon.spy(),
          isWorking: true
        }),
        m: 'method should be called immediately'
      },
      t4: {
        obj: Em.Object.create({
          method3: sinon.spy(),
          isWorking: true
        }),
        m: 'method call should be ignored if `isWorking` set to false'
      }
    };

    it(tests.t1.m, function() {
      App.updater.run(tests.t1.obj, 'method', 'isWorking');
      this.clock.tick(15000);
      expect(tests.t1.obj.method.called).to.be.ok;
    });

    it(tests.t2.m, function() {
      var methodCall = App.updater.run(tests.t2.obj, 'method', 'isWorking');
      expect(methodCall).to.be.false;
    });

    it(tests.t3.m, function() {
      App.updater.run(tests.t3.obj, 'method2', 'isWorking');
      App.updater.immediateRun('method2');
      expect(tests.t3.obj.method2.called).to.be.ok;
    });

    it(tests.t4.m, function() {
      App.updater.run(tests.t4.obj, 'method3', 'isWorking');
      this.clock.tick(10000);
      tests.t4.obj.set('isWorking', false);
      this.clock.tick(5000);
      expect(tests.t4.obj.method3.called).to.be.false;
    });


    afterEach(function() {
      this.clock.restore();
    });
  });
});

});

;require.register("test/utils/validator_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var validator = require('utils/validator');

describe('validator', function () {

  describe('#isValidEmail(value)', function () {
    it('should return false if value is null', function () {
      expect(validator.isValidEmail(null)).to.equal(false);
    });
    it('should return false if value is ""', function () {
      expect(validator.isValidEmail('')).to.equal(false);
    });
    it('should return false if value is "a.com"', function () {
      expect(validator.isValidEmail('a.com')).to.equal(false);
    });
    it('should return false if value is "@a.com"', function () {
      expect(validator.isValidEmail('@a.com')).to.equal(false);
    });
    it('should return false if value is "a@.com"', function () {
      expect(validator.isValidEmail('a@.com')).to.equal(false);
    });
    it('should return true if value is "a@a.com"', function () {
      expect(validator.isValidEmail('a@a.com')).to.equal(true);
    });
    it('should return true if value is "user@a.b.com"', function () {
      expect(validator.isValidEmail('user@a.b.com')).to.equal(true);
    })
  });

  describe('#isValidInt(value)', function () {
    it('should return false if value is null', function () {
      expect(validator.isValidInt(null)).to.equal(false);
    });
    it('should return false if value is ""', function () {
      expect(validator.isValidInt('')).to.equal(false);
    });
    it('should return false if value is "abc"', function () {
      expect(validator.isValidInt('abc')).to.equal(false);
    });
    it('should return false if value is "0xff"', function () {
      expect(validator.isValidInt('0xff')).to.equal(false);
    });
    it('should return false if value is " 1""', function () {
      expect(validator.isValidInt(' 1')).to.equal(false);
    });
    it('should return false if value is "1 "', function () {
      expect(validator.isValidInt('1 ')).to.equal(false);
    });
    it('should return true if value is "10"', function () {
      expect(validator.isValidInt('10')).to.equal(true);
    });
    it('should return true if value is "-123"', function () {
      expect(validator.isValidInt('-123')).to.equal(true);
    });
    it('should return true if value is "0"', function () {
      expect(validator.isValidInt('0')).to.equal(true);
    });
    it('should return true if value is 10', function () {
      expect(validator.isValidInt(10)).to.equal(true);
    });
    it('should return true if value is -123', function () {
      expect(validator.isValidInt(10)).to.equal(true);
    });
    it('should return true if value is 0', function () {
      expect(validator.isValidInt(10)).to.equal(true);
    })
  });

  describe('#isValidFloat(value)', function () {
    it('should return false if value is null', function () {
      expect(validator.isValidFloat(null)).to.equal(false);
    });
    it('should return false if value is ""', function () {
      expect(validator.isValidFloat('')).to.equal(false);
    });
    it('should return false if value is "abc"', function () {
      expect(validator.isValidFloat('abc')).to.equal(false);
    });
    it('should return false if value is "0xff"', function () {
      expect(validator.isValidFloat('0xff')).to.equal(false);
    });
    it('should return false if value is " 1""', function () {
      expect(validator.isValidFloat(' 1')).to.equal(false);
    });
    it('should return false if value is "1 "', function () {
      expect(validator.isValidFloat('1 ')).to.equal(false);
    });
    it('should return true if value is "10"', function () {
      expect(validator.isValidFloat('10')).to.equal(true);
    });
    it('should return true if value is "-123"', function () {
      expect(validator.isValidFloat('-123')).to.equal(true);
    });
    it('should return true if value is "0"', function () {
      expect(validator.isValidFloat('0')).to.equal(true);
    });
    it('should return true if value is 10', function () {
      expect(validator.isValidFloat(10)).to.equal(true);
    });
    it('should return true if value is -123', function () {
      expect(validator.isValidFloat(10)).to.equal(true);
    });
    it('should return true if value is 0', function () {
      expect(validator.isValidFloat(10)).to.equal(true);
    });
    it('should return true if value is "0.0"', function () {
      expect(validator.isValidFloat("0.0")).to.equal(true);
    });
    it('should return true if value is "10.123"', function () {
      expect(validator.isValidFloat("10.123")).to.equal(true);
    });
    it('should return true if value is "-10.123"', function () {
      expect(validator.isValidFloat("-10.123")).to.equal(true);
    });
    it('should return true if value is 10.123', function () {
      expect(validator.isValidFloat(10.123)).to.equal(true);
    });
    it('should return true if value is -10.123', function () {
      expect(validator.isValidFloat(-10.123)).to.equal(true);
    })

  });
  describe('#isIpAddress(value)', function () {
    it('"127.0.0.1" - valid IP', function () {
      expect(validator.isIpAddress('127.0.0.1')).to.equal(true);
    })
    it('"227.3.67.196" - valid IP', function () {
      expect(validator.isIpAddress('227.3.67.196')).to.equal(true);
    })
    it('"327.0.0.0" - invalid IP', function () {
      expect(validator.isIpAddress('327.0.0.0')).to.equal(false);
    })
    it('"127.0.0." - invalid IP', function () {
      expect(validator.isIpAddress('127.0.0.')).to.equal(false);
    })
    it('"127.0." - invalid IP', function () {
      expect(validator.isIpAddress('127.0.')).to.equal(false);
    })
    it('"127" - invalid IP', function () {
      expect(validator.isIpAddress('127')).to.equal(false);
    })
    it('"127.333.0.1" - invalid IP', function () {
      expect(validator.isIpAddress('127.333.0.1')).to.equal(false);
    })
    it('"127.0.333.1" - invalid IP', function () {
      expect(validator.isIpAddress('127.0.333.1')).to.equal(false);
    })
    it('"127.0.1.333" - invalid IP', function () {
      expect(validator.isIpAddress('127.0.1.333')).to.equal(false);
    })
    it('"127.0.0.0:45555" - valid IP', function () {
      expect(validator.isIpAddress('127.0.0.0:45555')).to.equal(true);
    })
    it('"327.0.0.0:45555" - invalid IP', function () {
      expect(validator.isIpAddress('327.0.0.0:45555')).to.equal(false);
    })
  });

  describe('#isDomainName(value)', function () {
    it('"google.com" - valid Domain Name', function () {
      expect(validator.isDomainName('google.com')).to.equal(true);
    });
    it('"google" - invalid Domain Name', function () {
      expect(validator.isDomainName('google')).to.equal(false);
    });
    it('"123.123" - invalid Domain Name', function () {
      expect(validator.isDomainName('123.123')).to.equal(false);
    });
    it('"4goog.le" - valid Domain Name', function () {
      expect(validator.isDomainName('4goog.le')).to.equal(true);
    });
    it('"55454" - invalid Domain Name', function () {
      expect(validator.isDomainName('55454')).to.equal(false);
    })
  });

  describe('#hasSpaces()', function(){
    var testable = [
      { str: ' hello', detect: true },
      { str: 'hello world', detect: true },
      { str: 'hello ', detect: true },
      { str: 'hello', detect: false }
    ];
    testable.forEach(function(value){
      it('should ' + (value.detect ? '' : 'not') + ' detects spaces in `' + value.str + '`', function(){
        expect(validator.hasSpaces(value.str)).to.eql(value.detect);
      });
    });
  });
  describe('#isNotTrimmed', function(){
    var testable = [
      { str: ' hello world', detect: true },
      { str: ' hello world ', detect: true },
      { str: 'hello world ', detect: true },
      { str: 'hello world', detect: false },
      { str: 'hello world !', detect: false }
    ];
    testable.forEach(function(value){
      it('should ' + (value.detect ? '' : 'not') + 'trimmed string', function() {
        expect(validator.isNotTrimmed(value.str)).to.eql(value.detect);
      });
    });
  });
  describe('#empty()', function(){
    var testable = [
      { obj: "", detect: true },
      { obj: 0, detect: true },
      { obj: "0", detect: true },
      { obj: null, detect: true },
      { obj: undefined, detect: true },
      { obj: 'hello', detect: false },
      { obj: {}, detect: false },
      { obj: [], detect: false },
      { obj: ['a'], detect: false },
      { obj: 1, detect: false },
      { obj: true, detect: false }
    ];
    testable.forEach(function(value){
      it('should ' + (value.detect ? '' : 'not') + ' detect empty value in `' + new String(value.obj) + '`', function(){
        expect(validator.empty(value.obj)).to.eql(value.detect);
      });
    });
  });
  describe('#isValidUserName(value)', function() {
    var tests = [
      {m:'"" - invalid',i:'',e:false},
      {m:'"abc123" - valid',i:'abc123',e:true},
      {m:'"1abc123" - invalid',i:'1abc123',e:false},
      {m:'"abc123$" - invalid',i:'abc123$',e:false},
      {m:'"~1abc123" - invalid',i: '~1abc123',e:false},
      {m:'"abc12345679abc1234567890abc1234567890$" - invalid',i:'abc12345679abc1234567890abc1234567890$',e:false},
      {m:'"1abc123$$" - invalid',i:'1abc123$$',e:false},
      {m:'"a" - valid',i:'a',e:true},
      {m:'"!" - invalid',i:'!',e:false},
      {m:'"root$" - invalid',i:'root$',e:false},
      {m:'"rootU" - invalid',i:'rootU',e:false},
      {m:'"rUoot" - invalid',i:'rUoot',e:false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidUserName(test.i)).to.equal(test.e);
      })
    });
  });
  describe('#isValidUNIXUser(value)', function() {
    var tests = [
      {m:'"" - invalid',i:'',e:false},
      {m:'"abc123" - valid',i:'abc123',e:true},
      {m:'"1abc123" - invalid',i:'1abc123',e:false},
      {m:'"abc123$" - invalid',i:'abc123$',e:false},
      {m:'"~1abc123" - invalid',i: '~1abc123',e:false},
      {m:'"abc12345679abc1234567890abc1234567890$" - invalid',i:'abc12345679abc1234567890abc1234567890$',e:false},
      {m:'"1abc123$$" - invalid',i:'1abc123$$',e:false},
      {m:'"a" - valid',i:'a',e:true},
      {m:'"!" - invalid',i:'!',e:false},
      {m:'"abc_" - valid',i:'abc_',e:true},
      {m:'"_abc" - valid',i:'_abc',e:true},
      {m:'"abc_abc" - valid',i:'_abc',e:true}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidUNIXUser(test.i)).to.equal(test.e);
      })
    });
  });
  describe('#isValidDir(value)', function() {
    var tests = [
      {m:'"dir" - invalid',i:'dir',e:false},
      {m:'"/dir" - valid',i:'/dir',e:true},
      {m:'"/dir1,dir2" - invalid',i:'/dir1,dir2',e:false},
      {m:'"/dir1,/dir2" - valid',i:'/dir1,/dir2',e:true},
      {m:'"/123" - valid',i:'/111',e:true},
      {m:'"/abc" - valid',i:'/abc',e:true},
      {m:'"/1a2b3c" - valid',i:'/1a2b3c',e:true}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidDir(test.i)).to.equal(test.e);
      })
    });
  });
  describe('#isAllowedDir(value)', function() {
    var tests = [
      {m:'"/home" - not allowed',i:'/home',e:false},
      {m:'"/homes" - not allowed',i:'/homes',e:false},
      {m:'"/home/" - not allowed',i:'/home/',e:false},
      {m:'"/homes/" - not allowed',i:'/homes/',e:false},
      {m:'"/dir" - allowed',i:'/dir',e:true},
      {m:'"/dir/home" - allowed',i:'/dir/home',e:true},
      {m:'"/dir/homes" - allowed',i:'/dir/homes',e:true},
      {m:'"/dir/home/" - allowed',i:'/dir/home/',e:true},
      {m:'"/dir/homes/" - allowed',i:'/dir/homes/',e:true}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isAllowedDir(test.i)).to.equal(test.e);
      })
    });
  });
  describe('#isValidConfigKey(value)', function() {
    var tests = [
      {m:'"123" - valid',i:'123',e:true},
      {m:'"abc" - valid',i:'abc',e:true},
      {m:'"abc123" - valid',i:'abc123',e:true},
      {m:'".abc." - valid',i:'.abc.',e:true},
      {m:'"_abc_" - valid',i:'_abc_',e:true},
      {m:'"-abc-" - valid',i:'-abc-',e:true},
      {m:'"abc 123" - invalid',i:'abc 123',e:false},
      {m:'"a"b" - invalid',i:'a"b',e:false},
      {m:'"a\'b" - invalid',i:'a\'b',e:false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidConfigKey(test.i)).to.equal(test.e);
      })
    });
  });

  describe('#isValidMatchesRegexp()', function() {
    var message = '`{0}` should be {1}',
        tests = [
          { value: '.*', expected: true },
          { value: '..', expected: true },
          { value: '.a1', expected: true },
          { value: '.*a1', expected: true },
          { value: '.*a1.*', expected: true },
          { value: '.*a1.a2', expected: true },
          { value: '.*a1.*.a2', expected: true },
          { value: '.*a1.*.a2.*.a3.a4.*.*', expected: true },
          { value: '*', expected: false },
          { value: '1>1', expected: false },
          { value: '.*a1,*', expected: false },
          { value: '?a1[1]asd[1]', expected: false },
          { value: 'a1[1]asd[1]', expected: true },
          { value: 'a1[1]asd[1][', expected: false },
          { value: 'a1[1|1]asd[1]', expected: true },
          { value: 'a1-2!', expected: true },
          { value: '|a1-2', expected: false },
          { value: '[a1', expected: false },
          { value: 'a{1}', expected: true },
          { value: 'a{1,2}', expected: true },
          { value: 'a{1,2}{', expected: false }
        ];
    tests.forEach(function(test) {
      it(message.format(test.value, (test.expected) ? 'valid' : 'not valid'), function() {
        expect(validator.isValidMatchesRegexp(test.value)).to.equal(test.expected);
      })
    });
  });
});

});

;require.register("test/views/application_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/application');

var view,
  modals = [],
  removed = false,
  events = [
    {
      event: 'keydown',
      which: 13,
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span class="btn-success"></span></div></div>',
      particle: '',
      length: 0
    },
    {
      event: 'keydown',
      keyCode: 13,
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span class="btn-success"></span></div></div>',
      particle: '',
      length: 0
    },
    {
      event: 'keyup',
      which: 27,
      key: 'Esc',
      html: '<div id="modal"><div class="modal-header"><span class="close"></span></div></div>',
      particle: '',
      length: 0
    },
    {
      event: 'keyup',
      keyCode: 27,
      key: 'Esc',
      html: '<div id="modal"><div class="modal-header"><span class="close"></span></div></div>',
      particle: '',
      length: 0
    },
    {
      event: 'keydown',
      which: 13,
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keydown',
      keyCode: 13,
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keyup',
      which: 27,
      key: 'Esc',
      html: '<div id="modal"><div class="modal-header"><span></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keyup',
      keyCode: 27,
      key: 'Esc',
      html: '<div id="modal"><div class="modal-header"><span></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keydown',
      which: 13,
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span class="btn-success" disabled="disabled"></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keydown',
      keyCode: 13,
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span class="btn-success" disabled="disabled"></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keydown',
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span class="btn-success"></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keyup',
      key: 'Esc',
      html: '<div id="modal"><div class="modal-footer"><span class="close"></span></div></div>',
      particle: 'not ',
      length: 1
    }
  ];

describe('App.ApplicationView', function () {

  before(function () {
    if($('#modal').length) {
      removed = true;
    }
    while($('#modal').length) {
      modals.push({
        modal: $('#modal'),
        parent: $('modal').parent()
      });
      $('#modal').remove();
    }
  });

  beforeEach(function () {
    view = App.ApplicationView.create({
      template: null
    });
  });

  afterEach(function () {
    $('#modal').remove();
  });

  after(function () {
    if (removed) {
      modals.forEach(function (item) {
        item.parent.append(item.modal);
      });
    }
  });

  describe('#didInsertElement', function () {
    events.forEach(function (item) {
      it('should ' + item.particle + 'close modal window on ' + item.key + ' press', function () {
        $('body').append(item.html);
        $('span').click(function () {
          $('#modal').remove();
        });
        view.didInsertElement();
        var e = $.Event(item.event);
        e.which = item.which;
        e.keyCode = item.keyCode;
        $(document).trigger(e);
        expect($('#modal')).to.have.length(item.length);
      });
    });
  });

});

});

;require.register("test/views/common/chart/linear_time_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/chart/linear_time');

describe('App.ChartLinearTimeView', function () {

  var chartLinearTimeView = App.ChartLinearTimeView.create({});

  describe('#transformData ([[1, 2], [2, 3], [3, 4]], "abc")', function () {

    var data = [[1, 2], [2, 3], [3, 4]];
    var name = 'abc';
    var result = chartLinearTimeView.transformData(data, name);
    it('"name" should be "abc" ', function () {
      expect(result.name).to.equal('abc');
    });
    it('data size should be 3 ', function () {
      expect(result.data.length).to.equal(3);
    });
    it('data[0].x should be 2 ', function () {
      expect(result.data[0].x).to.equal(2);
    });
    it('data[0].y should be 1 ', function () {
      expect(result.data[0].y).to.equal(1);
    })
  }),
  describe('#yAxisFormatter', function() {
    var tests = [
      {m:'undefined to 0',i:undefined,e:0},
      {m:'NaN to 0',i:NaN,e:0},
      {m:'0 to 0',i:'0',e:'0'},
      {m:'1000 to 1K',i:'1000',e:'1K'},
      {m:'1000000 to 1M',i:'1000000',e:'1M'},
      {m:'1000000000 to 1B',i:'1000000000',e:'1B'},
      {m:'1000000000000 to 1T',i:'1000000000000',e:'1T'},
      {m:'1048576 to 1.049M',i:'1048576',e:'1.049M'},
      {m:'1073741824 to 1.074B',i:'1073741824',e:'1.074B'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(chartLinearTimeView.yAxisFormatter(test.i)).to.equal(test.e);
      });
    });
  }),
  describe('#checkSeries', function() {
    var tests = [
      {m:'undefined - false',i:undefined,e:false},
      {m:'NaN - false',i:NaN,e:false},
      {m:'object without data property - false',i:[{}],e:false},
      {m:'object with empty data property - false',i:[{data:[]}],e:false},
      {m:'object with invalid data property - false',i:[{data:[1]}],e:false},
      {m:'object with valid data property - true',i:[{data:[{x:1,y:1},{x:2,y:2}]}],e:true}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(chartLinearTimeView.checkSeries(test.i)).to.equal(test.e);
      });
    });
  }),
  describe('#BytesFormatter', function() {
    var tests = [
      {m:'undefined to "0 B"',i:undefined,e:'0 B'},
      {m:'NaN to "0 B"',i:NaN,e:'0 B'},
      {m:'0 to "0 B"',i:0,e:'0 B'},
      {m:'124 to "124 B"',i:124,e:'124 B'},
      {m:'1024 to "1 KB"',i:1024,e:'1 KB'},
      {m:'1536 to "1 KB"',i:1536,e:'1.5 KB'},
      {m:'1048576 to "1 MB"',i:1048576,e:'1 MB'},
      {m:'1073741824 to "1 GB"',i:1073741824,e:'1 GB'},
      {m:'1610612736 to "1.5 GB"',i:1610612736,e:'1.5 GB'}
    ];

    tests.forEach(function(test) {
      it(test.m + ' ', function () {

        expect(App.ChartLinearTimeView.BytesFormatter(test.i)).to.equal(test.e);
      });
    });
  }),
  describe('#PercentageFormatter', function() {
    var tests = [
      {m:'undefined to "0 %"',i:undefined,e:'0 %'},
      {m:'NaN to "0 %"',i:NaN,e:'0 %'},
      {m:'0 to "0 %"',i:0,e:'0 %'},
      {m:'1 to "1%"',i:1,e:'1%'},
      {m:'1.12341234 to "1.123%"',i:1.12341234,e:'1.123%'},
      {m:'-11 to "-11%"',i:-11,e:'-11%'},
      {m:'-11.12341234 to "-11.123%"',i:-11.12341234,e:'-11.123%'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(App.ChartLinearTimeView.PercentageFormatter(test.i)).to.equal(test.e);
      });
    });
  });
  describe('#TimeElapsedFormatter', function() {
    var tests = [
      {m:'undefined to "0 ms"',i:undefined,e:'0 ms'},
      {m:'NaN to "0 ms"',i:NaN,e:'0 ms'},
      {m:'0 to "0 ms"',i:0,e:'0 ms'},
      {m:'1000 to "1000 ms"',i:1000,e:'1000 ms'},
      {m:'120000 to "2 m"',i:120000,e:'2 m'},
      {m:'3600000 to "60 m"',i:3600000,e:'60 m'},
      {m:'5000000 to "1 hr"',i:5000000,e:'1 hr'},
      {m:'7200000 to "2 hr"',i:7200000,e:'2 hr'},
      {m:'90000000 to "1 d"',i:90000000,e:'1 d'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(App.ChartLinearTimeView.TimeElapsedFormatter(test.i)).to.equal(test.e);
      });
    });
  })
});

});

;require.register("test/views/common/configs/services_config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/chart/pie');
require('views/common/configs/services_config');


describe('App.ServiceConfigView', function () {
  var controller = App.WizardStep7Controller.create({
    selectedServiceObserver: function(){},
    switchConfigGroupConfigs: function(){}
  });
  var view = App.ServiceConfigView.create({
    controller: controller
  });
  var testCases = [
    {
      title: 'selectedConfigGroup is null',
      result: {
        'category1': false,
        'category2': true,
        'category3': false
      },
      selectedConfigGroup: null,
      selectedService: {
        serviceName: 'TEST',
        configCategories: [
          App.ServiceConfigCategory.create({ name: 'category1', canAddProperty: false}),
          App.ServiceConfigCategory.create({ name: 'category2', siteFileName: 'xml', canAddProperty: true}),
          App.ServiceConfigCategory.create({ name: 'category3', siteFileName: 'xml', canAddProperty: false})
        ]
      }
    },
    {
      title: 'selectedConfigGroup is default group',
      result: {
        'category1': true,
        'category2': true,
        'category3': false
      },
      selectedConfigGroup: {isDefault: true},
      selectedService: {
        serviceName: 'TEST',
        configCategories: [
          App.ServiceConfigCategory.create({ name: 'category1', canAddProperty: true}),
          App.ServiceConfigCategory.create({ name: 'category2', siteFileName: 'xml', canAddProperty: true}),
          App.ServiceConfigCategory.create({ name: 'category3', siteFileName: 'xml', canAddProperty: false})
        ]
      }
    },
    {
      title: 'selectedConfigGroup is not default group',
      result: {
        'category1': false,
        'category2': false
      },
      selectedConfigGroup: {},
      selectedService: {
        serviceName: 'TEST',
        configCategories: [
          App.ServiceConfigCategory.create({ name: 'category1', siteFileName: 'xml', canAddProperty: true}),
          App.ServiceConfigCategory.create({ name: 'category2', siteFileName: 'xml', canAddProperty: false})
        ]
      }
    }
  ];
  describe('#checkCanEdit', function () {
    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('selectedService', test.selectedService);
        controller.set('selectedConfigGroup', test.selectedConfigGroup);
        view.checkCanEdit();
        controller.get('selectedService.configCategories').forEach(function (category) {
          expect(category.get('canAddProperty')).to.equal(test.result[category.get('name')]);
        });
      });
    });
  });
});

describe('App.ServiceConfigsByCategoryView', function () {

  var view = App.ServiceConfigsByCategoryView.create({
    serviceConfigs: []
  });

  var result = [1, 2, 3, 4];

  var testData = [
    {
      title: 'four configs in correct order',
      configs: [
        Em.Object.create({index: 1, resultId: 1}),
        Em.Object.create({index: 2, resultId: 2}),
        Em.Object.create({index: 3, resultId: 3}),
        Em.Object.create({index: 4, resultId: 4})
      ]
    },
    {
      title: 'four configs in reverse order',
      configs: [
        Em.Object.create({index: 4, resultId: 4}),
        Em.Object.create({index: 3, resultId: 3}),
        Em.Object.create({index: 2, resultId: 2}),
        Em.Object.create({index: 1, resultId: 1})
      ]
    },
    {
      title: 'four configs in random order',
      configs: [
        Em.Object.create({index: 3, resultId: 3}),
        Em.Object.create({index: 4, resultId: 4}),
        Em.Object.create({index: 1, resultId: 1}),
        Em.Object.create({index: 2, resultId: 2})
      ]
    },
    {
      title: 'four configs with no index',
      configs: [
        Em.Object.create({resultId: 1}),
        Em.Object.create({resultId: 2}),
        Em.Object.create({resultId: 3}),
        Em.Object.create({resultId: 4})
      ]
    },
    {
      title: 'four configs but one with index',
      configs: [
        Em.Object.create({resultId: 2}),
        Em.Object.create({resultId: 3}),
        Em.Object.create({resultId: 4}),
        Em.Object.create({index: 1, resultId: 1})
      ]
    },
    {
      title: 'index is null or not number',
      configs: [
        Em.Object.create({index: null, resultId: 3}),
        Em.Object.create({index: 1, resultId: 1}),
        Em.Object.create({index: 2, resultId: 2}),
        Em.Object.create({index: 'a', resultId: 4})
      ]
    },
    {
      title: 'four configs when indexes skipped',
      configs: [
        Em.Object.create({index: 88, resultId: 3}),
        Em.Object.create({index: 67, resultId: 2}),
        Em.Object.create({index: 111, resultId: 4}),
        Em.Object.create({index: 3, resultId: 1})
      ]
    }
  ];

  describe('#sortByIndex', function () {
    testData.forEach(function(_test){
      it(_test.title, function () {
        expect(view.sortByIndex(_test.configs).mapProperty('resultId')).to.deep.equal(result);
      })
    })
  });

  describe('#updateReadOnlyFlags', function () {
    it('if canEdit is true then isEditable flag of configs shouldn\'t be changed', function () {
      view.set('canEdit', true);
      view.set('serviceConfigs', [
        Em.Object.create({
          name: 'config1',
          isEditable: true
        }),
        Em.Object.create({
          name: 'config2',
          isEditable: false
        })
      ]);
      view.updateReadOnlyFlags();
      expect(view.get('serviceConfigs').findProperty('name', 'config1').get('isEditable')).to.equal(true);
      expect(view.get('serviceConfigs').findProperty('name', 'config2').get('isEditable')).to.equal(false);
    });
    it('if canEdit is false then configs shouldn\'t be editable', function () {
      view.set('canEdit', false);
      view.set('serviceConfigs', [
        Em.Object.create({
          name: 'config1',
          isEditable: true
        }),
        Em.Object.create({
          name: 'config2',
          isEditable: false
        })
      ]);
      view.updateReadOnlyFlags();
      expect(view.get('serviceConfigs').findProperty('name', 'config1').get('isEditable')).to.equal(false);
      expect(view.get('serviceConfigs').findProperty('name', 'config2').get('isEditable')).to.equal(false);
    });
    it('if canEdit is false then config overrides shouldn\'t be editable', function () {
      view.set('canEdit', false);
      view.set('serviceConfigs', [
        Em.Object.create({
          name: 'config',
          isEditable: true,
          overrides: [
            Em.Object.create({
              name: 'override1',
              isEditable: true
            }),
            Em.Object.create({
              name: 'override2',
              isEditable: false
            })
          ]
        })
      ]);
      view.updateReadOnlyFlags();
      var overrides = view.get('serviceConfigs').findProperty('name', 'config').get('overrides');
      expect(overrides.findProperty('name', 'override1').get('isEditable')).to.equal(false);
      expect(overrides.findProperty('name', 'override2').get('isEditable')).to.equal(false);
    });
    it('if canEdit is true then isEditable flag of overrides shouldn\'t be changed', function () {
      view.set('canEdit', true);
      view.set('serviceConfigs', [
        Em.Object.create({
          name: 'config',
          isEditable: true,
          overrides: [
            Em.Object.create({
              name: 'override1',
              isEditable: true
            }),
            Em.Object.create({
              name: 'override2',
              isEditable: false
            })
          ]
        })
      ]);
      view.updateReadOnlyFlags();
      var overrides = view.get('serviceConfigs').findProperty('name', 'config').get('overrides');
      expect(overrides.findProperty('name', 'override1').get('isEditable')).to.equal(true);
      expect(overrides.findProperty('name', 'override2').get('isEditable')).to.equal(false);
    })
  })
});

});

;require.register("test/views/common/filter_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var filters = require('views/common/filter_view');

describe('filters.getFilterByType', function () {


  describe('ambari-bandwidth', function () {

    var filter = filters.getFilterByType('ambari-bandwidth');
    var testData = [
      {
        condition: '<',
        value: 'any value',
        result: true
      },
      {
        condition: '=',
        value: 'any value',
        result: true
      },
      {
        condition: '>',
        value: 'any value',
        result: true
      },
      {
        condition: '1',
        value: '1GB',
        result: true
      },
      {
        condition: '1g',
        value: '1GB',
        result: true
      },
      {
        condition: '=1g',
        value: '1GB',
        result: true
      },
      {
        condition: '<1g',
        value: '0.9GB',
        result: true
      },
      {
        condition: '>1g',
        value: '1.1GB',
        result: true
      },
      {
        condition: '=1k',
        value: '1KB',
        result: true
      },
      {
        condition: '<1k',
        value: '0.9KB',
        result: true
      },
      {
        condition: '>1k',
        value: '1.1KB',
        result: true
      },
      {
        condition: '=1m',
        value: '1MB',
        result: true
      },
      {
        condition: '<1m',
        value: '0.9MB',
        result: true
      },
      {
        condition: '>1m',
        value: '1.1MB',
        result: true
      },
      {
        condition: '=1024k',
        value: '1MB',
        result: true
      },
      {
        condition: '=1024m',
        value: '1GB',
        result: true
      }
    ];

    testData.forEach(function(item){
      it('Condition: ' + item.condition + ' - match value: ' + item.value, function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('duration', function () {

    var filter = filters.getFilterByType('duration');
    var testData = [
      {
        condition: '<',
        value: 'any value',
        result: true
      },
      {
        condition: '=',
        value: 'any value',
        result: true
      },
      {
        condition: '>',
        value: 'any value',
        result: true
      },
      {
        condition: '1',
        value: '1000',
        result: true
      },
      {
        condition: '1s',
        value: '1000',
        result: true
      },
      {
        condition: '=1s',
        value: '1000',
        result: true
      },
      {
        condition: '>1s',
        value: '1001',
        result: true
      },
      {
        condition: '<1s',
        value: '999',
        result: true
      },
      {
        condition: '=1m',
        value: '60000',
        result: true
      },
      {
        condition: '>1m',
        value: '60001',
        result: true
      },
      {
        condition: '<1m',
        value: '59999',
        result: true
      },
      {
        condition: '=1h',
        value: '3600000',
        result: true
      },
      {
        condition: '>1h',
        value: '3600001',
        result: true
      },
      {
        condition: '<1h',
        value: '3599999',
        result: true
      }

    ];

    testData.forEach(function(item){
      it('Condition: ' + item.condition + ' - match value: ' + item.value, function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('date', function () {

    var filter = filters.getFilterByType('date');
    var currentTime = new Date().getTime();
    var testData = [
      {
        condition: 'Past 1 Day',
        value: currentTime - 86300000,
        result: true
      },
      {
        condition: 'Past 2 Days',
        value: currentTime - 172700000,
        result: true
      },
      {
        condition: 'Past 7 Days',
        value: currentTime - 604700000,
        result: true
      },
      {
        condition: 'Past 14 Days',
        value: currentTime - 1209500000,
        result: true
      },
      {
        condition: 'Past 30 Days',
        value: currentTime - 2591900000,
        result: true
      },
      {
        condition: 'Any',
        value: 'any value',
        result: true
      }
    ];

    testData.forEach(function(item){
      it('Condition: ' + item.condition + ' - match value: ' + item.value, function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('number', function () {

    var filter = filters.getFilterByType('number');
    var testData = [
      {
        condition: '<',
        value: 'any value',
        result: true
      },
      {
        condition: '=',
        value: 'any value',
        result: true
      },
      {
        condition: '>',
        value: 'any value',
        result: true
      },
      {
        condition: '1',
        value: '1',
        result: true
      },
      {
        condition: '=1',
        value: '1',
        result: true
      },
      {
        condition: '<1',
        value: '0',
        result: true
      },
      {
        condition: '>1',
        value: '2',
        result: true
      }
    ];

    testData.forEach(function(item){
      it('Condition: ' + item.condition + ' - match value: ' + item.value, function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('multiple', function () {

    var filter = filters.getFilterByType('multiple');
    var commonValue = [
      {componentName: 'DATANODE'},
      {componentName: 'NAMENODE'},
      {componentName: 'JOBTRACKER'}
    ];
    var testData = [
      {
        condition: 'DATANODE',
        value: commonValue,
        result: true
      },
      {
        condition: 'DATANODE,NAMENODE',
        value: commonValue,
        result: true
      },
      {
        condition: 'DATANODE,NAMENODE,JOBTRACKER',
        value: commonValue,
        result: true
      },
      {
        condition: 'JOBTRACKER,TASKTRACKER',
        value: commonValue,
        result: true
      },
      {
        condition: 'TASKTRACKER',
        value: commonValue,
        result: false
      }
    ];

    testData.forEach(function(item){
      it('Condition: ' + item.condition + ((item.result) ? ' - match ' : ' - doesn\'t match ' + 'value: ') +
        item.value.mapProperty('componentName').join(" "), function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('string', function () {

    var filter = filters.getFilterByType('string');

    var testData = [
      {
        condition: '',
        value: '',
        result: true
      },
      {
        condition: '',
        value: 'hello',
        result: true
      },
      {
        condition: 'hello',
        value: 'hello',
        result: true
      },
      {
        condition: 'HeLLo',
        value: 'hello',
        result: true
      },
      {
        condition: 'he',
        value: 'hello',
        result: true
      },
      {
        condition: 'lo',
        value: 'hello',
        result: true
      },
      {
        condition: 'lol',
        value: 'hello',
        result: false
      },
      {
        condition: 'hello',
        value: '',
        result: false
      }
    ];

    testData.forEach(function(item){
      it('Condition: ' + item.condition + ((item.result) ? ' - match ' : ' - doesn\'t match ' + 'value: ') + item.value, function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });
});

});

;require.register("test/views/common/quick_link_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/quick_view_link_view');

describe('App.QuickViewLinks', function () {

  var quickViewLinks = App.QuickViewLinks.create({});

  describe('#setPort', function () {
    var testData = [
      Em.Object.create({
        'service_id': 'YARN',
        'protocol': 'http',
        'result': '8088',
        'default_http_port': '8088',
        'default_https_port': '8090',
        'regex': '\\w*:(\\d+)'
      }),
      Em.Object.create({
        'service_id': 'YARN',
        'protocol': 'https',
        'https_config': 'https_config',
        'result': '8090',
        'default_http_port': '8088',
        'default_https_port': '8090',
        'regex': '\\w*:(\\d+)'
      }),
      Em.Object.create({
        'service_id': 'YARN',
        'protocol': 'https',
        'https_config': 'https_config',
        'result': '8090',
        'default_http_port': '8088',
        'default_https_port': '8090',
        'regex': '\\w*:(\\d+)'
      })
    ];

    testData.forEach(function(item) {
      it(item.service_id + ' ' + item.protocol, function () {
        expect(quickViewLinks.setPort(item, item.protocol, item.version)).to.equal(item.result);
      })
    },this);
  });
});

});

;require.register("test/views/common/rolling_restart_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/rolling_restart_view');

describe('App.RollingRestartView', function () {

  var view = App.RollingRestartView.create({
    restartHostComponents: []
  });

  describe('#initialize', function () {
    var testCases = [
      {
        restartHostComponents: [],
        result: {
          batchSize: 1,
          tolerateSize: 1
        }
      },
      {
        restartHostComponents: new Array(10),
        result: {
          batchSize: 1,
          tolerateSize: 1
        }
      },
      {
        restartHostComponents: new Array(11),
        result: {
          batchSize: 2,
          tolerateSize: 2
        }
      },
      {
        restartHostComponents: new Array(20),
        result: {
          batchSize: 2,
          tolerateSize: 2
        }
      }
    ];

    testCases.forEach(function (test) {
      it(test.restartHostComponents.length + ' components to restart', function () {
        view.set('batchSize', -1);
        view.set('interBatchWaitTimeSeconds', -1);
        view.set('tolerateSize', -1);
        view.set('restartHostComponents', test.restartHostComponents);
        view.initialize();
        expect(view.get('batchSize')).to.equal(test.result.batchSize);
        expect(view.get('tolerateSize')).to.equal(test.result.tolerateSize);
      })
    }, this);
  });
});

});

;require.register("test/views/common/table_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/db');
require('views/common/filter_view');
require('views/common/sort_view');
require('mixins');
require('mixins/common/userPref');
require('views/common/table_view');

describe('App.TableView', function () {

  var view;

  beforeEach(function() {
    App.db.cleanUp();
  });

  afterEach(function() {
    App.db.cleanUp();
  });

  describe('#updatePaging', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        filtersUsedCalc: function() {},
        filter: function() {}
      });
      view.clearFilters();
      view.updateFilter();
    });

    it('should set "startIndex" to 0 if "filteredContent" is empty', function() {
      view.set('filteredContent', []);
      expect(view.get('startIndex')).to.equal(0);
    });

    it('should set "startIndex" to 1 if "filteredContent" is not empty', function() {
      view.set('filteredContent', d3.range(1, 10));
      expect(view.get('startIndex')).to.equal(1);
    });

  });

  describe('#endIndex', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        filtersUsedCalc: function() {},
        filter: function() {}
      });
      view.clearFilters();
      view.updateFilter();
    });

    it('should be recalculated if "startIndex" was changed', function() {
      view.set('startIndex', 2);
      expect(view.get('endIndex')).to.equal(11);
    });

    it('should be recalculated if "displayLength" was changed', function() {
      view.set('displayLength', 5);
      expect(view.get('endIndex')).to.equal(5);
    });

    it('should be recalculated (but not changed) if "filteredContent" was changed (and "filterContent.length" is more than "startIndex + displayLength")', function() {
      var endIndexBefore = view.get('endIndex');
      view.set('filteredContent', d3.range(2,100));
      expect(view.get('endIndex')).to.equal(endIndexBefore);
    });

    it('should be recalculated (and changed) if "filteredContent" was changed (and "filterContent.length" is less than "startIndex + displayLength")', function() {
      var endIndexBefore = view.get('endIndex');
      var indx = 4;
      view.set('filteredContent', d3.range(1,indx));
      expect(view.get('endIndex')).to.not.equal(endIndexBefore);
      expect(view.get('endIndex')).to.equal(indx - 1);
    });

  });

  describe('#pageContent', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        endIndex: 10,
        filtersUsedCalc: function() {},
        filter: function() {}
      });
      view.clearFilters();
      view.updateFilter();
    });

    it('should be recalculated if "startIndex" was changed', function() {
      view.set('startIndex', 2);
      expect(view.get('pageContent').length).to.equal(9);
    });

    it('should be recalculated if "endIndex" was changed', function() {
      view.set('endIndex', 5);
      expect(view.get('pageContent').length).to.equal(5);
    });

    it('should be recalculated if "filteredContent" was changed', function() {
      var pageContentBefore = view.get('pageContent');
      view.set('filteredContent', d3.range(2,100));
      expect(view.get('pageContent').length).to.equal(pageContentBefore.length);
      expect(view.get('pageContent')).to.not.eql(pageContentBefore);
    });

  });

  describe('#clearFilters', function() {

    it('should set "filterConditions" to empty array', function() {
      view.clearFilters();
      expect(view.get('filterConditions')).to.eql([]);
    });

  });

  describe('#filtersUsedCalc', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        endIndex: 10,
        filter: function() {}
      });
    });

    it('should set "filtersUsed" to false if "filterConditions" is empty array', function() {
      view.set('filterConditions', []);
      view.filtersUsedCalc();
      expect(view.get('filtersUsed')).to.equal(false);
    });

    it('should set "filtersUsed" to false if each value in "filterConditions" is empty', function() {
      view.set('filterConditions', [{value:''}, {value:''}]);
      view.filtersUsedCalc();
      expect(view.get('filtersUsed')).to.equal(false);
    });

    it('should set "filtersUsed" to true if one or more values in "filterConditions" are not empty', function() {
      view.set('filterConditions', [{value:''}, {value:'lol'}]);
      view.filtersUsedCalc();
      expect(view.get('filtersUsed')).to.equal(true);
    });

  });

  describe('#nextPage', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        endIndex: 10,
        filter: function() {}
      });
    });

    it('should set "startIndex" if "filteredContent.length is greater than "startIndex" + "displayLength"', function() {
      var oldStartIndex = view.get('startIndex');
      var displayLength = 50;
      view.set('displayLength', displayLength);
      view.nextPage();
      expect(view.get('startIndex')).to.equal(oldStartIndex + displayLength);
    });

    it('should not set "startIndex" if "filteredContent.length is equal to "startIndex" + "displayLength"', function() {
      var oldStartIndex = view.get('startIndex');
      var displayLength = 99;
      view.set('displayLength', displayLength);
      view.nextPage();
      expect(view.get('startIndex')).to.equal(oldStartIndex);
    });

    it('should not set "startIndex" if "filteredContent.length is less than "startIndex" + "displayLength"', function() {
      var oldStartIndex = view.get('startIndex');
      var displayLength = 100;
      view.set('displayLength', displayLength);
      view.nextPage();
      expect(view.get('startIndex')).to.equal(oldStartIndex);
    });

  });

  describe('#previousPage', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 50,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        endIndex: 60,
        filter: function() {}
      });
    });

    it('should set "startIndex" to 1', function() {
      var displayLength = 50;
      view.set('displayLength', displayLength);
      view.previousPage();
      expect(view.get('startIndex')).to.equal(1);
    });

    it('should not set "startIndex" to 40', function() {
      view.set('startIndex', 50);
      var displayLength = 10;
      view.set('displayLength', displayLength);
      view.previousPage();
      expect(view.get('startIndex')).to.equal(40);
    });

  });

});

});

;require.register("test/views/experimental_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/experimental');

var view,
  transition,
  supports = {},
  transitionStubbed = false,
  viewSupports = [
    Em.Object.create({
      name: 'sup0',
      selected: true
    }),
    Em.Object.create({
      name: 'sup1',
      selected: false
    })
  ],
  saveObject = {};

describe('App.ExperimentalView', function () {

  before(function () {
    viewSupports.forEach(function(item) {
      supports[item.get('name')] = item.get('selected');
    });
    sinon.stub(App, 'get', function(k) {
      if (k === 'supports') return supports;
      return Em.get(App, k);
    });
  });

  beforeEach(function () {
    view = App.ExperimentalView.create();
  });

  after(function () {
    App.get.restore();
  });

  describe('#supports', function () {
    it('should take data from App.supports', function () {
      expect(view.get('supports')).to.eql(viewSupports);
    });
  });

  describe('#doSave', function () {

    before(function () {
      sinon.stub(Ember, 'set', function (p, v) {
        if (p.indexOf('App.supports.' != -1)) {
          p = p.replace('App.supports.', '');
          saveObject[p] = v;
          return;
        }
        return Ember.set(p, v);
      });
      if (App.router.get('transitionTo') === undefined) {
        App.router.set('transitionTo', Em.K);
      } else {
        sinon.stub(App.router, 'transitionTo', function (k) {
          if (k === 'root.index') return Em.K;
          return App.router.transitionTo(k);
        });
        transitionStubbed = true;
      }
    });

    after(function () {
      Ember.set.restore();
      if (transitionStubbed) {
        App.router.transitionTo.restore();
      } else {
        App.router.set('transitionTo', undefined);
      }
    });

    it('should pass data to App.supports', function () {
      view.set('supports', viewSupports);
      view.doSave();
      expect(saveObject).to.eql(supports);
    });

  });

});

});

;require.register("test/views/installer_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/installer');

var view,
  stepsCount = 11,
  isStepDisabled = [],
  properties = [];

for (var i = 0; i < stepsCount; i++ ) {
  isStepDisabled.push(Em.Object.create({
    step: i,
    value: Boolean(Math.floor(Math.random() * 2))
  }));
  properties.push('isStep' + i + 'Disabled');
}

describe('App.InstallerView', function () {

  beforeEach(function () {
    view = App.InstallerView.create({
      controller: {
        isStepDisabled: isStepDisabled
      }
    });
  });

  properties.forEach(function (item, index) {
    describe(item, function () {
      it('should take value from isStepDisabled', function () {
        expect(view.get(item)).to.equal(isStepDisabled.findProperty('step', index).get('value'));
      });
    });
  });

});

});

;require.register("test/views/login_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/login');

var view,
  controller,
  pass;

describe('App.LoginView', function () {

  before(function () {
    sinon.stub(App, 'get', function(k) {
      if (k === 'router') return {
        login: Em.K
      };
      return Em.get(App, k);
    });
  });

  beforeEach(function () {
    view = App.LoginView.create();
    pass = view.passTextField.create({
      controller: App.LoginController.create()
    });
  });

  after(function () {
    App.get.restore();
  });

  describe('#passTextField', function () {
    it('should change error message', function () {
      pass.insertNewline();
      expect(pass.get('controller.errorMessage')).to.be.empty;
    });
  });

});

});

;require.register("test/views/main/admin/user/create_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/user/create');

describe('App.MainAdminUserCreateView', function () {

  var view = App.MainAdminUserCreateView.create({
    userForm: Em.Object.create({
      isValid: function () {
        return this.get('mockIsValid');
      },
      getField: function () {
        return Em.Object.create();
      },
      isWarn: Em.K,
      propertyDidChange: Em.K,
      mockIsValid: false
    })
  });

  describe('#create()', function () {

    it('form is invalid', function () {
      view.set('userForm.mockIsValid', false);
      expect(view.create()).to.be.false;
    });
    it('form is valid', function () {
      view.set('userForm.mockIsValid', true);
      sinon.stub(view, 'identifyRoles', Em.K);
      sinon.stub(App.ajax, 'send', Em.K);

      expect(view.create()).to.be.true;
      expect(view.identifyRoles.calledOnce).to.be.true;
      expect(App.ajax.send.calledOnce).to.be.true;

      view.identifyRoles.restore();
      App.ajax.send.restore();
    });
  });

  describe('#identifyRoles()', function () {
    var mock = Em.Object.create();
    var form = Em.Object.create({
      getField: function () {
        return mock;
      }
    });

    it('admin is false', function () {
      mock.set('value', false);

      expect(view.identifyRoles(form)).to.equal('user');
      expect(mock.get('value')).to.equal('user');
    });
    it('admin is true', function () {
      mock.set('value', true);

      expect(view.identifyRoles(form)).to.equal('admin,user');
      expect(mock.get('value')).to.equal('admin,user');
    });
  });

  describe('#createUserSuccessCallback()', function () {

    it('', function () {
      var mock = {
        persistKey: function () {
          return 'persists';
        },
        postUserPref: Em.K
      };
      var params = {
        form: {
          getField: function () {
            return Em.Object.create({
              value: 'user_name_value'
            })
          },
          save: Em.K
        }
      };
      sinon.stub(App.ModalPopup, 'show', Em.K);
      sinon.stub(App.router, 'get', function () {
        return mock;
      });
      sinon.spy(mock, 'persistKey');
      sinon.spy(mock, 'postUserPref');
      sinon.spy(params.form, 'save');
      sinon.stub(App.router, 'transitionTo', Em.K);

      view.createUserSuccessCallback({}, {}, params);
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      expect(mock.persistKey.calledWith('user_name_value')).to.be.true;
      expect(mock.postUserPref.calledWith('persists', true)).to.be.true;
      expect(params.form.save.calledOnce).to.be.true;
      expect(App.router.transitionTo.calledWith('allUsers')).to.be.true;

      App.ModalPopup.show.restore();
      App.router.get.restore();
      App.router.transitionTo.restore();
    });
  });

  describe('#createUserErrorCallback()', function () {

    it('', function () {
      sinon.stub(App.ModalPopup, 'show', Em.K);

      view.createUserErrorCallback();
      expect(App.ModalPopup.show.calledOnce).to.be.true;

      App.ModalPopup.show.restore();
    });
  });

  describe('#keyPress()', function () {

    beforeEach(function () {
      sinon.stub(view, 'create', Em.K);
    });
    afterEach(function () {
      view.create.restore();
    });

    it('not "Enter" button pressed', function () {
      expect(view.keyPress({keyCode: 99})).to.be.true;
      expect(view.create.called).to.be.false;
    });
    it('"Enter" button pressed', function () {
      expect(view.keyPress({keyCode: 13})).to.be.false;
      expect(view.create.calledOnce).to.be.true;
    });
  });

  describe('#passwordValidation()', function () {
    var mock = Em.Object.create();

    beforeEach(function () {
      sinon.stub(view.get('userForm'), 'getField', function () {
        return mock;
      });
      sinon.stub(view.get('userForm'), 'isValid', Em.K);
      sinon.stub(view.get('userForm'), 'isWarn', Em.K);
    });
    afterEach(function () {
      view.get('userForm').getField.restore();
      view.get('userForm').isValid.restore();
      view.get('userForm').isWarn.restore();
    });

    it('passwordValue is null, isPasswordDirty = false', function () {
      mock.set('value', null);
      view.set('isPasswordDirty', false);

      view.passwordValidation();
      expect(view.get('isPasswordDirty')).to.be.false;
      expect(view.get('userForm').isValid.called).to.be.false;
      expect(view.get('userForm').isWarn.called).to.be.false;
    });
    it('passwordValue is correct, isPasswordDirty = true', function () {
      mock.set('value', 'pass');
      view.set('isPasswordDirty', true);

      view.passwordValidation();
      expect(view.get('isPasswordDirty')).to.be.true;
      expect(view.get('userForm').isValid.calledOnce).to.be.true;
      expect(view.get('userForm').isWarn.calledOnce).to.be.true;
    });
    it('passwordValue is correct, isPasswordDirty = false', function () {
      mock.set('value', 'pass');
      view.set('isPasswordDirty', false);

      view.passwordValidation();
      expect(view.get('isPasswordDirty')).to.be.true;
      expect(view.get('userForm').isValid.calledOnce).to.be.true;
      expect(view.get('userForm').isWarn.calledOnce).to.be.true;
    });
  });

  describe('#didInsertElement()', function () {
    it('propertyDidChange function should be called', function () {
      sinon.spy(view.get('userForm'), 'propertyDidChange');

      view.didInsertElement();
      expect(view.get('userForm').propertyDidChange.calledWith('object')).to.be.true;

      view.get('userForm').propertyDidChange.restore();
    });
  });
});

});

;require.register("test/views/main/admin/user/edit_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/user/edit');

describe('App.MainAdminUserEditView', function () {

  var view = App.MainAdminUserEditView.create({
    userForm: Em.Object.create({
      getField: function (property) {
        return this.get(property) || Em.Object.create();
      },
      isValid: Em.K,
      isWarn: Em.K,
      propertyDidChange: Em.K
    })
  });

  describe('#edit()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    afterEach(function () {
      view.get('userForm').isValid.restore();
      App.ajax.send.restore();
    });

    it('form is invalid', function () {
      sinon.stub(view.get('userForm'), 'isValid', function () {
        return false;
      });

      expect(view.edit()).to.be.false;
      expect(App.ajax.send.called).to.be.false;
    });
    it('form is valid', function () {
      sinon.stub(view.get('userForm'), 'isValid', function () {
        return true;
      });
      sinon.stub(view, 'identifyRoles', Em.K);
      sinon.stub(view, 'setPassword', Em.K);


      expect(view.edit()).to.be.true;
      expect(App.ajax.send.calledOnce).to.be.true;
      expect(view.identifyRoles.calledOnce).to.be.true;
      expect(view.setPassword.calledOnce).to.be.true;

      view.identifyRoles.restore();
      view.setPassword.restore();
    });
  });

  describe('#setPassword()', function () {
    var form = Em.Object.create({
      getField: function (property) {
        return this.get(property);
      },
      new_password: Em.Object.create({
        value: 'pass'
      }),
      old_password: Em.Object.create({
        value: 'pass'
      })
    });

    it('new_password value is empty', function () {
      var Users = {};
      form.set('new_password.value', "");

      expect(view.setPassword(Users, form)).to.be.false;
      expect(Users.password).to.be.undefined;
      expect(Users.old_password).to.be.undefined;
    });
    it('old_password value is empty', function () {
      var Users = {};
      form.set('old_password.value', "");

      expect(view.setPassword(Users, form)).to.be.false;
      expect(Users.password).to.be.undefined;
      expect(Users.old_password).to.be.undefined;
    });
    it('old_password and new_password values are correct', function () {
      var Users = {};
      form.set('old_password.value', "old_pass");
      form.set('new_password.value', "pass");

      expect(view.setPassword(Users, form)).to.be.true;
      expect(Users.password).to.equal('pass');
      expect(Users.old_password).to.equal('old_pass');
    });
  });

  describe('#identifyRoles()', function () {
    var mock = Em.Object.create();
    var form = Em.Object.create({
      getField: function () {
        return mock;
      }
    });

    it('admin is false', function () {
      mock.set('value', false);

      expect(view.identifyRoles(form)).to.equal('user');
      expect(mock.get('value')).to.equal('user');
    });
    it('admin is true', function () {
      mock.set('value', true);

      expect(view.identifyRoles(form)).to.equal('admin,user');
      expect(mock.get('value')).to.equal('admin,user');
    });
  });

  describe('#editUserSuccessCallback()', function () {
    it('', function () {
      var params = {
        form: {
          save: Em.K
        }
      };
      sinon.spy(params.form, 'save');
      sinon.stub(App.router, 'transitionTo', Em.K);

      view.editUserSuccessCallback({}, {}, params);
      expect(params.form.save.calledOnce).to.be.true;
      expect(App.router.transitionTo.calledWith('allUsers')).to.be.true;

      App.router.transitionTo.restore();
    });
  });

  describe('#editUserErrorCallback()', function () {
    it('show popup', function () {
      sinon.stub(App.ModalPopup, 'show', Em.K);
      sinon.stub(view, 'parseErrorMessage', Em.K);

      view.editUserErrorCallback({});
      expect(App.ModalPopup.show.calledOnce).to.be.true;

      App.ModalPopup.show.restore();
      view.parseErrorMessage.restore();
    });
  });

  describe('#parseErrorMessage()', function () {
    it('":" is not present in response', function () {
      var request = {
        responseText: JSON.stringify({
          message: 'content'
        })
      };

      expect(view.parseErrorMessage(request)).to.equal('content');
    });
    it('one ":" is  present in response', function () {
      var request = {
        responseText: JSON.stringify({
          message: 'content : b'
        })
      };

      expect(view.parseErrorMessage(request)).to.equal(' b');
    });
    it('several ":" are  present in response', function () {
      var request = {
        responseText: JSON.stringify({
          message: 'content : b: a'
        })
      };

      expect(view.parseErrorMessage(request)).to.equal(' a');
    });
  });

  describe('#keyPress()', function () {

    beforeEach(function () {
      sinon.stub(view, 'edit', Em.K);
    });
    afterEach(function () {
      view.edit.restore();
    });

    it('not "Enter" button pressed', function () {
      expect(view.keyPress({keyCode: 99})).to.be.true;
      expect(view.edit.called).to.be.false;
    });
    it('"Enter" button pressed', function () {
      expect(view.keyPress({keyCode: 13})).to.be.false;
      expect(view.edit.calledOnce).to.be.true;
    });
  });

  describe('#didInsertElement()', function () {

    beforeEach(function () {
      sinon.stub(view.get('userForm'), 'propertyDidChange', Em.K);
    });
    afterEach(function () {
      view.get('userForm').propertyDidChange.restore();
    });
    view.set('userForm.old_password', Em.Object.create());
    view.set('userForm.new_password', Em.Object.create());
    view.set('userForm.new_passwordRetype', Em.Object.create());

    it('isLdap value is true', function () {
      view.set('userForm.isLdap', Em.Object.create({
        value: true
      }));

      view.didInsertElement();
      expect(view.get('userForm').propertyDidChange.calledWith('object')).to.be.true;
      expect(view.get('userForm.old_password.disabled')).to.be.true;
      expect(view.get('userForm.new_password.disabled')).to.be.true;
      expect(view.get('userForm.new_passwordRetype.disabled')).to.be.true;
    });
    it('isLdap value is false', function () {
      view.set('userForm.isLdap', Em.Object.create({
        value: false
      }));

      view.didInsertElement();
      expect(view.get('userForm').propertyDidChange.calledWith('object')).to.be.true;
      expect(view.get('userForm.old_password.disabled')).to.be.false;
      expect(view.get('userForm.new_password.disabled')).to.be.false;
      expect(view.get('userForm.new_passwordRetype.disabled')).to.be.false;
    });
  });
});

});

;require.register("test/views/main/charts/heatmap/heatmap_host_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/charts/heatmap/heatmap_host');

describe('App.MainChartsHeatmapHostView', function() {

  var view = App.MainChartsHeatmapHostView.create({
    templateName: '',
    controller: Em.Object.create(),
    content: {}
  });

  describe('#hostTemperatureStyle', function () {
    var testCases = [
      {
        title: 'if hostToSlotMap is null then hostTemperatureStyle should be empty',
        hostName: 'host',
        controller: Em.Object.create({
          hostToSlotMap: null,
          selectedMetric: {
            slotDefinitions: []
          }
        }),
        result: ''
      },
      {
        title: 'if hostName is null then hostTemperatureStyle should be empty',
        hostName: '',
        controller: Em.Object.create({
          hostToSlotMap: {},
          selectedMetric: {
            slotDefinitions: []
          }
        }),
        result: ''
      },
      {
        title: 'if slot less than 0 then hostTemperatureStyle should be empty',
        hostName: 'host1',
        controller: Em.Object.create({
          hostToSlotMap: {
            "host1": -1
          },
          selectedMetric: {
            slotDefinitions: []
          }
        }),
        result: ''
      },
      {
        title: 'if slotDefinitions is null then hostTemperatureStyle should be empty',
        hostName: 'host1',
        controller: Em.Object.create({
          hostToSlotMap: {
            "host1": 1
          },
          selectedMetric: {
            slotDefinitions: null
          }
        }),
        result: ''
      },
      {
        title: 'if slotDefinitions length not more than slot number then hostTemperatureStyle should be empty',
        hostName: 'host1',
        controller: Em.Object.create({
          hostToSlotMap: {
            "host1": 1
          },
          selectedMetric: {
            slotDefinitions: [{}]
          }
        }),
        result: ''
      },
      {
        title: 'if slotDefinitions correct then hostTemperatureStyle should be "style1"',
        hostName: 'host1',
        controller: Em.Object.create({
          hostToSlotMap: {
            "host1": 1
          },
          selectedMetric: {
            slotDefinitions: [
              Em.Object.create({cssStyle: 'style0'}),
              Em.Object.create({cssStyle: 'style1'})
            ]
          }
        }),
        result: 'style1'
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        view.set('content.hostName', test.hostName);
        view.set('controller', test.controller);
        expect(view.get('hostTemperatureStyle')).to.equal(test.result);
      });
    });
  });

});

});

;require.register("test/views/main/charts/heatmap/heatmap_rack_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/charts/heatmap/heatmap_rack');

describe('App.MainChartsHeatmapRackView', function() {

  var view = App.MainChartsHeatmapRackView.create({
    templateName: ''
  });

  describe('#hostCssStyle', function () {
    var testCases = [
      {
        title: 'if hosts haven\'t been loaded yet then hostCssStyle should be have width 100%',
        rack: Em.Object.create({
          hosts: new Array(0),
          isLoaded: false
        }),
        result: "width:100%;float:left;"
      },
      {
        title: 'if hosts number is zero then hostCssStyle should be have width 10%',
        rack: Em.Object.create({
          hosts: new Array(0),
          isLoaded: true
        }),
        result: "width:10%;float:left;"
      },
      {
        title: 'if hosts number is one then hostCssStyle should be have width 99.5%',
        rack: Em.Object.create({
          hosts: new Array(1),
          isLoaded: true
        }),
        result: "width:99.5%;float:left;"
      },
      {
        title: 'if hosts number is ten then hostCssStyle should be have width 9.5%',
        rack: Em.Object.create({
          hosts: new Array(10),
          isLoaded: true
        }),
        result: "width:9.5%;float:left;"
      },
      {
        title: 'if hosts number is ten then hostCssStyle should be have width 10%',
        rack: Em.Object.create({
          hosts: new Array(11),
          isLoaded: true
        }),
        result: "width:10%;float:left;"
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        view.set('rack', test.rack);
        expect(view.get('hostCssStyle')).to.equal(test.result);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/dashboard/widget');

describe('App.DashboardWidgetView', function() {
  var dashboardWidgetView = App.DashboardWidgetView.create();

  describe('#viewID', function() {
    it('viewID is computed with id', function() {
      dashboardWidgetView.set('id', 5);
      expect(dashboardWidgetView.get('viewID')).to.equal('widget-5');
    });
  });

  describe('#hoverContentTopClass', function() {
    var tests = [
      {
        h: ['', ''],
        e: 'content-hidden-two-line',
        m: '2 lines'
      },
      {
        h: ['', '', ''],
        e: 'content-hidden-three-line',
        m: '3 lines'
      },
      {
        h: [''],
        e: '',
        m: '1 line'
      },
      {
        h: [],
        e: '',
        m: '0 lines'
      },
      {
        h: ['', '', '', '', ''],
        e: 'content-hidden-five-line',
        m: '5 lines'
      },
      {
        h: ['', '', '', ''],
        e: 'content-hidden-four-line',
        m: '4 lines'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        dashboardWidgetView.set('hiddenInfo', test.h);
        expect(dashboardWidgetView.get('hoverContentTopClass')).to.equal(test.e);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/datanode_live_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/datanode_live');

describe('App.DataNodeUpView', function() {

  var tests = [
    {
      data: 100,
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true
      }
    },
    {
      data: 0,
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false
      }
    },
    {
      data: 50,
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false
      }
    }
  ];

  tests.forEach(function(test) {
    describe('', function() {
      var dataNodeUpView = App.DataNodeUpView.create({model_type:null, data: test.data, content: test.data.toString()});
      it('isRed', function() {
        expect(dataNodeUpView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(dataNodeUpView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(dataNodeUpView.get('isGreen')).to.equal(test.e.isGreen);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/hbase_average_load_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/hbase_average_load');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.HBaseAverageLoadView', function() {

  var tests = [
    {
      model: {
        averageLoad: 1
      },
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false,
        isNA: false,
        content: '1'
      }
    },
    {
      model: {
        averageLoad: 10
      },
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: false,
        content: '10'
      }
    },
    {
      model: {
        averageLoad: 0
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '0'
      }
    },
    {
      model: {
        averageLoad: null
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable')
      }
    }
  ];

  tests.forEach(function(test) {
    describe('averageLoad - ' + test.model.averageLoad, function() {
      var hBaseAverageLoadView = App.HBaseAverageLoadView.create({model_type:null, model: test.model});
      it('content', function() {
        expect(hBaseAverageLoadView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(hBaseAverageLoadView.get('data')).to.equal(test.model.averageLoad);
      });
      it('isRed', function() {
        expect(hBaseAverageLoadView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(hBaseAverageLoadView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(hBaseAverageLoadView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(hBaseAverageLoadView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/hbase_master_uptime_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/hbase_master_uptime');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.HBaseMasterUptimeView', function() {

  var tests = [
    {
      model: Em.Object.create({
        masterStartTime: ((new Date()).getTime() - 192.1*24*3600*1000)
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '192.1 d',
        data: 192.1
      }
    },
    {
      model:  Em.Object.create({
        masterStartTime: 0
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    },
    {
      model:  Em.Object.create({
        masterStartTime: null
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  tests.forEach(function(test) {
    var hBaseMasterUptimeView = App.HBaseMasterUptimeView.create({model_type:null, model: test.model});
    hBaseMasterUptimeView.calc();
    describe('masterStartTime - ' + test.model.masterStartTime, function() {
      it('content', function() {
        expect(hBaseMasterUptimeView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(hBaseMasterUptimeView.get('data')).to.equal(test.e.data);
      });
      it('isRed', function() {
        expect(hBaseMasterUptimeView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(hBaseMasterUptimeView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(hBaseMasterUptimeView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(hBaseMasterUptimeView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/hbase_regions_in_transition_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widgets/hbase_regions_in_transition');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.HBaseRegionsInTransitionView', function() {

  var tests = [
    {
      model: {
        regionsInTransition: 1
      },
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false,
        isNA: false,
        content: '1'
      }
    },
    {
      model: {
        regionsInTransition: 10
      },
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: false,
        content: '10'
      }
    },
    {
      model: {
        regionsInTransition: 0
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '0'
      }
    },
    {
      model: {
        regionsInTransition: null
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: true,
        content: 'null'
      }
    }
  ];

  tests.forEach(function(test) {
    describe('regionsInTransition - ' + test.model.regionsInTransition, function() {
      var hBaseRegionsInTransitionView = App.HBaseRegionsInTransitionView.create({model_type:null, model: test.model});
      it('content', function() {
        expect(hBaseRegionsInTransitionView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(hBaseRegionsInTransitionView.get('data')).to.equal(test.model.regionsInTransition);
      });
      it('isRed', function() {
        expect(hBaseRegionsInTransitionView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(hBaseRegionsInTransitionView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(hBaseRegionsInTransitionView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(hBaseRegionsInTransitionView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/jobtracker_rpc_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/jobtracker_rpc');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.JobTrackerRpcView', function() {

  var tests = [
    {
      model: {
        jobTrackerRpc: 1
      },
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false,
        isNA: false,
        content: '1.00 ms',
        data: '1.00'
      }
    },
    {
      model: {
        jobTrackerRpc: 10
      },
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: false,
        content: '10.00 ms',
        data: '10.00'
      }
    },
    {
      model: {
        jobTrackerRpc: 0
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '0 ms',
        data: 0
      }
    },
    {
      model: {
        jobTrackerRpc: null
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  tests.forEach(function(test) {
    describe('jobTrackerRpc - ' + test.model.jobTrackerRpc, function() {
      var jobTrackerRpcView = App.JobTrackerRpcView.create({model_type:null, model: test.model});
      it('content', function() {
        expect(jobTrackerRpcView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(jobTrackerRpcView.get('data')).to.equal(test.e.data);
      });
      it('isRed', function() {
        expect(jobTrackerRpcView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(jobTrackerRpcView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(jobTrackerRpcView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(jobTrackerRpcView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/jobtracker_uptime_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/jobtracker_uptime');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.JobTrackerUptimeView', function() {

  var tests = [
    {
      model: Em.Object.create({
        jobTrackerStartTime: ((new Date()).getTime() - 192.1*24*3600*1000)
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '192.1 d',
        data: 192.1
      }
    },
    {
      model: Em.Object.create({
        jobTrackerStartTime: 0
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    },
    {
      model: Em.Object.create({
        jobTrackerStartTime: null
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  tests.forEach(function(test) {
    describe('jobTrackerStartTime - ' + test.model.jobTrackerStartTime, function() {
      var jobTrackerUptimeView = App.JobTrackerUptimeView.create({model_type:null, model: test.model});
      jobTrackerUptimeView.calc();
      it('content', function() {
        expect(jobTrackerUptimeView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(jobTrackerUptimeView.get('data')).to.equal(test.e.data);
      });
      it('isRed', function() {
        expect(jobTrackerUptimeView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(jobTrackerUptimeView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(jobTrackerUptimeView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(jobTrackerUptimeView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/links_widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/host_component');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/links_widget');

describe('App.LinkDashboardWidgetView', function() {

  var model = Em.Object.create({
    field: Em.Object.create({
      publicHostName: 'host1'
    })
  });
  var linkDashboardWidgetView = App.LinkDashboardWidgetView.create({
    model_type: null,
    model: model,
    port: 1234,
    modelField: 'field'
  });
  linkDashboardWidgetView.calc();
  describe('#webUrl', function() {
    it('calc', function() {
      expect(linkDashboardWidgetView.get('webUrl')).to.equal('http://host1:1234');
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/namenode_cpu_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('utils/helper');
require('views/common/chart/pie');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/pie_chart_widget');
require('views/main/dashboard/widgets/namenode_cpu');

describe('App.NameNodeCpuPieChartView', function() {

  var model = Em.Object.create({
    used: null,
    max: null
  });
  var nameNodeCpuPieChartView = App.NameNodeCpuPieChartView.create({
    model_type: null,
    model: model,
    modelFieldUsed: 'used',
    modelFieldMax: 'max',
    widgetHtmlId: 'fake'
  });

  nameNodeCpuPieChartView.calc();

  describe('#calcIsPieExists', function() {
    var tests = [
      {
        model: Em.Object.create({
          used: 1
        }),
        e: true,
        m: 'Exists'
      },
      {
        model: Em.Object.create({
          used: 0
        }),
        e: true,
        m: 'Exists'
      },
      {
        model: Em.Object.create({}),
        e: false,
        m: 'Not exists'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        nameNodeCpuPieChartView.set('model', test.model);
        expect(nameNodeCpuPieChartView.calcIsPieExists()).to.equal(test.e);
      });
    });
  });

  describe('calcDataForPieChart', function() {
    var tests = [
      {
        model: Em.Object.create({
          used: 0
        }),
        e: ['0.0', '0.00'],
        m: 'Nothing is used'
      },
      {
        model: Em.Object.create({
          used: 100
        }),
        e: ['100.0', '100.00'],
        m: 'All is used'
      },
      {
        model: Em.Object.create({
          used: 50
        }),
        e: ['50.0', '50.00'],
        m: 'Half is used'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        nameNodeCpuPieChartView.set('model', test.model);
        expect(nameNodeCpuPieChartView.calcDataForPieChart()).to.eql(test.e);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/namenode_rpc_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/namenode_rpc');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.NameNodeRpcView', function() {

  var tests = [
    {
      model: {
        nameNodeRpc: 1
      },
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false,
        isNA: false,
        content: '1.00 ms',
        data: '1.00'
      }
    },
    {
      model: {
        nameNodeRpc: 10
      },
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: false,
        content: '10.00 ms',
        data: '10.00'
      }
    },
    {
      model: {
        nameNodeRpc: 0
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '0 ms',
        data: 0
      }
    },
    {
      model: {
        nameNodeRpc: null
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  tests.forEach(function(test) {
    describe('nameNodeRpc - ' + test.model.nameNodeRpc, function() {
      var jobTrackerRpcView = App.NameNodeRpcView.create({model_type:null, model: test.model});
      it('content', function() {
        expect(jobTrackerRpcView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(jobTrackerRpcView.get('data')).to.equal(test.e.data);
      });
      it('isRed', function() {
        expect(jobTrackerRpcView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(jobTrackerRpcView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(jobTrackerRpcView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(jobTrackerRpcView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/namenode_uptime_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/namenode_uptime');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.NameNodeUptimeView', function() {

  var tests = [
    {
      model: Em.Object.create({
        nameNodeStartTime: ((new Date()).getTime() - 192.1*24*3600*1000)
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '192.1 d',
        data: 192.1
      }
    },
    {
      model:  Em.Object.create({
        nameNodeStartTime: 0
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    },
    {
      model:  Em.Object.create({
        nameNodeStartTime: null
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  tests.forEach(function(test) {
    var nameNodeUptimeView = App.NameNodeUptimeView.create({model_type:null, model: test.model});
    nameNodeUptimeView.calc();
    describe('nameNodeStartTime - ' + test.model.nameNodeStartTime, function() {
      it('content', function() {
        expect(nameNodeUptimeView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(nameNodeUptimeView.get('data')).to.equal(test.e.data);
      });
      it('isRed', function() {
        expect(nameNodeUptimeView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(nameNodeUptimeView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(nameNodeUptimeView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(nameNodeUptimeView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/node_managers_live_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/node_managers_live');

describe('App.NodeManagersLiveView', function() {

  var tests = [
    {
      model: {
        nodeManagersTotal: 3,
        nodeManagerLiveNodes: 2
      },
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false,
        isNA: false,
        content: '2/3',
        data: 67
      }
    },
    {
      model: {
        nodeManagersTotal: 2,
        nodeManagerLiveNodes: 2
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '2/2',
        data: 100
      }
    },
    {
      model: {
        nodeManagersTotal: 2,
        nodeManagerLiveNodes: 0
      },
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: false,
        content: '0/2',
        data: 0.00
      }
    }
  ];

  tests.forEach(function(test) {
    describe('nodeManagerNodes length - ' + test.model.nodeManagersTotal + ' | nodeManagerLiveNodes length - ' + test.model.nodeManagerLiveNodes, function() {
      var AppNodeManagersLiveView = App.NodeManagersLiveView.extend({nodeManagersLive: test.model.nodeManagerLiveNodes});
      var nodeManagersLiveView = AppNodeManagersLiveView.create({model_type:null, model: test.model});
      it('content', function() {
        expect(nodeManagersLiveView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(nodeManagersLiveView.get('data')).to.equal(test.e.data);
      });
      it('isRed', function() {
        expect(nodeManagersLiveView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(nodeManagersLiveView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(nodeManagersLiveView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(nodeManagersLiveView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/pie_chart_widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/common/chart/pie');
require('utils/helper');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/pie_chart_widget');

describe('App.PieChartDashboardWidgetView', function() {

  var model = Em.Object.create({
    used: null,
    max: null
  });
  var pieChartDashboardWidgetView = App.PieChartDashboardWidgetView.create({
    model_type: null,
    model: model,
    modelFieldUsed: 'used',
    modelFieldMax: 'max',
    widgetHtmlId: 'fake'
  });

  pieChartDashboardWidgetView.calc();

  describe('#getUsed', function() {
    var tests = [
      {
        model: Em.Object.create({
          used: 1
        }),
        e: 1,
        m: '"Used" is set'
      },
      {
        model: Em.Object.create({
          used: null
        }),
        e: 0,
        m: '"Used" is not set'
      },
      {
        model: Em.Object.create({}),
        e: 0,
        m: '"Used" is not defined'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        pieChartDashboardWidgetView.set('model', test.model);
        expect(pieChartDashboardWidgetView.getUsed()).to.equal(test.e);
      });
    });
  });

  describe('#getMax', function() {
    var tests = [
      {
        model: Em.Object.create({
          max: 1
        }),
        e: 1,
        m: '"Max" is set'
      },
      {
        model: Em.Object.create({
          max: null
        }),
        e: 0,
        m: '"Max" is not set'
      },
      {
        model: Em.Object.create({}),
        e: 0,
        m: '"Max" is not defined'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        pieChartDashboardWidgetView.set('model', test.model);
        expect(pieChartDashboardWidgetView.getMax()).to.equal(test.e);
      });
    });
  });

  describe('#calcIsPieExists', function() {
    var tests = [
      {
        model: Em.Object.create({
          max: 1
        }),
        e: true,
        m: 'Exists'
      },
      {
        model: Em.Object.create({
          max: 0
        }),
        e: false,
        m: 'Not exists'
      },
      {
        model: Em.Object.create({}),
        e: false,
        m: 'Not exists'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        pieChartDashboardWidgetView.set('model', test.model);
        expect(pieChartDashboardWidgetView.calcIsPieExists()).to.equal(test.e);
      });
    });
  });

  describe('calcDataForPieChart', function() {
    var tests = [
      {
        model: Em.Object.create({
          max: 10,
          used: 0
        }),
        e: ['0', '0.0'],
        m: 'Nothing is used'
      },
      {
        model: Em.Object.create({
          max: 10,
          used: 10
        }),
        e: ['100', '100.0'],
        m: 'All is used'
      },
      {
        model: Em.Object.create({
          max: 10,
          used: 5
        }),
        e: ['50', '50.0'],
        m: 'Half is used'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        pieChartDashboardWidgetView.set('model', test.model);
        expect(pieChartDashboardWidgetView.calcDataForPieChart()).to.eql(test.e);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/resource_manager_uptime_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/resource_manager_uptime');

describe('App.ResourceManagerUptimeView', function() {

  var tests = [
    {
      model: Em.Object.create({
        resourceManagerStartTime: ((new Date()).getTime() - 192.1*24*3600*1000)
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '192.1 d',
        data: 192.1
      }
    },
    {
      model:  Em.Object.create({
        resourceManagerStartTime: 0
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    },
    {
      model:  Em.Object.create({
        resourceManagerStartTime: null
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  tests.forEach(function(test) {
    var resourceManagerUptimeView = App.ResourceManagerUptimeView.create({model_type:null, model: test.model});
    resourceManagerUptimeView.calc();
    describe('resourceManagerStartTime - ' + test.model.resourceManagerStartTime, function() {
      it('content', function() {
        expect(resourceManagerUptimeView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(resourceManagerUptimeView.get('data')).to.equal(test.e.data);
      });
      it('isRed', function() {
        expect(resourceManagerUptimeView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(resourceManagerUptimeView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(resourceManagerUptimeView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(resourceManagerUptimeView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/tasktracker_live_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/tasktracker_live');

describe('App.TaskTrackerUpView', function() {

  var tests = [
    {
      data: 100,
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true
      }
    },
    {
      data: 0,
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false
      }
    },
    {
      data: 50,
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false
      }
    }
  ];

  tests.forEach(function(test) {
    describe('', function() {
      var taskTrackerUpView = App.TaskTrackerUpView.create({model_type:null, data: test.data, content: test.data.toString()});
      it('isRed', function() {
        expect(taskTrackerUpView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(taskTrackerUpView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(taskTrackerUpView.get('isGreen')).to.equal(test.e.isGreen);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/text_widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');

describe('App.TextDashboardWidgetView', function() {

  var tests = [
    {
      data: 100,
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false
      }
    },
    {
      data: 1,
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: false
      }
    },
    {
      data: 50,
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false,
        isNA: false
      }
    },
    {
      data: null,
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: true
      }
    }
  ];

  tests.forEach(function(test) {
    describe('data - ' + test.data + ' | thresh1 - 40 | thresh2 - 70', function() {
      var textDashboardWidgetView = App.TextDashboardWidgetView.create({thresh1:40, thresh2:70});
      textDashboardWidgetView.set('data', test.data);
      it('isRed', function() {
        expect(textDashboardWidgetView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(textDashboardWidgetView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(textDashboardWidgetView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(textDashboardWidgetView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/uptime_text_widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/uptime_text_widget');

describe('App.UptimeTextDashboardWidgetView', function() {

  describe('#timeConverter', function() {
    var timestamps = [
      {
        t: 1358245370553,
        e: {
          l: 2,
          f: 'Tue Jan 15 2013'
        }
      },
      {
        t: 0,
        e: {
          l: 2,
          f: 'Thu Jan 01 1970'
        }
      }
    ];
    timestamps.forEach(function(timestamp) {
      var uptimeTextDashboardWidgetView = App.UptimeTextDashboardWidgetView.create({thresh1:40, thresh2:70});
      it('timestamp ' + timestamp.t, function() {
        var result = uptimeTextDashboardWidgetView.timeConverter(timestamp.t);
        expect(result.length).to.equal(timestamp.e.l);
        expect(result[0]).to.equal(timestamp.e.f);
      });
    });
  });

  describe('#uptimeProcessing', function() {
    var timestamps = [
      {
        t: (new Date()).getTime() - 10*1000,
        e: {
          timeUnit: 's'
        }
      },
      {
        t: (new Date()).getTime() - 3600*1000,
        e: {
          timeUnit: 'hr'
        }
      },
      {
        t: (new Date()).getTime() - 24*3600*1000,
        e: {
          timeUnit: 'd'
        }
      },
      {
        t: (new Date()).getTime() - 1800*1000,
        e: {
          timeUnit: 'min'
        }
      }
    ];
    timestamps.forEach(function(timestamp) {
      var uptimeTextDashboardWidgetView = App.UptimeTextDashboardWidgetView.create({thresh1:40, thresh2:70});
      it('timestamp ' + timestamp.t + '. timeUnit should be ' + '"' + timestamp.e.timeUnit + '"', function() {
        var result = uptimeTextDashboardWidgetView.uptimeProcessing(timestamp.t);
        expect(uptimeTextDashboardWidgetView.get('timeUnit')).to.equal(timestamp.e.timeUnit);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('messages');
var filters = require('views/common/filter_view');
require('mixins/common/userPref');
require('mixins/common/localStorage');
require('views/main/dashboard/widgets');
var mainDashboardWidgetsView;

describe('App.MainDashboardWidgetsView', function() {

  beforeEach(function() {
    mainDashboardWidgetsView = App.MainDashboardWidgetsView.create();
  });

  describe('#setInitPrefObject', function() {
    var hdfs_widgets_count = 7;
    var mapreduce_widgets_count = 7;
    var hbase_widgets_count = 4;
    var yarn_widgets_count = 4;
    var total_widgets_count = 27;
    var tests = Em.A([
      {
        models: {
          hdfs_model: null,
          mapreduce_model: null,
          hbase_model: null,
          yarn_model: null
        },
        e: {
          visibleL: total_widgets_count - hdfs_widgets_count - mapreduce_widgets_count - hbase_widgets_count - yarn_widgets_count - 1,
          hiddenL: 0
        },
        m: 'All models are null'
      },
      {
        models: {
          hdfs_model: {},
          mapreduce_model: null,
          hbase_model: null,
          yarn_model: null
        },
        e: {
          visibleL: total_widgets_count  - mapreduce_widgets_count - hbase_widgets_count - yarn_widgets_count - 1,
          hiddenL: 0
        },
        m: 'mapreduce_model, hbase_model, yarn_model are null'
      },
      {
        models: {
          hdfs_model: {},
          mapreduce_model: {},
          hbase_model: null,
          yarn_model: null
        },
        e: {
          visibleL: total_widgets_count - hbase_widgets_count - yarn_widgets_count - 1,
          hiddenL: 0
        },
        m: 'hbase_model and yarn_model are null'
      },
      {
        models: {
          hdfs_model: {},
          mapreduce_model: {},
          hbase_model: {},
          yarn_model: null
        },
        e: {
          visibleL: total_widgets_count - yarn_widgets_count - 1,
          hiddenL: 1
        },
        m: 'yarn_model is null'
      },
      {
        models: {
          hdfs_model: {},
          mapreduce_model: {},
          hbase_model: {},
          yarn_model: {}
        },
        e: {
          visibleL: total_widgets_count - 1,
          hiddenL: 1
        },
        m: 'All models are not null'
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        mainDashboardWidgetsView.set('hdfs_model', test.models.hdfs_model);
        mainDashboardWidgetsView.set('mapreduce_model', test.models.mapreduce_model);
        mainDashboardWidgetsView.set('hbase_model', test.models.hbase_model);
        mainDashboardWidgetsView.set('yarn_model', test.models.yarn_model);
        mainDashboardWidgetsView.setInitPrefObject();
        expect(mainDashboardWidgetsView.get('initPrefObject.visible.length')).to.equal(test.e.visibleL);
        expect(mainDashboardWidgetsView.get('initPrefObject.hidden.length')).to.equal(test.e.hiddenL);
      });
    });
  });

  describe('#persistKey', function() {
    App.router.set('loginName', 'tdk');
    it('Check it', function() {
      expect(mainDashboardWidgetsView.get('persistKey')).to.equal('user-pref-tdk-dashboard');
    });
  });

});
});

;require.register("test/views/main/dashboard_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('messages');
var filters = require('views/common/filter_view');
require('views/main/dashboard');
var mainDashboardView;
describe('App.MainDashboardView', function() {

   beforeEach(function() {
     mainDashboardView = App.MainDashboardView.create();
   });

});

});

;require.register("test/views/main/host/details/host_component_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/host_component');
require('views/main/host/details/host_component_view');

var hostComponentView;

describe('App.HostComponentView', function() {

  beforeEach(function() {
    hostComponentView = App.HostComponentView.create({
      startBlinking: function(){},
      doBlinking: function(){},
      getDesiredAdminState: function(){return $.ajax({});}
    });
  });

  describe('#disabled', function() {

    var tests = Em.A([
      {
        parentView: {content: {healthClass: 'health-status-DEAD-YELLOW'}},
        e: 'disabled'
      },
      {
        parentView: {content: {healthClass: 'another-class'}},
        e: ''
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        hostComponentView = App.HostComponentView.create({
          startBlinking: function(){},
          doBlinking: function(){},
          parentView: test.parentView
        });
        expect(hostComponentView.get('disabled')).to.equal(test.e);
      });
    });

  });

  describe('#isUpgradeFailed', function() {

    var tests = ['UPGRADE_FAILED'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.set('content', {workStatus: status});
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isUpgradeFailed')).to.equal(e);
      });
    });

  });

  describe('#isInstallFailed', function() {

    var tests = ['INSTALL_FAILED'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.set('content', {workStatus: status});
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isInstallFailed')).to.equal(e);
      });
    });

  });

  describe('#isStart', function() {

    var tests = ['STARTED','STARTING'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.set('content', {workStatus: status});
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isStart')).to.equal(e);
      });
    });

  });

  describe('#isStop', function() {

    var tests = ['INSTALLED'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.set('content', {workStatus: status});
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isStop')).to.equal(e);
      });
    });

  });

  describe('#isInstalling', function() {

    var tests = ['INSTALLING'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.set('content', {workStatus: status});
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isInstalling')).to.equal(e);
      });
    });

  });

  describe('#isInit', function() {

    var tests = ['INIT'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.set('content', {workStatus: status});
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isInit')).to.equal(e);
      });
    });

  });

  describe('#noActionAvailable', function() {

    var tests = ['STARTING', 'STOPPING', 'UNKNOWN', 'DISABLED'];
    var testE = 'hidden';
    var defaultE = '';

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.set('content', {workStatus: status});
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('noActionAvailable')).to.equal(e);
      });
    });

  });

  describe('#isActive', function() {

    var tests = Em.A([
      {passiveState: 'OFF', e: true},
      {passiveState: 'ON', e: false},
      {passiveState: 'IMPLIED', e: false}
    ]);

    tests.forEach(function(test) {
      it(test.workStatus, function() {
        hostComponentView.set('content', {passiveState: test.passiveState});
        expect(hostComponentView.get('isActive')).to.equal(test.e);
      });
    });

  });

  describe('#isImplied', function() {

    var tests = Em.A([
      {
        content: {service: {passiveState: 'ON'}},
        parentView: {content: {passiveState: 'ON'}},
        m: 'service in ON, host in ON',
        e: true
      },
      {
        content: {service: {passiveState: 'ON', serviceName:'SERVICE_NAME'}},
        parentView: {content: {passiveState: 'OFF'}},
        m: 'service in ON, host in OFF',
        e: true
      },
      {
        content: {service: {passiveState: 'OFF', serviceName:'SERVICE_NAME'}},
        parentView: {content: {passiveState: 'ON'}},
        m: 'service in OFF, host in ON',
        e: true
      },
      {
        content: {service: {passiveState: 'OFF'}},
        parentView: {content: {passiveState: 'OFF'}},
        m: 'service in OFF, host in OFF',
        e: false
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        hostComponentView = App.HostComponentView.create({
          startBlinking: function(){},
          doBlinking: function(){},
          parentView: test.parentView,
          content: test.content
        });
        expect(hostComponentView.get('isImplied')).to.equal(test.e);
      });
    });

  });

  describe('#isRestartComponentDisabled', function() {

    var tests = ['STARTED'];
    var testE = false;
    var defaultE = true;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.set('content', {workStatus: status});
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isRestartComponentDisabled')).to.equal(e);
      });
    });

  });

  describe('#isDeleteComponentDisabled', function() {

    var tests = ['INSTALLED', 'UNKNOWN', 'INSTALL_FAILED', 'UPGRADE_FAILED', 'INIT'];
    var testE = false;
    var defaultE = true;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.set('content', {workStatus: status});
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isDeleteComponentDisabled')).to.equal(e);
      });
    });

  });

  describe('#componentTextStatus', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: null,
        e: 'status',
        m: 'get content status'
      },
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        e: 'new_status',
        m: 'get hostComponent status'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        hostComponentView = App.HostComponentView.create({
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          content: test.content,
          hostComponent: test.hostComponent
        });
        expect(hostComponentView.get('componentTextStatus')).to.equal(test.e);
      });
    });

  });

  describe('#workStatus', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({workStatus: 'status'}),
        hostComponent: null,
        e: 'status',
        m: 'get content workStatus'
      },
      {
        content: Em.Object.create({workStatus: 'status'}),
        hostComponent: Em.Object.create({workStatus: 'new_status'}),
        e: 'new_status',
        m: 'get hostComponent workStatus'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        hostComponentView = App.HostComponentView.create({
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          content: test.content,
          hostComponent: test.hostComponent
        });
        expect(hostComponentView.get('workStatus')).to.equal(test.e);
      });
    });

  });

  describe('#statusClass', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({workStatus: App.HostComponentStatus.install_failed,passiveState: 'OFF'}),
        e: 'health-status-color-red icon-cog'
      },
      {
        content: Em.Object.create({workStatus: App.HostComponentStatus.installing, passiveState: 'OFF'}),
        e: 'health-status-color-blue icon-cog'
      },
      {
        content: Em.Object.create({workStatus: 'STARTED', passiveState: 'ON'}),
        e: 'health-status-started'
      },
      {
        content: Em.Object.create({workStatus: 'STARTED', passiveState: 'IMPLIED'}),
        e: 'health-status-started'
      },
      {
        content: Em.Object.create({workStatus: 'STARTED', passiveState: 'OFF'}),
        e: 'health-status-started'
      }
    ]);

    tests.forEach(function(test) {
      it(test.content.get('workStatus') + ' ' + test.content.get('passiveState'), function() {
        hostComponentView = App.HostComponentView.create({
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          content: test.content
        });
        expect(hostComponentView.get('statusClass')).to.equal(test.e);
      });
    });

  });

  describe('#isInProgress', function() {

    var tests = ['STOPPING', 'STARTING'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.set('content', {workStatus: status});
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isInProgress')).to.equal(e);
      });
    });

  });

  describe('#statusIconClass', function() {
    var tests = Em.A([
      {s: 'health-status-started', e: App.healthIconClassGreen},
      {s: 'health-status-starting', e: App.healthIconClassGreen},
      {s: 'health-status-installed', e: App.healthIconClassRed},
      {s: 'health-status-stopping', e: App.healthIconClassRed},
      {s: 'health-status-unknown', e: App.healthIconClassYellow},
      {s: 'health-status-DEAD-ORANGE', e: App.healthIconClassOrange},
      {s: 'other', e: ''}
    ]);

    tests.forEach(function(test) {
      it(test.s, function() {
        hostComponentView.reopen({statusClass: test.s});
        expect(hostComponentView.get('statusIconClass')).to.equal(test.e);
      })
    });
  });

});

});

;require.register("test/views/main/host/details/host_component_views/decommissionable_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/host_component');
require('views/main/host/details/host_component_view');
require('mixins');
require('mixins/main/host/details/host_components/decommissionable');

var hostComponentView;

describe('App.Decommissionable', function() {

  beforeEach(function() {
    hostComponentView = App.HostComponentView.create(App.Decommissionable, {
      startBlinking: function(){},
      doBlinking: function(){},
      getDesiredAdminState: function(){return $.ajax({});}
    });
  });

  describe('#componentTextStatus', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: null,
        isComponentRecommissionAvailable: false,
        isComponentDecommissioning: false,
        e: 'status',
        m: 'get content status'
      },
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        isComponentRecommissionAvailable: false,
        isComponentDecommissioning: false,
        e: 'new_status',
        m: 'get hostComponent status'
      },
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        isComponentRecommissionAvailable: false,
        isComponentDecommissioning: false,
        e: 'new_status',
        m: 'get hostComponent status'
      },
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        isComponentRecommissionAvailable: true,
        isComponentDecommissioning: true,
        e: Em.I18n.t('hosts.host.decommissioning'),
        m: 'get decommissioning status'
      },
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        isComponentRecommissionAvailable: true,
        isComponentDecommissioning: false,
        e: Em.I18n.t('hosts.host.decommissioned'),
        m: 'get decommissioned status'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        hostComponentView = App.HostComponentView.create(App.Decommissionable, {
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          content: test.content,
          hostComponent: test.hostComponent,
          isComponentRecommissionAvailable: test.isComponentRecommissionAvailable,
          isComponentDecommissioning: test.isComponentDecommissioning
        });
        expect(hostComponentView.get('componentTextStatus')).to.equal(test.e);
      });
    });

  });

  describe('#statusClass', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({workStatus: App.HostComponentStatus.install_failed,passiveState: 'OFF'}),
        isComponentRecommissionAvailable: false,
        e: 'health-status-color-red icon-cog'
      },
      {
        content: Em.Object.create({workStatus: App.HostComponentStatus.installing, passiveState: 'OFF'}),
        isComponentRecommissionAvailable: false,
        e: 'health-status-color-blue icon-cog'
      },
      {
        content: Em.Object.create({workStatus: 'STARTED', passiveState: 'ON'}),
        isComponentRecommissionAvailable: false,
        e: 'health-status-started'
      },
      {
        content: Em.Object.create({workStatus: 'STARTED', passiveState: 'IMPLIED'}),
        isComponentRecommissionAvailable: false,
        e: 'health-status-started'
      },
      {
        content: Em.Object.create({workStatus: 'STARTED', passiveState: 'OFF'}),
        isComponentRecommissionAvailable: false,
        e: 'health-status-started'
      },
      {
        content: Em.Object.create({workStatus: 'STARTED', passiveState: 'OFF'}),
        isComponentRecommissionAvailable: true,
        e: 'health-status-DEAD-ORANGE'
      },
      {
        content: Em.Object.create({workStatus: 'STARTING', passiveState: 'OFF'}),
        isComponentRecommissionAvailable: true,
        e: 'health-status-DEAD-ORANGE'
      },
      {
        content: Em.Object.create({workStatus: 'INSTALLED', passiveState: 'OFF'}),
        isComponentRecommissionAvailable: true,
        e: 'health-status-DEAD-ORANGE'
      }

    ]);

    tests.forEach(function(test) {
      it(test.content.get('workStatus') + ' ' + test.content.get('passiveState') + ' ' + test.isComponentRecommissionAvailable?'true':'false', function() {
        hostComponentView = App.HostComponentView.create(App.Decommissionable,{
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          isComponentRecommissionAvailable: test.isComponentRecommissionAvailable,
          content: test.content
        });
        expect(hostComponentView.get('statusClass')).to.equal(test.e);
      });
    });

  });

  describe('#isInProgress', function() {

    var tests = Em.A([
      {
        workStatus: App.HostComponentStatus.stopping,
        isDecommissioning: false,
        e: true
      },
      {
        workStatus: App.HostComponentStatus.starting,
        isDecommissioning: false,
        e: true
      },
      {
        workStatus: 'other_status',
        isDecommissioning: false,
        e: false
      },
      {
        workStatus: 'other_status',
        isDecommissioning: true,
        e: true
      }
    ]);

    tests.forEach(function(test) {
      it(test.workStatus + ' ' + test.isDecommissioning?'true':'false', function() {

        hostComponentView = App.HostComponentView.create(App.Decommissionable,{
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          isDecommissioning: test.isDecommissioning,
          content: Em.Object.create({workStatus: test.workStatus})
        });

        expect(hostComponentView.get('isInProgress')).to.equal(test.e);
      });
    });

  });

});

});

;require.register("test/views/main/host/summary_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/host');
require('models/service');
require('models/host_component');
require('mappers/server_data_mapper');
require('views/main/host/summary');

var mainHostSummaryView;
var extendedMainHostSummaryView = App.MainHostSummaryView.extend({content: {}, addToolTip: function(){}, installedServices: []});
var modelSetup = require('test/init_model_test');

describe('App.MainHostSummaryView', function() {

  beforeEach(function() {
    modelSetup.setupStackServiceComponent();
    mainHostSummaryView = extendedMainHostSummaryView.create({});
  });

  afterEach(function(){
    modelSetup.cleanStackServiceComponent();
  });

  describe('#sortedComponents', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters, slaves and clients',
        e: ['A', 'C', 'B']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters and slaves',
        e: ['A', 'C', 'D', 'B']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters',
        e: ['B', 'A', 'C', 'D']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'A'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'D'})
          ])
        }),
        m: 'List of slaves',
        e: ['B', 'A', 'C', 'D']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([])
        }),
        m: 'Empty list',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'B'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of clients',
        e: []
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        test.content.get('hostComponents').forEach(function(component) {
          component.set('id', component.get('componentName'));
        });
        mainHostSummaryView.set('sortedComponents', []);
        mainHostSummaryView.set('content', test.content);
        mainHostSummaryView.sortedComponentsFormatter();
        expect(mainHostSummaryView.get('sortedComponents').mapProperty('componentName')).to.eql(test.e);
      });
    });

  });

  describe('#clients', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters, slaves and clients',
        e: ['D']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters and slaves',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'A'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'D'})
          ])
        }),
        m: 'List of slaves',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([])
        }),
        m: 'Empty list',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'B'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of clients',
        e: ['B', 'A', 'C', 'D']
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        mainHostSummaryView.set('content', test.content);
        expect(mainHostSummaryView.get('clients').mapProperty('componentName')).to.eql(test.e);
      });
    });

  });

  describe('#areClientWithStaleConfigs', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D', staleConfigs: true}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C', staleConfigs: false})
          ])
        }),
        m: 'Some clients with stale configs',
        e: true
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D', staleConfigs: false}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C', staleConfigs: false})
          ])
        }),
        m: 'No clients with stale configs',
        e: false
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D', staleConfigs: true}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C', staleConfigs: true})
          ])
        }),
        m: 'All clients with stale configs',
        e: true
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([])
        }),
        m: 'Empty list',
        e: false
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        mainHostSummaryView.set('content', test.content);
        expect(mainHostSummaryView.get('areClientWithStaleConfigs')).to.equal(test.e);
      });
    });

  });

  describe('#isAddComponent', function() {

    var tests = Em.A([
      {content: {healthClass: 'health-status-DEAD-YELLOW', hostComponents: Em.A([])}, e: false},
      {content: {healthClass: 'OTHER_VALUE', hostComponents: Em.A([])}, e: true}
    ]);

    tests.forEach(function(test) {
      it(test.content.healthClass, function() {
        mainHostSummaryView.set('content', test.content);
        expect(mainHostSummaryView.get('isAddComponent')).to.equal(test.e);
      });
    });

  });

  describe('#installableClientComponents', function() {

    it('delete host not supported', function() {
      App.set('supports.deleteHost', false);
      expect(mainHostSummaryView.get('installableClientComponents')).to.eql([]);
      App.set('supports.deleteHost', true);
    });

    var tests = Em.A([
      {
        content: Em.Object.create({
          hostComponents: Em.A([])
        }),
        services: ['HDFS', 'YARN', 'MAPREDUCE2'],
        e: ['HDFS_CLIENT', 'YARN_CLIENT', 'MAPREDUCE2_CLIENT'],
        m: 'no one client installed'
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({
              componentName: 'HDFS_CLIENT'
            })
          ])
        }),
        services: ['HDFS', 'YARN', 'MAPREDUCE2'],
        e: ['YARN_CLIENT', 'MAPREDUCE2_CLIENT'],
        m: 'some clients are already installed'
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({
              componentName: 'HDFS_CLIENT'
            }),
            Em.Object.create({
              componentName: 'YARN_CLIENT'
            }),
            Em.Object.create({
              componentName: 'MAPREDUCE2_CLIENT'
            })
          ])
        }),
        services: ['HDFS', 'YARN', 'MAPREDUCE2'],
        e: [],
        m: 'all clients are already installed'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        mainHostSummaryView.set('content', test.content);
        mainHostSummaryView.set('installedServices', test.services);
        expect(mainHostSummaryView.get('installableClientComponents')).to.include.members(test.e);
        expect(test.e).to.include.members(mainHostSummaryView.get('installableClientComponents'));
      });
    });

  });

  describe('#addableComponents', function() {
    var tests = Em.A([
      {
        content: Em.Object.create({
          hostComponents: Em.A([])
        }),
        services: ['HDFS', 'YARN', 'MAPREDUCE2'],
        e: ['DATANODE', 'NODEMANAGER', 'CLIENTS'],
        m: 'no components on host (impossible IRL, but should be tested)'
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({
              componentName: 'HDFS_CLIENT'
            }),
            Em.Object.create({
              componentName: 'DATANODE'
            })
          ])
        }),
        services: ['HDFS', 'YARN', 'MAPREDUCE2'],
        e: ['NODEMANAGER', 'CLIENTS'],
        m: 'some components are already installed'
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({
              componentName: 'HDFS_CLIENT'
            }),
            Em.Object.create({
              componentName: 'YARN_CLIENT'
            }),
            Em.Object.create({
              componentName: 'MAPREDUCE2_CLIENT'
            }),
            Em.Object.create({
              componentName: 'NODEMANAGER'
            })
          ])
        }),
        services: ['HDFS', 'YARN', 'MAPREDUCE2'],
        e: ['DATANODE'],
        m: 'all clients and some other components are already installed'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        mainHostSummaryView.set('content', test.content);
        mainHostSummaryView.set('installedServices', test.services);
        expect(mainHostSummaryView.get('addableComponents').mapProperty('componentName')).to.eql(test.e);
      });
    });

  });

});

});

;require.register("test/views/main/jobs/hive_job_details_tez_dag_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/jobs/hive_job_details_tez_dag_view');

describe('App.MainHiveJobDetailsTezDagView', function() {
  var tezDagView = App.MainHiveJobDetailsTezDagView.create();

  describe('#getNodeCalculatedDimensions()', function() {
    var tests = Em.A([
      {
        i: {
          node: {
            operations: [],
            duration: 100
          },
          minDuration: 1
        },
        e: {
          width : 180,
          height : 40,
          drawWidth : 180,
          drawHeight : 40,
          scale : 1
        },
        m: 'Node(ops=0,duration=100) minDuration=1'
      },
      {
        i: {
          node: {
            operations: [1,2,3,4,5],
            duration: 4
          },
          minDuration: 1
        },
        e: {
          width : 180,
          height : 80,
          drawWidth : 180,
          drawHeight : 40+40,
          scale : 1
        },
        m: 'Node(ops=5,duration=4) minDuration=1'
      },
      {
        i: {
          node: {
            operations: [1],
            duration: 1
          },
          minDuration: 1
        },
        e: {
          width : 180,
          height : 60,
          drawWidth : 180,
          drawHeight : 60,
          scale : 1
        },
        m: 'Node(ops=1,duration=1) minDuration=1'
      },
      { // Error case
        i: {
          node: {
            operations: [1],
            duration: 1
          },
          minDuration: 3
        },
        e: {
          width : 180,
          height : 60,
          drawWidth : 180,
          drawHeight : 60,
          scale : 1
        },
        m: 'Node(ops=1,duration=1) minDuration=3'
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        var nodeDim = tezDagView.getNodeCalculatedDimensions(test.i.node, test.i.minDuration);
        Em.keys(test.e).forEach(function(key) {
          expect(nodeDim[key]).to.equal(test.e[key]);
        });
      });
    });
  });

});

});

;require.register("test/views/main/jobs/hive_job_details_tez_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
module.exports = {
  _createVertex : function(row, col, state, type, numOps, inEdges, outEdges, vertexJsons) {
    var v = {
      id : 'v_' + row + '_' + col,
      instance_id : 'vi_' + row + '_' + col,
      name : 'Vertex ' + row + ', ' + col,
      state : state,
      type : type,
      operations : [],
      outgoing_edges : outEdges,
      incoming_edges : inEdges
    };
    for ( var c = 0; c < numOps; c++) {
      v.operations.push("Op " + c);
    }
    vertexJsons.push(v);
    return v;
  },

  _createEdge : function(id, type, from, to, edgeJsons) {
    var e = {
      id : id,
      instance_id : 'i_' + id,
      from_vertex_id : from.id,
      to_vertex_id : to.id,
      edge_type : type
    }
    edgeJsons.push(e);
    return e;
  },

  /**
   * Creates a Tez DAG for test purposes with 6 nodes in row 1, 1 node in row 2
   * and 5 nodes in row 3.
   *
   * Usage: <code>
   *     var testDag = jobUtils.createTezDag_6x1x5();
   *     vertices = testDag.get('vertices');
   *     edges = testDag.get('edges');
   * </code>
   */
  createTezDag_6x1x5 : function() {
    var vertices = [];
    var dagJson = {
      id : 'dag1',
      instance_id : 'dag1',
      name : 'Test DAG 1',
      stage : 'My stage',
      vertices : [],
      edges : []
    };
    var vertexJsons = [];
    var edgeJsons = [];
    // Row 1
    var v1 = this._createVertex(1, 1, "FAILED", App.TezDagVertexType.MAP, 30, [], [ 'e1' ], vertexJsons);
    var v2 = this._createVertex(1, 2, "RUNNING", App.TezDagVertexType.REDUCE, 2, [], [ 'e2' ], vertexJsons);
    var v3 = this._createVertex(1, 3, "FAILED", App.TezDagVertexType.MAP, 5, [], [ 'e3' ], vertexJsons);
    var v4 = this._createVertex(1, 4, "FAILED", App.TezDagVertexType.REDUCE, 10, [], [ 'e4' ], vertexJsons);
    var v5 = this._createVertex(1, 5, "FAILED", App.TezDagVertexType.MAP, 15, [], [ 'e5' ], vertexJsons);
    var v6 = this._createVertex(1, 6, "FAILED", App.TezDagVertexType.REDUCE, 20, [], [ 'e6' ], vertexJsons);
    // Row 2
    var v7 = this._createVertex(2, 1, "SUCCEEDED", App.TezDagVertexType.UNION, 30, [ 'e1', 'e2', 'e3', 'e4', 'e5', 'e6' ], [ 'e7', 'e8', 'e9', 'e10', 'e11' ], vertexJsons);
    // Row 3
    var v8 = this._createVertex(3, 1, "FAILED", App.TezDagVertexType.REDUCE, 30, [ 'e7' ], [], vertexJsons);
    var v9 = this._createVertex(3, 2, "RUNNING", App.TezDagVertexType.MAP, 2, [ 'e8' ], [], vertexJsons);
    var v10 = this._createVertex(3, 3, "FAILED", App.TezDagVertexType.REDUCE, 5, [ 'e9' ], [], vertexJsons);
    var v11 = this._createVertex(3, 4, "FAILED", App.TezDagVertexType.MAP, 10, [ 'e10' ], [], vertexJsons);
    var v12 = this._createVertex(3, 5, "FAILED", App.TezDagVertexType.REDUCE, 15, [ 'e11' ], [], vertexJsons);
    // Edges 1-2
    this._createEdge('e1', 'BROADCAST', v1, v7, edgeJsons);
    this._createEdge('e2', 'BROADCAST', v2, v7, edgeJsons);
    this._createEdge('e3', 'BROADCAST', v3, v7, edgeJsons);
    this._createEdge('e4', 'SCATTER_GATHER', v4, v7, edgeJsons);
    this._createEdge('e5', 'SCATTER_GATHER', v5, v7, edgeJsons);
    this._createEdge('e6', 'SCATTER_GATHER', v6, v7, edgeJsons);
    // Edges 2-3
    this._createEdge('e7', 'SCATTER_GATHER', v7, v8, edgeJsons);
    this._createEdge('e8', 'SCATTER_GATHER', v7, v9, edgeJsons);
    this._createEdge('e9', 'SCATTER_GATHER', v7, v10, edgeJsons);
    this._createEdge('e10', 'BROADCAST', v7, v11, edgeJsons);
    this._createEdge('e11', 'BROADCAST', v7, v12, edgeJsons);
    vertexJsons.forEach(function(v) {
      dagJson.vertices.push(v.id);
    })
    edgeJsons.forEach(function(e) {
      dagJson.edges.push(e.id);
    })
    App.store.load(App.TezDag, dagJson);
    App.store.loadMany(App.TezDagVertex, vertexJsons);
    App.store.loadMany(App.TezDagEdge, edgeJsons);
    return App.TezDag.find('dag1');
  },

  /**
   * Creates a Tez DAG for test purposes with 6 nodes in row 1, 1 node in row 2
   * and 5 nodes in row 3.
   *
   * Usage: <code>
   *     var testDag = jobUtils.createTezDag_7x1_1x1();
   *     vertices = testDag.get('vertices');
   *     edges = testDag.get('edges');
   * </code>
   */
  createTezDag_7x1_1x1 : function() {
    var vertices = [];
    var dagJson = {
      id : 'dag1',
      instance_id : 'dag1',
      name : 'Test DAG 1',
      stage : 'My stage',
      vertices : [],
      edges : []
    };
    var vertexJsons = [];
    var edgeJsons = [];
    // Row 1
    var v1 = this._createVertex(1, 1, "FAILED", App.TezDagVertexType.REDUCE, 30, [], [ 'e1' ], vertexJsons);
    var v4 = this._createVertex(1, 4, "FAILED", App.TezDagVertexType.MAP, 10, [], [ 'e4' ], vertexJsons);
    var v6 = this._createVertex(1, 6, "FAILED", App.TezDagVertexType.REDUCE, 20, [], [ 'e6' ], vertexJsons);
    var v2 = this._createVertex(1, 2, "RUNNING", App.TezDagVertexType.MAP, 2, [], [ 'e2' ], vertexJsons);
    var v3 = this._createVertex(1, 3, "FAILED", App.TezDagVertexType.REDUCE, 5, [], [ 'e3' ], vertexJsons);
    var v5 = this._createVertex(1, 5, "FAILED", App.TezDagVertexType.MAP, 15, [], [ 'e5' ], vertexJsons);
    var v7 = this._createVertex(1, 7, "FAILED", App.TezDagVertexType.REDUCE, 4, [], [ 'e7' ], vertexJsons);
    // Row 2
    var v8 = this._createVertex(2, 1, "SUCCEEDED", App.TezDagVertexType.MAP, 30, [ 'e1', 'e2', 'e3', 'e4' ], [ 'e8' ], vertexJsons);
    var v9 = this._createVertex(2, 2, "FAILED", App.TezDagVertexType.REDUCE, 30, [ 'e5', 'e6', 'e7' ], ['e9'], vertexJsons);
    // Row 3
    var v10 = this._createVertex(3, 1, "RUNNING", App.TezDagVertexType.UNION, 2, [ 'e8', 'e9' ], [], vertexJsons);
    // Edges 1-2
    this._createEdge('e1', 'BROADCAST', v1, v8, edgeJsons);
    this._createEdge('e2', 'BROADCAST', v2, v8, edgeJsons);
    this._createEdge('e3', 'BROADCAST', v3, v8, edgeJsons);
    this._createEdge('e4', 'SCATTER_GATHER', v4, v8, edgeJsons);
    this._createEdge('e5', 'SCATTER_GATHER', v5, v9, edgeJsons);
    this._createEdge('e6', 'SCATTER_GATHER', v6, v9, edgeJsons);
    this._createEdge('e7', 'SCATTER_GATHER', v7, v9, edgeJsons);
    // Edges 2-3
    this._createEdge('e8', 'SCATTER_GATHER', v8, v10, edgeJsons);
    this._createEdge('e9', 'SCATTER_GATHER', v9, v10, edgeJsons);
    vertexJsons.forEach(function(v) {
      dagJson.vertices.push(v.id);
    })
    edgeJsons.forEach(function(e) {
      dagJson.edges.push(e.id);
    })
    App.store.load(App.TezDag, dagJson);
    App.store.loadMany(App.TezDagVertex, vertexJsons);
    App.store.loadMany(App.TezDagEdge, edgeJsons);
    return App.TezDag.find('dag1');
  },

  /**
   * Creates a Tez DAG for test purposes. Each row in the graph is fully
   * connected to the next row. The number of nodes in each row is passed as
   * input.
   *
   * Usage:
   * <code>
   *  var testDag = jobUtils._test_createTezDag_fullyConnected([10,3,8]);
   *  vertices = testDag.get('vertices');
   *  edges = testDag.get('edges');
   * </code>
   */
  createTezDag_fullyConnected : function(rowCounts) {
    var vertices = [];
    var dagJson = {
      id : 'dag1',
      instance_id : 'dag1',
      name : 'Test DAG 1',
      stage : 'My stage',
      vertices : [],
      edges : []
    };
    var vertexJsons = [];
    var edgeJsons = [];
    var matrix = new Array(rowCounts.length);
    for ( var r = 0; r < rowCounts.length; r++) {
      matrix[r] = new Array(rowCounts[r]);
      for ( var c = 0; c < rowCounts[r]; c++) {
        var outs = [];
        var ins = [];
        if (r < rowCounts.length - 1) {
          for ( var c2 = 0; c2 < rowCounts[r + 1]; c2++) {
            outs.push('e_' + r + c + '_' + (r + 1) + c2);
          }
        }
        if (r > 0) {
          for ( var c2 = 0; c2 < rowCounts[r - 1]; c2++) {
            ins.push('e_' + (r - 1) + c2 + '_' + r + c);
          }
        }
        matrix[r][c] = this._createVertex(r, c, "RUNNING", true, (r + 1) * (c + 1), ins, outs, vertexJsons);
        if (r > 0) {
          for ( var c2 = 0; c2 < rowCounts[r - 1]; c2++) {
            this._createEdge('e_' + (r - 1) + c2 + '_' + r + c, 'BROADCAST', matrix[r - 1][c2], matrix[r][c], edgeJsons);
          }
        }
      }
    }
    vertexJsons.forEach(function(v) {
      dagJson.vertices.push(v.id);
    })
    edgeJsons.forEach(function(e) {
      dagJson.edges.push(e.id);
    })
    App.store.load(App.TezDag, dagJson);
    App.store.loadMany(App.TezDagVertex, vertexJsons);
    App.store.loadMany(App.TezDagEdge, edgeJsons);
    return App.TezDag.find('dag1');
  }
}

});

;require.register("test/views/main/jobs/hive_job_details_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/jobs/hive_job_details_view');

describe('App.MainHiveJobDetailsView', function () {
  var mainHiveJobDetailsView = App.MainHiveJobDetailsView.create({
    controller: App.MainHiveJobDetailsController.create({
      content: Ember.Object.create({
        id: 'id',
        queryText: 'show tables',
        stages: [{
          id: 'Stage-0',
          description: '. Fetch Operator'
        }, {
          id: 'Stage-1',
          description: '. Tez'
        }],
        name: 'id',
        startTime: 1394569191001,
        endTime: null,
        tezDagId: 'id:1',
        tezDag: {
          id: 'id:1',
          instanceId: 'dag_1394502141829_0425_1',
          name: 'id:1',
          yarnApplicationId: 'application_1395263571423_0014',
          stage: 'Stage-1',
          vertices: [
            Ember.Object.create({
              id: 'id:1/Map 1',
              name: 'Map 1',
              type: 'MAP',
              operations: ['TableScan', 'Filter Operator', 'Reduce Output Operator'],
              operationPlan: '[\n  {\n    "TableScan": {\n      "filterExpr:": "((hd_dep_count = 4) or (hd_vehicle_count = 3)) (type: boolean)",\n      "alias:": "household_demographics",\n      "children": {\n        "Filter Operator": {\n          "predicate:": "((hd_dep_count = 4) or (hd_vehicle_count = 3)) (type: boolean)",\n          "children": {\n            "Reduce Output Operator": {\n              "Map-reduce partition columns:": "hd_demo_sk (type: int)",\n              "sort order:": "+",\n              "value expressions:": "hd_demo_sk (type: int), hd_dep_count (type: int), hd_vehicle_count (type: int)",\n              "Statistics:": "Num rows: 7200 Data size: 770400 Basic stats: COMPLETE Column stats: NONE",\n              "key expressions:": "hd_demo_sk (type: int)"\n            }\n          },\n          "Statistics:": "Num rows: 7200 Data size: 770400 Basic stats: COMPLETE Column stats: NONE"\n        }\n      },\n      "Statistics:": "Num rows: 7200 Data size: 770400 Basic stats: COMPLETE Column stats: NONE"\n    }\n  }\n]'
            }), Ember.Object.create({
              id: 'id:1/Map 2',
              name: 'Map 2',
              state: 'KILLED',
              type: 'MAP',
              startTime: 1394569231819,
              endTime: 1394569303554,
              operations: ['TableScan', 'Map Join Operator', 'Map Join Operator', 'Map Join Operator', 'Map Join Operator', 'Filter Operator', 'Select Operator', 'Group By Operator', 'Reduce Output Operator'],
              operationPlan: '[\n  {\n    "TableScan": {\n      "alias:": "store_sales",\n      "children": {\n        "Map Join Operator": {\n          "keys:": {\n            "0": "ss_sold_date_sk (type: int)",\n            "1": "d_date_sk (type: int)"\n          },\n          "outputColumnNames:": [\n            "_col0",\n            "_col3",\n            "_col5",\n            "_col6",\n            "_col8",\n            "_col18",\n            "_col21",\n            "_col22",\n            "_col25",\n            "_col31",\n            "_col32"\n          ],\n          "children": {\n            "Map Join Operator": {\n              "keys:": {\n                "0": "UDFToDouble(_col22) (type: double)",\n                "1": "UDFToDouble(s_store_sk) (type: double)"\n              },\n              "outputColumnNames:": [\n                "_col0",\n                "_col3",\n                "_col5",\n                "_col6",\n                "_col8",\n                "_col18",\n                "_col21",\n                "_col22",\n                "_col25",\n                "_col31",\n                "_col32",\n                "_col55",\n                "_col77"\n              ],\n              "children": {\n                "Map Join Operator": {\n                  "keys:": {\n                    "0": "_col5 (type: int)",\n                    "1": "hd_demo_sk (type: int)"\n                  },\n                  "outputColumnNames:": [\n                    "_col0",\n                    "_col22",\n                    "_col31",\n                    "_col34",\n                    "_col36",\n                    "_col37",\n                    "_col39",\n                    "_col49",\n                    "_col52",\n                    "_col53",\n                    "_col56",\n                    "_col62",\n                    "_col63",\n                    "_col86",\n                    "_col89",\n                    "_col90"\n                  ],\n                  "children": {\n                    "Map Join Operator": {\n                      "keys:": {\n                        "0": "_col37 (type: int)",\n                        "1": "ca_address_sk (type: int)"\n                      },\n                      "outputColumnNames:": [\n                        "_col0",\n                        "_col3",\n                        "_col4",\n                        "_col7",\n                        "_col29",\n                        "_col38",\n                        "_col41",\n                        "_col43",\n                        "_col44",\n                        "_col46",\n                        "_col56",\n                        "_col59",\n                        "_col60",\n                        "_col63",\n                        "_col69",\n                        "_col70",\n                        "_col93",\n                        "_col99"\n                      ],\n                      "children": {\n                        "Filter Operator": {\n                          "predicate:": "((((((((_col38 = _col63) and (_col60 = _col7)) and (_col43 = _col0)) and (_col44 = _col93)) and ((_col3 = 4) or (_col4 = 3))) and (_col70) IN (6, 0)) and (_col69) IN (1999, (1999 + 1), (1999 + 2))) and (_col29) IN (\'Fairview\', \'Fairview\', \'Fairview\', \'Midway\', \'Fairview\')) (type: boolean)",\n                          "children": {\n                            "Select Operator": {\n                              "expressions:": "_col46 (type: int), _col41 (type: int), _col44 (type: int), _col99 (type: string), _col56 (type: decimal(7,2)), _col59 (type: decimal(7,2))",\n                              "outputColumnNames:": [\n                                "_col46",\n                                "_col41",\n                                "_col44",\n                                "_col99",\n                                "_col56",\n                                "_col59"\n                              ],\n                              "children": {\n                                "Group By Operator": {\n                                  "mode:": "hash",\n                                  "aggregations:": [\n                                    "sum(_col56)",\n                                    "sum(_col59)"\n                                  ],\n                                  "keys:": "_col46 (type: int), _col41 (type: int), _col44 (type: int), _col99 (type: string)",\n                                  "outputColumnNames:": [\n                                    "_col0",\n                                    "_col1",\n                                    "_col2",\n                                    "_col3",\n                                    "_col4",\n                                    "_col5"\n                                  ],\n                                  "children": {\n                                    "Reduce Output Operator": {\n                                      "Map-reduce partition columns:": "_col0 (type: int), _col1 (type: int), _col2 (type: int), _col3 (type: string)",\n                                      "sort order:": "++++",\n                                      "value expressions:": "_col4 (type: decimal(17,2)), _col5 (type: decimal(17,2))",\n                                      "Statistics:": "Num rows: 32946 Data size: 43551613 Basic stats: COMPLETE Column stats: NONE",\n                                      "key expressions:": "_col0 (type: int), _col1 (type: int), _col2 (type: int), _col3 (type: string)"\n                                    }\n                                  },\n                                  "Statistics:": "Num rows: 32946 Data size: 43551613 Basic stats: COMPLETE Column stats: NONE"\n                                }\n                              },\n                              "Statistics:": "Num rows: 32946 Data size: 43551613 Basic stats: COMPLETE Column stats: NONE"\n                            }\n                          },\n                          "Statistics:": "Num rows: 32946 Data size: 43551613 Basic stats: COMPLETE Column stats: NONE"\n                        }\n                      },\n                      "Statistics:": "Num rows: 4217199 Data size: 5574753280 Basic stats: COMPLETE Column stats: NONE",\n                      "condition map:": [\n                        {\n                          "": "Inner Join 0 to 1"\n                        }\n                      ],\n                      "condition expressions:": {\n                        "0": "{_col86} {_col89} {_col90} {_col0} {_col22} {_col31} {_col34} {_col36} {_col37} {_col39} {_col49} {_col52} {_col53} {_col56} {_col62} {_col63}",\n                        "1": "{ca_address_sk} {ca_city}"\n                      }\n                    }\n                  },\n                  "Statistics:": "Num rows: 3833817 Data size: 5067957248 Basic stats: COMPLETE Column stats: NONE",\n                  "condition map:": [\n                    {\n                      "": "Inner Join 0 to 1"\n                    }\n                  ],\n                  "condition expressions:": {\n                    "0": "{_col55} {_col77} {_col0} {_col3} {_col5} {_col6} {_col8} {_col18} {_col21} {_col22} {_col25} {_col31} {_col32}",\n                    "1": "{hd_demo_sk} {hd_dep_count} {hd_vehicle_count}"\n                  }\n                }\n              },\n              "Statistics:": "Num rows: 3485288 Data size: 4607233536 Basic stats: COMPLETE Column stats: NONE",\n              "condition map:": [\n                {\n                  "": "Inner Join 0 to 1"\n                }\n              ],\n              "condition expressions:": {\n                "0": "{_col0} {_col3} {_col5} {_col6} {_col8} {_col18} {_col21} {_col22} {_col25} {_col31} {_col32}",\n                "1": "{s_store_sk} {s_city}"\n              }\n            }\n          },\n          "Statistics:": "Num rows: 3168444 Data size: 4188394240 Basic stats: COMPLETE Column stats: NONE",\n          "condition map:": [\n            {\n              "": "Inner Join 0 to 1"\n            }\n          ],\n          "condition expressions:": {\n            "0": "{ss_sold_date_sk} {ss_customer_sk} {ss_hdemo_sk} {ss_addr_sk} {ss_ticket_number} {ss_coupon_amt} {ss_net_profit} {ss_store_sk}",\n            "1": "{d_date_sk} {d_year} {d_dow}"\n          }\n        }\n      },\n      "Statistics:": "Num rows: 2880404 Data size: 3807631184 Basic stats: COMPLETE Column stats: NONE"\n    }\n  }\n]',
              tasksCount: 6,
              fileReadBytes: 0,
              fileWriteBytes: 337559,
              fileReadOps: 0,
              fileWriteOps: 0,
              spilledRecords: 7194,
              hdfsReadBytes: 12854749,
              hdfsWriteBytes: 0,
              hdfsReadOps: 12,
              hdfsWriteOps: 0
            })
          ]
        }
      })
    })
  });
  describe('#zoomStep', function () {
    it('should be calculated according to difference between zoomScaleTo and zoomScaleFrom', function () {
      mainHiveJobDetailsView.set('zoomScaleFrom', 0);
      mainHiveJobDetailsView.set('zoomScaleTo', 1);
      expect(mainHiveJobDetailsView.get('zoomStep')).to.equal(0.2);
      mainHiveJobDetailsView.set('zoomScaleFrom', 2);
      expect(mainHiveJobDetailsView.get('zoomStep')).to.equal(0.01);
    });
  });
  describe('#canGraphZoomIn', function () {
    it('should be calculated according to comparison between zoomScale and zoomScaleTo', function () {
      mainHiveJobDetailsView.set('zoomScale', 2);
      expect(mainHiveJobDetailsView.get('canGraphZoomIn')).to.equal(false);
      mainHiveJobDetailsView.set('zoomScaleTo', 3);
      expect(mainHiveJobDetailsView.get('canGraphZoomIn')).to.equal(true);
    });
  });
  describe('#canGraphZoomOut', function () {
    it('should be calculated according to comparison between zoomScale and zoomScaleFrom', function () {
      mainHiveJobDetailsView.set('zoomScale', 3);
      expect(mainHiveJobDetailsView.get('canGraphZoomOut')).to.equal(true);
      mainHiveJobDetailsView.set('zoomScaleFrom', 4);
      expect(mainHiveJobDetailsView.get('canGraphZoomOut')).to.equal(false);
    });
  });
  describe('#doGraphZoomIn', function () {
    it('should be calculated according to zoomScale, zoomScaleTo and zoomScaleFrom', function () {
      mainHiveJobDetailsView.set('zoomScale', 0);
      mainHiveJobDetailsView.set('zoomScaleTo', 1);
      mainHiveJobDetailsView.set('zoomScaleFrom', 0);
      mainHiveJobDetailsView.doGraphZoomIn();
      expect(mainHiveJobDetailsView.get('zoomScale')).to.equal(0.2);
      mainHiveJobDetailsView.set('zoomScale', 0);
      mainHiveJobDetailsView.set('zoomScaleTo', 10);
      mainHiveJobDetailsView.set('zoomScaleFrom', 0);
      mainHiveJobDetailsView.doGraphZoomIn();
      expect(mainHiveJobDetailsView.get('zoomScale')).to.equal(2);
    });
  });
  describe('#doGraphZoomOut', function () {
    it('should be calculated according to zoomScale, zoomScaleTo and zoomScaleFrom', function () {
      mainHiveJobDetailsView.set('zoomScale', 3);
      mainHiveJobDetailsView.set('zoomScaleTo', 2);
      mainHiveJobDetailsView.set('zoomScaleFrom', 1);
      mainHiveJobDetailsView.doGraphZoomOut();
      expect(mainHiveJobDetailsView.get('zoomScale')).to.equal(2.8);
      mainHiveJobDetailsView.set('zoomScale', 1);
      mainHiveJobDetailsView.set('zoomScaleTo', 10);
      mainHiveJobDetailsView.set('zoomScaleFrom', 0);
      mainHiveJobDetailsView.doGraphZoomOut();
      expect(mainHiveJobDetailsView.get('zoomScale')).to.equal(0);
    });
  });
  describe('#toggleShowQueryText', function () {
    it('should be toggled according to showQuery', function () {
      mainHiveJobDetailsView.set('showQuery', true);
      expect(mainHiveJobDetailsView.get('toggleShowQueryText')).to.equal(Em.I18n.t('jobs.hive.less'));
      mainHiveJobDetailsView.toggleProperty('showQuery');
      expect(mainHiveJobDetailsView.get('toggleShowQueryText')).to.equal(Em.I18n.t('jobs.hive.more'));
    });
  });
  describe('#summaryMetricTypeDisplay', function () {
    it('should return the correct message for output', function () {
      mainHiveJobDetailsView.set('summaryMetricType', 'output');
      expect(mainHiveJobDetailsView.get('summaryMetricTypeDisplay')).to.equal(Em.I18n.t('jobs.hive.tez.metric.output'));
    });
  });
  describe('#initialDataLoaded', function () {
    it('controller.content should be loaded to view.content', function () {
      mainHiveJobDetailsView.set('controller.loaded', true);
      expect(mainHiveJobDetailsView.get('content.id')).to.equal(mainHiveJobDetailsView.get('controller.content.id'));
    });
  });
  describe('#jobObserver', function () {
    it('should set selection of the first vertex as default', function () {
      expect(mainHiveJobDetailsView.get('selectedVertex.id')).to.equal(mainHiveJobDetailsView.get('controller.content.tezDag.vertices').objectAt(0).get('id'));
    });
  });
});

});

;require.register("test/views/main/jobs_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/jobs_view');

describe('App.MainJobsView', function () {
  var mainJobsView = App.MainJobsView.create({
    controller: Ember.Object.create({
      filterObject: Ember.Object.create(),
      navIDs: Ember.Object.create({
        backIDs: ['id0', 'id1'],
        nextID: 'id2'
      }),
      content: [
        Ember.Object.create({
          id: 'id',
          query_text: 'show tables',
          name: 'id',
          user: ['user'],
          failed: false,
          startTime: 1393443850756,
          endTime: 1393443875265,
          tezDagId: 'id:1',
          hasTezDag: true
        })
      ]
    })
  });
  mainJobsView.get('controller').set('sortedContent', mainJobsView.controller.get('content').toArray());
  var jobNameView = mainJobsView.jobNameView.create();
  jobNameView.set('job', mainJobsView.get('controller.content').objectAt(0));
  describe('#noDataToShow', function () {
    it('should be false if content is not empty', function () {
      mainJobsView.noDataToShowObserver();
      expect(mainJobsView.get('noDataToShow')).to.equal(false);
    });
  });
  describe('#rowsPerPageSelectView.disabled', function() {
    it('should be true if controller.navIDs.backIDs.length > 1', function () {
      var rowsPerPageSelectView = mainJobsView.rowsPerPageSelectView.create({
        parentView: Ember.View.create({
          hasBackLinks: true
        })
      });
      rowsPerPageSelectView.disabledObserver();
      expect(rowsPerPageSelectView.get('disabled')).to.equal(true);
    });
  });
  describe('#hasNextJobs', function () {
    it('should be true if controller.navIDs.nextID is not empty', function () {
      expect(mainJobsView.get('hasNextJobs')).to.equal(true);
    });
  });
  describe('#hasBackLinks', function () {
    it('should be true if there are several controller.navIDs.backIDs', function () {
      expect(mainJobsView.get('hasBackLinks')).to.equal(true);
    });
  });
  describe('#jobsPaginationLeft.class', function () {
    it('should be paginate_next if there are new jobs and no filter is applied', function () {
      mainJobsView.get('controller.filterObject').set('isAnyFilterApplied', false);
      var jobsPaginationLeft = mainJobsView.jobsPaginationLeft.create({
        parentView: Ember.View.create({
          hasBackLinks: true
        })
      });
      expect(jobsPaginationLeft.get('class')).to.equal('paginate_previous');
    });
  });
  describe('#jobsPaginationRight.class', function () {
    it('should be paginate_next if there are new jobs and no filter is applied', function () {
      var jobsPaginationRight = mainJobsView.jobsPaginationRight.create({
        parentView: Ember.View.create({
          hasNextJobs: true
        })
      });
      expect(jobsPaginationRight.get('class')).to.equal('paginate_next');
    });
  });
  describe('#jobNameView.isLink', function () {
    it('should be empty if job has Tez DAG', function () {
      jobNameView.isLinkObserver();
      expect(jobNameView.get('isLink')).to.equal('');
    });
  });
});

});

;require.register("test/views/main/mirroring/edit_dataset_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/mirroring/edit_dataset_controller');
require('models/target_cluster');
require('views/main/mirroring/edit_dataset_view');

var mainMirroringEditDataSetView;
describe('App.MainMirroringEditDataSetView', function () {

  beforeEach(function () {
    mainMirroringEditDataSetView = App.MainMirroringEditDataSetView.create({
      controller: App.MainMirroringEditDataSetController.create(),
      isLoaded: true
    });
  });

  describe('targetClusterSelect.content', function () {
    var targetClusterSelect;
    beforeEach(function () {
      targetClusterSelect = mainMirroringEditDataSetView.get('targetClusterSelect').create({
        parentView: mainMirroringEditDataSetView
      });
    });

    it('should be empty if data is not loaded', function () {
      targetClusterSelect.set('parentView.isLoaded', false);
      expect(targetClusterSelect.get('content')).to.be.empty;
    });
    it('should contain list of clusters if data is loaded', function () {
      targetClusterSelect.set('parentView.isLoaded', true);
      targetClusterSelect.set('parentView.targetClusters', [
        {name: 'test1'},
        {name: 'test2'},
        {name: App.get('clusterName')}
      ]);
      expect(targetClusterSelect.get('content')).to.eql([
        'test1',
        'test2',
        Em.I18n.t('mirroring.dataset.addTargetCluster')
      ]);
    });
  });

  describe('targetClusterSelect.change', function () {
    var targetClusterSelect;
    beforeEach(function () {
      targetClusterSelect = mainMirroringEditDataSetView.get('targetClusterSelect').create({
        parentView: mainMirroringEditDataSetView,
        content: ['test1', 'test2', 'test3']
      });
      sinon.stub(targetClusterSelect.parentView, 'manageClusters', Em.K);
    });

    afterEach(function () {
      targetClusterSelect.parentView.manageClusters.restore();
    });

    it('should open manage cluster popup if appropriate option was selected', function () {
      targetClusterSelect.set('selection', Em.I18n.t('mirroring.dataset.addTargetCluster'));
      targetClusterSelect.change();
      expect(targetClusterSelect.get('selection')).to.equal('test1');
      expect(targetClusterSelect.parentView.manageClusters.calledOnce).to.be.true;
      expect(targetClusterSelect.get('parentView.controller.formFields.datasetTargetClusterName')).to.equal('test1');
    });
    it('should not open manage cluster popup if appropriate option was not selected', function () {
      targetClusterSelect.set('selection', 'test3');
      targetClusterSelect.change();
      expect(targetClusterSelect.get('selection')).to.equal('test3');
      expect(targetClusterSelect.parentView.manageClusters.calledOnce).to.be.false;
      expect(targetClusterSelect.get('parentView.controller.formFields.datasetTargetClusterName')).to.equal('test3');
    });
  });

  describe('onTargetClustersChange', function () {

    var testCases = [
      {
        isLoaded: true,
        targetClusters: [1, 2, 3],
        targetClusterName: 'test',
        hasTargetClusters: true
      },
      {
        isLoaded: false,
        targetClusters: [1, 2, 3],
        targetClusterName: null,
        hasTargetClusters: false
      },
      {
        isLoaded: true,
        targetClusters: [1],
        targetClusterName: null,
        hasTargetClusters: false
      }
    ];

    testCases.forEach(function (test) {
      it('should set hasTargetClusters property depending on cluster list', function () {
        mainMirroringEditDataSetView.set('isLoaded', test.isLoaded);
        mainMirroringEditDataSetView.set('targetClusters', test.targetClusters);
        mainMirroringEditDataSetView.set('controller.formFields.datasetTargetClusterName', 'test');
        mainMirroringEditDataSetView.onTargetClustersChange();
        expect(mainMirroringEditDataSetView.get('hasTargetClusters')).to.equal(test.hasTargetClusters);
        expect(mainMirroringEditDataSetView.get('controller.formFields.datasetTargetClusterName')).to.equal(test.targetClusterName);
      });
    });
  });

  describe('fillForm', function () {

    App.store.loadMany(App.Dataset, [
      {
        id: 'test1',
        name: 'test1',
        target_cluster_name: 'testCluster1',
        source_dir: '/testDir1',
        target_dir: '/testDir1',
        frequency: '5',
        frequency_unit: 'days',
        schedule_start_date: new Date('11/29/2014 01:00 AM').toISOString().replace(/\:\d{2}\.\d{3}/, ''),
        schedule_end_date: new Date('11/29/2014 02:00 AM').toISOString().replace(/\:\d{2}\.\d{3}/, '')
      },
      {
        id: 'test2',
        name: 'test2',
        target_cluster_name: 'testCluster2',
        source_dir: '/testDir2',
        target_dir: '/testDir2',
        frequency: '10',
        frequency_unit: 'hours',
        schedule_start_date: new Date('11/20/2014 01:00 AM').toISOString().replace(/\:\d{2}\.\d{3}/, ''),
        schedule_end_date: new Date('11/21/2014 02:00 PM').toISOString().replace(/\:\d{2}\.\d{3}/, '')
      },
      {
        id: 'test3',
        name: 'test3',
        target_cluster_name: 'testCluster3',
        source_dir: '/testDir3',
        target_dir: '/testDir3',
        frequency: '1',
        frequency_unit: 'minutes',
        schedule_start_date: new Date('10/29/2014 01:00 AM').toISOString().replace(/\:\d{2}\.\d{3}/, ''),
        schedule_end_date: new Date('11/29/2015 02:00 AM').toISOString().replace(/\:\d{2}\.\d{3}/, '')
      }
    ]);

    var testCases = [
      {
        datasetName: 'test1',
        datasetSourceDir: '/testDir1',
        datasetTargetDir: '/testDir1',
        datasetTargetClusterName: 'testCluster1',
        datasetFrequency: '5',
        repeatOptionSelected: 'days',
        datasetStartDate: '11/29/14',
        datasetEndDate: '11/29/14',
        hoursForStart: '01',
        hoursForEnd: '02',
        minutesForStart: '00',
        minutesForEnd: '00',
        middayPeriodForStart: 'AM',
        middayPeriodForEnd: 'AM'
      },
      {
        datasetName: 'test2',
        datasetSourceDir: '/testDir2',
        datasetTargetDir: '/testDir2',
        datasetTargetClusterName: 'testCluster2',
        datasetFrequency: '10',
        repeatOptionSelected: 'hours',
        datasetStartDate: '11/20/14',
        datasetEndDate: '11/21/14',
        hoursForStart: '01',
        hoursForEnd: '02',
        minutesForStart: '00',
        minutesForEnd: '00',
        middayPeriodForStart: 'AM',
        middayPeriodForEnd: 'PM'
      },
      {
        datasetName: 'test3',
        datasetSourceDir: '/testDir3',
        datasetTargetDir: '/testDir3',
        datasetTargetClusterName: 'testCluster3',
        datasetFrequency: '1',
        repeatOptionSelected: 'minutes',
        datasetStartDate: '10/29/14',
        datasetEndDate: '11/29/15',
        hoursForStart: '01',
        hoursForEnd: '02',
        minutesForStart: '00',
        minutesForEnd: '00',
        middayPeriodForStart: 'AM',
        middayPeriodForEnd: 'AM'
      }
    ];

    it('should not set form fields if isLoaded is false', function () {
      mainMirroringEditDataSetView.set('isLoaded', false);
      mainMirroringEditDataSetView.fillForm();
      Em.keys(mainMirroringEditDataSetView.get('controller.formFields')).forEach(function (field) {
        expect(mainMirroringEditDataSetView.get('controller.formFields.' + field)).to.be.null;
      });
    });

    it('should not set form fields if controller.isEdit is false', function () {
      mainMirroringEditDataSetView.set('controller.isEdit', false);
      mainMirroringEditDataSetView.fillForm();
      Em.keys(mainMirroringEditDataSetView.get('controller.formFields')).forEach(function (field) {
        expect(mainMirroringEditDataSetView.get('controller.formFields.' + field)).to.be.null;
      });
    });

    testCases.forEach(function (test) {
      it('set appropriate form fields from dataset model', function () {
        mainMirroringEditDataSetView.set('controller.datasetIdToEdit', test.datasetName);
        mainMirroringEditDataSetView.set('controller.isEdit', true);
        mainMirroringEditDataSetView.fillForm();
        Em.keys(mainMirroringEditDataSetView.get('controller.formFields')).forEach(function (field) {
          expect(mainMirroringEditDataSetView.get('controller.formFields.' + field)).to.equal(test[field]);
        });
      });
    });
  });
});

});

;require.register("test/views/main/service/info/config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/service/info/configs');

describe('App.MainServiceInfoConfigsView', function() {

  var view = App.MainServiceInfoConfigsView.create({
    controller: Em.Object.create()
  });

  describe('#updateComponentInformation', function() {

    var testCases = [
      {
        title: 'if components absent then counters should be 0',
        content: {
          restartRequiredHostsAndComponents: {}
        },
        result: {
          componentsCount: 0,
          hostsCount: 0
        }
      },
      {
        title: 'if host doesn\'t have components then hostsCount should be 1 and componentsCount should be 0',
        content: {
          restartRequiredHostsAndComponents: {
            host1: []
          }
        },
        result: {
          componentsCount: 0,
          hostsCount: 1
        }
      },
      {
        title: 'if host has 1 component then hostsCount should be 1 and componentsCount should be 1',
        content: {
          restartRequiredHostsAndComponents: {
            host1: [{}]
          }
        },
        result: {
          componentsCount: 1,
          hostsCount: 1
        }
      }
    ];
    testCases.forEach(function(test) {
      it(test.title, function() {
        view.set('controller.content', test.content);
        view.updateComponentInformation();
        expect(view.get('componentsCount')).to.equal(test.result.componentsCount);
        expect(view.get('hostsCount')).to.equal(test.result.hostsCount);
      });
    });
  });
});

});

;require.register("test/views/main/service/info/summary_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/service/info/summary');

describe('App.MainServiceInfoSummaryView', function() {

  var mainServiceInfoSummaryView = App.MainServiceInfoSummaryView.create({
    monitorsLiveTextView: Em.View.create(),
    controller: Em.Object.create({
      content: Em.Object.create({
        id: 'HDFS',
        serviceName: 'HDFS',
        hostComponents: []
      })
    })
  });

  describe('#servers', function () {
    it('services shuldn\'t have servers except FLUME and ZOOKEEPER', function () {
      expect(mainServiceInfoSummaryView.get('servers')).to.be.empty;
    });

    it('if one server exists then first server should have isComma and isAnd property false', function () {
      mainServiceInfoSummaryView.set('controller.content', Em.Object.create({
        id: 'ZOOKEEPER',
        serviceName: 'ZOOKEEPER',
        hostComponents: [
          Em.Object.create({
            displayName: '',
            isMaster: true
          })
        ]
      }));
      expect(mainServiceInfoSummaryView.get('servers').objectAt(0).isComma).to.equal(false);
      expect(mainServiceInfoSummaryView.get('servers').objectAt(0).isAnd).to.equal(false);
    });

    it('if more than one servers exist then first server should have isComma - true and isAnd - false', function () {
      mainServiceInfoSummaryView.set('controller.content', Em.Object.create({
        id: 'ZOOKEEPER',
        serviceName: 'ZOOKEEPER',
        hostComponents: [
          Em.Object.create({
            displayName: '',
            isMaster: true
          }),
          Em.Object.create({
            displayName: '',
            isMaster: true
          })
        ]
      }));
      expect(mainServiceInfoSummaryView.get('servers').objectAt(0).isComma).to.equal(true);
      expect(mainServiceInfoSummaryView.get('servers').objectAt(0).isAnd).to.equal(false);
      expect(mainServiceInfoSummaryView.get('servers').objectAt(1).isComma).to.equal(false);
      expect(mainServiceInfoSummaryView.get('servers').objectAt(1).isAnd).to.equal(false);
    });

    it('if more than two servers exist then second server should have isComma - false and isAnd - true', function () {
      mainServiceInfoSummaryView.set('controller.content', Em.Object.create({
        id: 'ZOOKEEPER',
        serviceName: 'ZOOKEEPER',
        hostComponents: [
          Em.Object.create({
            displayName: '',
            isMaster: true
          }),
          Em.Object.create({
            displayName: '',
            isMaster: true
          }),
          Em.Object.create({
            displayName: '',
            isMaster: true
          })
        ]
      }));
      expect(mainServiceInfoSummaryView.get('servers').objectAt(0).isComma).to.equal(true);
      expect(mainServiceInfoSummaryView.get('servers').objectAt(0).isAnd).to.equal(false);
      expect(mainServiceInfoSummaryView.get('servers').objectAt(1).isComma).to.equal(false);
      expect(mainServiceInfoSummaryView.get('servers').objectAt(1).isAnd).to.equal(true);
      expect(mainServiceInfoSummaryView.get('servers').objectAt(2).isComma).to.equal(false);
      expect(mainServiceInfoSummaryView.get('servers').objectAt(2).isAnd).to.equal(false);
    });

  });
});

});

;require.register("test/views/wizard/controls_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/controls_view');
require('utils/ajax/ajax');
require('router');

describe('views/wizard/control_views', function() {
  describe('App.CheckDBConnectionView', function() {
    var createView = function(serviceName) {
      return App.CheckDBConnectionView.extend({
        parentView: Em.View.create({
          service: Em.Object.create({
            serviceName: serviceName
          }),
          categoryConfigsAll: function() {
            return Em.A(
              require('data/HDP2/global_properties').configProperties.concat(require('data/HDP2/site_properties').configProperties)
                .filterProperty('serviceName', serviceName).map(function(property) { return App.ServiceConfigProperty.create(property)})
            );
          }.property()
        })
      });
    };
    var generateTypeValueProp = function(type, value) {
      return {
        type: type,
        value: value
      }
    };
    var prepareConfigsTesting = function() {
      var view = createView('HIVE').create({ databaseName: 'MySQL'});
      var setConfigProperty = function(name, value) {
        view.get('parentView.categoryConfigsAll').findProperty('name', name).set('value', value);
      };

      setConfigProperty('javax.jdo.option.ConnectionUserName', 'hive_user');
      setConfigProperty('javax.jdo.option.ConnectionPassword', 'hive_pass');
      setConfigProperty('ambari.hive.db.schema.name', 'hive_scheme');
      setConfigProperty('javax.jdo.option.ConnectionURL', 'hive_c_url');
      return view;
    }
    describe('`Oozie` properties checking', function() {
      var view = createView('OOZIE').create();
      describe('#requiredProperties', function() {
        var expectedProperties = ['oozie.db.schema.name','oozie.service.JPAService.jdbc.username','oozie.service.JPAService.jdbc.password','oozie.service.JPAService.jdbc.driver','oozie.service.JPAService.jdbc.url'];
        it('required properties present {0}'.format(expectedProperties.join(',')), function() {
          expect(view.get('requiredProperties')).to.have.members(expectedProperties);
        });
      });
      describe('#hostNameProperty', function() {
        var testMessage = 'property name should be `{0}`';
        var tests = [
          {
            databaseName: 'MySQL',
            e: 'oozie_existing_mysql_host'
          },
          {
            databaseName: 'PostgreSQL',
            e: 'oozie_existing_postgresql_host'
          },
          {
            databaseName: 'Oracle',
            e: 'oozie_existing_oracle_host'
          }
        ];
        tests.forEach(function(test) {
          it(testMessage.format(test.e), function() {
            view.set('databaseName', test.databaseName);
            expect(view.get('hostNameProperty')).to.eql(test.e);
          });
        });
      });
    });

    describe('`Hive` properties checking', function() {
      var view = createView('HIVE').create();
      describe('#requiredProperties', function() {
        var expectedProperties = ['ambari.hive.db.schema.name','javax.jdo.option.ConnectionUserName','javax.jdo.option.ConnectionPassword','javax.jdo.option.ConnectionDriverName','javax.jdo.option.ConnectionURL'];
        it('required properties present {0}'.format(expectedProperties.join(',')), function() {
          expect(view.get('requiredProperties')).to.have.members(expectedProperties);
        });
      });
      describe('#hostNameProperty', function() {
        var testMessage = 'property name should be `{0}`';
        var tests = [
          {
            databaseName: 'MySQL',
            e: 'hive_existing_mysql_host'
          },
          {
            databaseName: 'PostgreSQL',
            e: 'hive_existing_postgresql_host'
          },
          {
            databaseName: 'Oracle',
            e: 'hive_existing_oracle_host'
          }
        ];
        tests.forEach(function(test) {
          it(testMessage.format(test.e), function() {
            view.set('databaseName', test.databaseName);
            expect(view.get('hostNameProperty')).to.eql(test.e);
          });
        }, this);
      });
      describe('#connectionProperties', function() {
        var view = prepareConfigsTesting();
        var tests = [
          generateTypeValueProp('user_name', 'hive_user'),
          generateTypeValueProp('user_passwd', 'hive_pass'),
          generateTypeValueProp('db_connection_url', 'hive_c_url')
        ];
        var testMessage = 'property `{0}` should have `{1}`';
        tests.forEach(function(test) {
          it(testMessage.format(test.value, test.type), function() {
            expect(view.get('connectionProperties')[test.type]).to.eql(test.value);
          });
        });
      });

      describe('#preparedDBProperties', function() {
        var view = prepareConfigsTesting();
        var tests = [
          generateTypeValueProp('javax.jdo.option.ConnectionUserName', 'hive_user'),
          generateTypeValueProp('javax.jdo.option.ConnectionPassword', 'hive_pass'),
          generateTypeValueProp('javax.jdo.option.ConnectionURL', 'hive_c_url')
        ];
        var testMessage = 'property `{1}` should have `{0}`';
        tests.forEach(function(test) {
          it(testMessage.format(test.value, test.type), function() {
            expect(view.get('preparedDBProperties')[test.type]).to.eql(test.value);
          });
        });
      });


    });

    describe('#isBtnDisabled', function() {
      var view = createView('HIVE').create({ databaseName: 'MySQL' });
      var testMessage = 'button should be {0} if `isValidationPassed`/`isConnecting`: {1}/{2}';
      var tests = [
        {
          isValidationPassed: true,
          isConnecting: true,
          e: true
        },
        {
          isValidationPassed: true,
          isConnecting: false,
          e: false
        }
      ];
      tests.forEach(function(test) {
        it(testMessage.format(!!test.e ? 'disabled' : 'enabled', test.isValidationPassed, test.isConnecting), function() {
          view.set('isValidationPassed', test.isValidationPassed);
          view.set('isConnecting', test.isConnecting);
          expect(view.get('isBtnDisabled')).to.be.eql(test.e);
        });
      })
    });

    describe('#connectToDatabase()', function() {
      before(function() {
        sinon.spy(App.ajax, 'send');
      });
      describe('connection request validation', function() {
        var view = createView('HIVE').create({ databaseName: 'MySQL'});
        var setConfigProperty = function(name, value) {
          view.get('parentView.categoryConfigsAll').findProperty('name', name).set('value', value);
        };

        setConfigProperty('javax.jdo.option.ConnectionUserName', 'hive_user');
        setConfigProperty('javax.jdo.option.ConnectionPassword', 'hive_pass');
        setConfigProperty('ambari.hive.db.schema.name', 'hive_scheme');
        setConfigProperty('javax.jdo.option.ConnectionURL', 'hive_c_url');

        it('request should be passed with correct params', function() {
          view.connectToDatabase();
          expect(App.ajax.send.calledOnce).to.be.ok;
        })
      });
      after(function() {
        App.ajax.send.restore();
      })
    });

  });

  describe('App.ServiceConfigRadioButtons', function() {
    var createView = function(serviceName) {
      return App.ServiceConfigRadioButtons.extend({
        categoryConfigsAll: function() {
          return Em.A(
            require('data/HDP2/global_properties').configProperties.concat(require('data/HDP2/site_properties').configProperties)
              .filterProperty('serviceName', serviceName).map(function(property) { return App.ServiceConfigProperty.create(property)})
          );
        }.property()
      });
    };

    var setProperties = function(properties, propertyMap) {
      for (var propertyName in propertyMap) {
        properties.findProperty('name', propertyName).set('value', propertyMap[propertyName]);
      }
    };

    before(function() {
      App.clusterStatus.set('wizardControllerName','installerController');
    });
    describe('#onOptionsChange()', function() {
      var oozieDerby =  {
        serviceConfig: { value: 'New Derby Database' },
        setupProperties: {
          'oozie.db.schema.name': 'derby.oozie.schema',
          'oozie.service.JPAService.jdbc.driver': 'oozie.driver',
          'oozie_ambari_host': 'derby.host.com'
        },
        expectedProperties: [
          {
            path: 'databaseName',
            value: 'derby.oozie.schema'
          },
          {
            path: 'dbClass.name',
            value: 'oozie.service.JPAService.jdbc.driver'
          },
          {
            path: 'dbClass.value',
            value: 'org.apache.derby.jdbc.EmbeddedDriver'
          },
          {
            path: 'hostName',
            value: 'derby.host.com'
          },
          {
            path: 'connectionUrl.name',
            value: 'oozie.service.JPAService.jdbc.url'
          },
          {
            path: 'connectionUrl.value',
            value: 'jdbc:derby:${oozie.data.dir}/${oozie.db.schema.name}-db;create=true'
          }
        ]
      };
      var oozieExistingMysql = {
        serviceConfig: { value: 'Existing MySQL Database' },
        setupProperties: {
          'oozie.db.schema.name': 'mysql.oozie.schema',
          'oozie.service.JPAService.jdbc.driver': 'oozie.driver',
          'oozie_existing_mysql_host': 'mysql.host.com'
        },
        expectedProperties: [
          {
            path: 'databaseName',
            value: 'mysql.oozie.schema'
          },
          {
            path: 'dbClass.name',
            value: 'oozie.service.JPAService.jdbc.driver'
          },
          {
            path: 'dbClass.value',
            value: 'com.mysql.jdbc.Driver'
          },
          {
            path: 'hostName',
            value: 'mysql.host.com'
          },
          {
            path: 'connectionUrl.name',
            value: 'oozie.service.JPAService.jdbc.url'
          },
          {
            path: 'connectionUrl.value',
            value: 'jdbc:mysql://mysql.host.com/mysql.oozie.schema'
          }
        ]
      };
      var oozieExistingPostgresql = {
        serviceConfig: { value: 'Existing PostgreSQL Database' },
        setupProperties: {
          'oozie.db.schema.name': 'postgresql.oozie.schema',
          'oozie.service.JPAService.jdbc.driver': 'oozie.driver',
          'oozie_existing_postgresql_host': 'postgresql.host.com'
        },
        expectedProperties: [
          {
            path: 'databaseName',
            value: 'postgresql.oozie.schema'
          },
          {
            path: 'dbClass.name',
            value: 'oozie.service.JPAService.jdbc.driver'
          },
          {
            path: 'dbClass.value',
            value: 'org.postgresql.Driver'
          },
          {
            path: 'hostName',
            value: 'postgresql.host.com'
          },
          {
            path: 'connectionUrl.name',
            value: 'oozie.service.JPAService.jdbc.url'
          },
          {
            path: 'connectionUrl.value',
            value: 'jdbc:postgresql://postgresql.host.com:5432/postgresql.oozie.schema'
          }
        ]
      };
      var oozieExistingOracle = {
        serviceConfig: { value: 'Existing Oracle Database' },
        setupProperties: {
          'oozie.db.schema.name': 'oracle.oozie.schema',
          'oozie.service.JPAService.jdbc.driver': 'oozie.driver',
          'oozie_existing_oracle_host': 'oracle.host.com'
        },
        expectedProperties: [
          {
            path: 'databaseName',
            value: 'oracle.oozie.schema'
          },
          {
            path: 'dbClass.name',
            value: 'oozie.service.JPAService.jdbc.driver'
          },
          {
            path: 'dbClass.value',
            value: 'oracle.jdbc.driver.OracleDriver'
          },
          {
            path: 'hostName',
            value: 'oracle.host.com'
          },
          {
            path: 'connectionUrl.name',
            value: 'oozie.service.JPAService.jdbc.url'
          },
          {
            path: 'connectionUrl.value',
            value: 'jdbc:oracle:thin:@//oracle.host.com:1521/oracle.oozie.schema'
          }
        ]
      };
      var tests = [
        {
          serviceName: 'OOZIE',
          mockData: [
            oozieDerby,
            oozieExistingMysql,
            oozieExistingPostgresql,
            oozieExistingOracle
          ]
        }
      ];
      tests.forEach(function(test) {
        describe('`{0}` service processing'.format(test.serviceName), function() {
          test.mockData.forEach(function(test) {
            describe('`oozie_database` value "{0}"'.format(test.serviceConfig.value), function() {
              var view = createView('OOZIE').create();
              before(function() {
                var categoryConfigs = view.get('categoryConfigsAll');
                view.reopen({
                  serviceConfig: function() {
                    var property = categoryConfigs.findProperty('name', 'oozie_database');
                    property.set('value', test.serviceConfig.value);
                    return property;
                  }.property()
                });
                setProperties(categoryConfigs, test.setupProperties);
                view.didInsertElement();
              })
              test.expectedProperties.forEach(function(property) {
                it('#{0} should be "{1}"'.format(property.path, property.value), function() {
                  expect(view.get(property.path)).to.eql(property.value);
                });
              });
            });
          });
        })
      });
    });
  });
});

});

;require.register("test/views/wizard/step0_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step0_view');

var view, controller = Em.Object.create({
  clusterNameError: '',
  loadStep: Em.K
});

describe('App.WizardStep0View', function () {

  beforeEach(function () {
    view = App.WizardStep0View.create({'controller': controller});
  });

  describe('#onError', function () {
    it('should be true if clusterNameError appears', function () {
      controller.set('clusterNameError', 'ERROR');
      expect(view.get('onError')).to.equal(true);
    });
    it('should be false if clusterNameError doesn\'t appears', function () {
      controller.set('clusterNameError', '');
      expect(view.get('onError')).to.equal(false);
    });
  });

  describe('#didInsertElement', function () {
    beforeEach(function () {
      sinon.stub(App, 'popover', Em.K);
      sinon.spy(view.get('controller'), 'loadStep');
    });
    afterEach(function () {
      App.popover.restore();
      view.get('controller').loadStep.restore();
    });
    it('should call loadStep', function () {
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
    });
    it('should create popover', function () {
      view.didInsertElement();
      expect(App.popover.calledOnce).to.equal(true);
    });
  });

});

describe('App.WizardStep0ViewClusterNameInput', function () {

  beforeEach(function() {
    view = App.WizardStep0ViewClusterNameInput.create({
      parentView: Em.Object.create({
        controller: Em.Object.create({
          submit: Em.K
        })
      })
    });
  });

  describe('#keyPress', function() {
    it('should return true if pressed not Enter', function() {
      expect(view.keyPress({keyCode: 1})).to.equal(true);
    });
    it('should submit form if Enter pressed', function() {
      sinon.spy(view.get('parentView.controller'), 'submit');
      expect(view.keyPress({keyCode: 13})).to.equal(false);
      expect(view.get('parentView.controller').submit.calledOnce).to.equal(true);
      view.get('parentView.controller').submit.restore();
    });
  });

});
});

;require.register("test/views/wizard/step10_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step10_view');
var view;
describe('App.WizardStep10View', function() {
  beforeEach(function() {
    view = App.WizardStep10View.create({
      controller: App.WizardStep10Controller.create()
    });
  });
  describe('didInsertElement', function() {
    it('should call loadStep', function() {
      sinon.stub(view.get('controller'), 'loadStep', Em.K);
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
      view.get('controller').loadStep.restore();
    });
  });
});

});

;require.register("test/views/wizard/step1_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step1_view');

var view;

var controller = Em.Object.create({
  content: {
    stacks: []
  }
});

describe('App.WizardStep1View', function () {

  beforeEach(function () {
    view = App.WizardStep1View.create({'controller': controller});
    view.set('$', function () {
      return Em.Object.create({hide: Em.K, toggle: Em.K});
    });
  });

  describe('#allRepositoriesGroups', function () {

    var controller = Em.Object.create({
      content: {
        stacks: [
          {
            operatingSystems: [
              {
                osType: 'redhat5',
                selected: true
              },
              {
                osType: 'redhat5',
                selected: true
              },
              {
                osType: 'redhat6',
                selected: false
              }
            ],
            isSelected: true
          }
        ]
      }
    });

    var allRepositories = [
      Ember.Object.create({osType: 'redhat5', 'empty-error': true}),
      Ember.Object.create({osType: 'redhat5', 'empty-error': true}),
      Ember.Object.create({osType: 'redhat6', 'empty-error': true})
    ];

    it('should create repo groups from repo list', function () {
      view.reopen({
        controller: controller
      });
      view.set('allRepositories', allRepositories);
      expect(view.get('allRepositoriesGroups.length')).to.equal(2);
      expect(view.get('allRepositoriesGroups')[0].get('name')).to.equal('redhat5');
      expect(view.get('allRepositoriesGroups')[1].get('name')).to.equal('redhat6');
      expect(view.get('allRepositoriesGroups')[0].get('checked')).to.be.true;
      expect(view.get('allRepositoriesGroups')[1].get('checked')).to.be.false;
      expect(view.get('allRepositoriesGroups')[0].get('repositories')).to.eql([allRepositories[0], allRepositories[1]]);
      expect(view.get('allRepositoriesGroups')[1].get('repositories')).to.eql([allRepositories[2]]);
    });

    it('should create empty array if there is no stacks', function () {
      view.reopen({
        controller: controller
      });
      view.set('controller.content.stacks', []);
      view.set('allRepositories', allRepositories);
      expect(view.get('allRepositoriesGroups.length')).to.equal(0);
    });
  });

  describe('#emptyRepoExist', function () {

    var tests = Em.A([
      {
        allRepositories: [
          {'empty-error': false},
          {'empty-error': false},
          {'empty-error': false}
        ],
        e: false
      },
      {
        allRepositories: [
          {'empty-error': true},
          {'empty-error': false},
          {'empty-error': false}
        ],
        e: true
      },
      {
        allRepositories: [
          {'empty-error': true},
          {'empty-error': true},
          {'empty-error': true}
        ],
        e: true
      }
    ]);

    tests.forEach(function (test) {
      it(test.allRepositories.mapProperty('empty-error').join(', '), function () {
        view.set('allRepositories', test.allRepositories);
        expect(view.get('emptyRepoExist')).to.equal(test.e);
      });
    });
  });

  describe('#allRepoUnchecked', function () {

    var tests = Em.A([
      {
        allRepositoriesGroups: [
          {'checked': false},
          {'checked': false},
          {'checked': false}
        ],
        e: true
      },
      {
        allRepositoriesGroups: [
          {'checked': true},
          {'checked': false},
          {'checked': false}
        ],
        e: false
      },
      {
        allRepositoriesGroups: [
          {'checked': true},
          {'checked': true},
          {'checked': true}
        ],
        e: false
      }
    ]);

    tests.forEach(function (test) {
      it(test.allRepositoriesGroups.mapProperty('checked').join(', '), function () {
        view.reopen({
          allRepositoriesGroups: test.allRepositoriesGroups
        });
        expect(view.get('allRepoUnchecked')).to.equal(test.e);
      });
    });

  });

  describe('#stacks', function () {

    var tests = Em.A([
      {
        m: 'Stack with 2 HDP',
        stacks: [
          Em.Object.create({isSelected: true, name: 'HDP-2.0.1'}),
          Em.Object.create({isSelected: false, name: 'HDP-1.3.3'})
        ],
        e: {
          names: ['HDP 2.0.1', 'HDP 1.3.3'],
          selected: [true, false]
        }
      },
      {
        m: 'No HDP',
        stacks: [],
        e: {
          names: [],
          selected: []
        }
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        view.set('controller.content.stacks', test.stacks);
        var stacks = view.get('stacks');
        expect(stacks.mapProperty('name')).to.eql(test.e.names);
        expect(stacks.mapProperty('isSelected')).to.eql(test.e.selected);
      });
    });

  });

  describe('#isSubmitDisabled', function () {

    var tests = Em.A([
      {
        emptyRepoExist: false,
        allRepoUnchecked: false,
        invalidUrlExist: false,
        e: false
      },
      {
        emptyRepoExist: true,
        allRepoUnchecked: false,
        invalidUrlExist: false,
        e: true
      },
      {
        emptyRepoExist: false,
        allRepoUnchecked: true,
        invalidUrlExist: false,
        e: true
      },
      {
        emptyRepoExist: false,
        allRepoUnchecked: false,
        invalidUrlExist: true,
        e: true
      },
      {
        emptyRepoExist: true,
        allRepoUnchecked: false,
        invalidUrlExist: true,
        e: true
      },
      {
        emptyRepoExist: true,
        allRepoUnchecked: true,
        invalidUrlExist: false,
        e: true
      },
      {
        emptyRepoExist: false,
        allRepoUnchecked: true,
        invalidUrlExist: true,
        e: true
      },
      {
        emptyRepoExist: true,
        allRepoUnchecked: true,
        invalidUrlExist: true,
        e: true
      }
    ]);

    tests.forEach(function (test) {
      it(test.emptyRepoExist.toString() + ' ' + test.allRepoUnchecked.toString() + ' ' + test.invalidUrlExist.toString(), function () {
        view = App.WizardStep1View.create();
        view.reopen({
          emptyRepoExist: test.emptyRepoExist,
          allRepoUnchecked: test.allRepoUnchecked,
          invalidUrlExist: test.invalidUrlExist
        });
        expect(view.get('isSubmitDisabled')).to.equal(test.e);
      });
    });

  });

  describe('#invalidUrlExist', function () {
    var tests = Em.A([
      {
        stacks: [Em.Object.create({isSelected: true, invalidCnt: 1})],
        allRepositories: [Em.Object.create({validation: 'icon-exclamation-sign'})],
        m: 'invalidCnt: 1, validation: icon-exclamation-sign',
        e: true
      },
      {
        stacks: [Em.Object.create({isSelected: true, invalidCnt: 1})],
        allRepositories: [Em.Object.create({validation: ''})],
        m: 'invalidCnt: 1, validation: ""',
        e: false
      },
      {
        stacks: [Em.Object.create({isSelected: true, invalidCnt: 0})],
        allRepositories: [Em.Object.create({validation: ''})],
        m: 'invalidCnt: 0, validation: ""',
        e: false
      },
      {
        stacks: [Em.Object.create({isSelected: true, invalidCnt: 0})],
        allRepositories: [Em.Object.create({validation: 'icon-exclamation-sign'})],
        m: 'invalidCnt: 0, validation: icon-exclamation-sign',
        e: false
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        view.reopen({
          allRepositoriesGroups: null
        });
        view.set('controller.content.stacks', test.stacks);
        view.set('allRepositories', test.allRepositories);
        expect(view.get('invalidUrlExist')).to.equal(test.e);
      });
    });
  });

  describe('#totalErrorCnt', function () {
    var tests = Em.A([
      {
        allRepositories: [
          {}
        ],
        m: 'allRepoUnchecked',
        allRepoUnchecked: true,
        e: 1
      },
      {
        allRepositories: [
          {'empty-error': true},
          {'empty-error': true}
        ],
        allRepoUnchecked: false,
        m: 'two with empty-error',
        e: 2
      },
      {
        allRepositories: [
          {'validation': 'icon-exclamation-sign'},
          {'validation': 'icon-exclamation-sign'}
        ],
        allRepoUnchecked: false,
        m: 'two with validation="icon-exclamation-sign"',
        e: 2
      },
      {
        allRepositories: [
          {'empty-error': true, 'validation': 'icon-exclamation-sign'},
          {'empty-error': true, 'validation': 'icon-exclamation-sign'}
        ],
        allRepoUnchecked: false,
        m: 'two with empty-error, two with validation="icon-exclamation-sign"',
        e: 4
      },
      {
        allRepositories: [
          {}
        ],
        allRepoUnchecked: false,
        m: 'no errors/warnings etc',
        e: 0
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        view.reopen({
          allRepositoriesGroups: null,
          allRepoUnchecked: test.allRepoUnchecked
        });
        view.set('allRepositories', test.allRepositories);
        expect(view.get('totalErrorCnt')).to.equal(test.e);
      });
    });
  });

  describe('#didInsertElement', function () {
    it('should create tooltip', function () {
      sinon.stub($.fn, 'tooltip', Em.K);
      view.set('isRLCollapsed', false);
      view.didInsertElement();
      expect($.fn.tooltip.calledOnce).to.equal(true);
      $.fn.tooltip.restore();
    });
  });

  describe('#stackRadioButton', function () {

    var v;
    beforeEach(function () {
      v = view.get('stackRadioButton').create({
        content: Em.Object.create({
          name: ''
        }),
        controller: Em.Object.create({
          content: Em.Object.create({
            stacks: []
          })
        })
      });
    });

    describe('#checked', function () {
      it('should be equal content.isSelected', function () {
        v.set('content.isSelected', true);
        expect(v.get('checked')).to.equal(true);
        v.set('content.isSelected', false);
        expect(v.get('checked')).to.equal(false);
      });
    });

    describe('#click', function () {
      it('should select proper stack', function () {
        v.set('controller.content.stacks', Em.A([Em.Object.create({name: 'n-1'}), Em.Object.create({name: 'n-2'}), Em.Object.create({name: 'n-3'})]));
        v.set('content.name', 'n 2');
        v.click();
        expect(v.get('controller.content.stacks').getEach('isSelected')).to.eql([false, true, false]);
      });
    });

  });

  describe('#popoverView', function () {

    var v;
    beforeEach(function () {
      v = view.get('popoverView').create();
      sinon.stub(App, 'popover', Em.K);
    });

    afterEach(function () {
      App.popover.restore();
    });

    describe('#didInsertElement', function () {
      it('should create popover', function () {
        v.didInsertElement();
        expect(App.popover.calledOnce).to.equal(true);
      });
    });

  });

  describe('#onToggleBlock', function () {
    it('should toggle isRLCollapsed', function () {
      view.set('isRLCollapsed', true);
      view.onToggleBlock();
      expect(view.get('isRLCollapsed')).to.equal(false);
      view.onToggleBlock();
      expect(view.get('isRLCollapsed')).to.equal(true);
    });
  });

  describe('#updateByCheckbox', function () {

    var allRepositories = [
      Em.Object.create({
        id: 'id',
        osType: 'redhat5',
        baseUrl: 'baseUrl',
        latestBaseUrl: 'latestBaseUrl',
        validation: '',
        selected: ''
      })
    ];

    var allRepositoriesGroups = [
      Em.Object.create({
        name: 'redhat5',
        checked: false,
        repositories: [Em.Object.create({
          id: 'id',
          osType: 'redhat5',
          baseUrl: 'baseUrl',
          latestBaseUrl: 'latestBaseUrl',
          validation: '',
          selected: ''
        })
        ]
      })
    ];

    var controller = {
      content: {
        stacks: [
          {
            isSelected: true,
            operatingSystems: [
              {
                id: 'id',
                osType: 'redhat5',
                baseUrl: 'baseUrl',
                latestBaseUrl: 'latestBaseUrl',
                validation: '',
                selected: false
              }
            ]
          }
        ]
      }
    };

    it('target group isn\'t checked', function () {
      view.reopen({
        allRepositories: allRepositories,
        allRepositoriesGroups: allRepositoriesGroups,
        controller: controller
      });
      view.updateByCheckbox();
      var os = view.get('controller.content.stacks')[0].operatingSystems[0],
          targetGroup = view.get('allRepositories.firstObject');
      expect(os.baseUrl).to.equal(os.latestBaseUrl);
      expect(os.selected).to.equal(false);
      expect(os.validation).to.be.null;
      expect(targetGroup.get('baseUrl')).to.equal('latestBaseUrl');
      expect(targetGroup.get('latestBaseUrl')).to.equal('latestBaseUrl');
      expect(targetGroup.get('undo')).to.equal(false);
      expect(targetGroup.get('invalid-error')).to.equal(false);
      expect(targetGroup.get('clearAll')).to.equal(false);
      expect(targetGroup.get('empty-error')).to.equal(false);
      expect(targetGroup.get('validation')).to.be.null;
    });

    it('target group is checked, skipValidationChecked = true', function () {
      controller.content.stacks[0].operatingSystems[0].selected = true;
      allRepositoriesGroups[0].set('checked', true);
      view.reopen({
        allRepositories: allRepositories,
        allRepositoriesGroups: allRepositoriesGroups,
        controller: controller,
        skipValidationChecked: true
      });
      view.updateByCheckbox();
      var os = view.get('controller.content.stacks')[0].operatingSystems[0],
          targetGroup = view.get('allRepositories.firstObject');
      expect(os.selected).to.equal(true);
      expect(os.skipValidation).to.equal(true);
      expect(targetGroup.get('invalid-error')).to.equal(false);
      expect(targetGroup.get('empty-error')).to.equal(false);
      expect(targetGroup.get('clearAll')).to.equal('latestBaseUrl');
      expect(targetGroup.get('validation')).to.be.null;
    });
  });

  describe('#clearGroupLocalRepository', function () {
    it('should be proxy for doActionForGroupLocalRepository', function () {
      sinon.stub(view, 'doActionForGroupLocalRepository', Em.K);
      view.clearGroupLocalRepository({});
      expect(view.doActionForGroupLocalRepository.calledWith({}, '')).to.equal(true);
      view.doActionForGroupLocalRepository.restore();
    });
  });

  describe('#undoGroupLocalRepository', function () {
    it('should be proxy for doActionForGroupLocalRepository', function () {
      sinon.stub(view, 'doActionForGroupLocalRepository', Em.K);
      view.undoGroupLocalRepository({});
      expect(view.doActionForGroupLocalRepository.calledWith({}, 'latestBaseUrl')).to.equal(true);
      view.doActionForGroupLocalRepository.restore();
    });
  });

  describe('#doActionForGroupLocalRepository', function () {

    beforeEach(function () {
      sinon.stub(view, 'loadRepositories', Em.K);
    });

    afterEach(function () {
      view.loadRepositories.restore();
    });

    it('should update OS in selected stack', function () {
      var event = {context: Em.Object.create({'group-number': 0})};
      view.reopen({
        allRepositories: [
          Em.Object.create({
            'group-number': 0,
            checked: false
          })
        ],
        controller: {
          content: {
            stacks: [
              {
                isSelected: true,
                operatingSystems: [
                  {
                    osType: 'redhat5',
                    baseUrl: 'baseUrl',
                    latestBaseUrl: 'latestBaseUrl',
                    validation: '',
                    selected: ''
                  }
                ]
              }
            ]
          }
        }
      });
      view.doActionForGroupLocalRepository(event, '');
      var os = view.get('controller.content.stacks')[0].operatingSystems[0];
      expect(os.baseUrl).to.equal('');
      expect(os.validation).to.be.null;
      expect(view.loadRepositories.calledOnce).to.equal(true);
    });

    it('should update OS in selected stack (2)', function () {
      var event = {context: Em.Object.create({'group-number': 0})};
      view.reopen({
        allRepositories: [
          Em.Object.create({
            'group-number': 0,
            checked: false
          })
        ],
        controller: {
          content: {
            stacks: [
              {
                isSelected: true,
                operatingSystems: [
                  {
                    osType: 'redhat5',
                    baseUrl: 'baseUrl',
                    latestBaseUrl: 'latestBaseUrl',
                    validation: '',
                    selected: ''
                  }
                ]
              }
            ]
          }
        }
      });
      view.doActionForGroupLocalRepository(event, 'latestBaseUrl');
      var os = view.get('controller.content.stacks')[0].operatingSystems[0];
      expect(os.baseUrl).to.equal('latestBaseUrl');
      expect(os.validation).to.be.null;
      expect(view.loadRepositories.calledOnce).to.equal(true);
    });

  });

  describe('#editLocalRepository', function () {

    it('should update os and group', function () {
      view.reopen({
        allRepositories: [
          Em.Object.create({
            'group-number': 0,
            checked: false,
            baseUrl: 'b1'
          })
        ],
        controller: {
          content: {
            stacks: [
              {
                isSelected: true,
                operatingSystems: [
                  {
                    osType: 'redhat5',
                    baseUrl: 'baseUrl',
                    latestBaseUrl: 'latestBaseUrl',
                    validation: '',
                    selected: ''
                  }
                ]
              }
            ]
          }
        }
      });
      view.editLocalRepository();
      var os = view.get('controller.content.stacks')[0].operatingSystems[0],
          targetGroup = view.get('allRepositories.firstObject');
      expect(os.baseUrl).to.equal(targetGroup.get('baseUrl'));
      expect(os.validation).to.be.null;


      expect(targetGroup.get('undo')).to.equal(true);
      expect(targetGroup.get('invalid-error')).to.equal(false);
      expect(targetGroup.get('empty-error')).to.equal(false);
      expect(targetGroup.get('validation')).to.be.null;
    });

  });

  describe('#loadRepositories', function () {
    beforeEach(function () {
      sinon.stub(view, 'updateByCheckbox', Em.K);
      sinon.stub(view, 'editLocalRepository', Em.K);
    });
    afterEach(function () {
      view.updateByCheckbox.restore();
      view.editLocalRepository.restore();
    });
    it('Should create repository object from controller content stack data', function () {
      controller = {
        content: {
          stacks: [
            {
              isSelected: true,
              operatingSystems: [
                {
                  'id': 'test',
                  'repoId': 'HDP',
                  'baseUrl': 'http://test1',
                  'osType': 'RedHat',
                  'latestBaseUrl': 'http://test1',
                  'defaultBaseUrl': 'http://test3',
                  'validation': 'icon-exclamation-sign',
                  'errorTitle': 'test',
                  'errorContent': 'test'
                }
              ]
            }
          ]
        }
      };
      result = Ember.Object.create({
        'id': 'test',
        'repoId': 'HDP',
        'baseUrl': 'http://test1',
        'osType': 'RedHat',
        'latestBaseUrl': 'http://test1',
        'defaultBaseUrl': 'http://test3',
        'empty-error': false,
        'invalid-error': true,
        'validation': 'icon-exclamation-sign',
        'undo': false,
        'clearAll': 'http://test1',
        'errorTitle': 'test',
        'errorContent': 'test'
      });
      view.reopen({
        controller: controller
      });
      view.loadRepositories();
      var allRepositories = view.get('allRepositories');
      Em.keys(allRepositories).forEach(function (key) {
        expect(allRepositories[0].get(key)).to.equal(result.get(key));
      });
    });
  });

});

});

;require.register("test/views/wizard/step2_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step2_view');

var view, controller = Em.Object.create({
  clusterNameError: ''
});

describe('App.WizardStep0View', function () {

  beforeEach(function() {
    view = App.WizardStep2View.create({'controller': controller});
  });

  describe('#sshKeyState', function() {
    it('should be equal to controller.content.installOptions.manualInstall', function() {
      controller.set('content', {installOptions: {manualInstall: false}});
      expect(view.get('sshKeyState')).to.equal(false);
      controller.toggleProperty('content.installOptions.manualInstall');
      expect(view.get('sshKeyState')).to.equal(true);
    });
  });

  describe('#didInsertElement', function() {
    beforeEach(function () {
      sinon.stub(App, 'popover', Em.K);
      view.set('controller.hostsError', 'some text');
      view.set('controller.sshKeyError', 'some text');
    });
    afterEach(function () {
      App.popover.restore();
    });
    it('should clean hostsError', function () {
      view.didInsertElement();
      expect(view.get('controller.hostsError')).to.be.null;
    });
    it('should clean sshKeyError', function () {
      view.didInsertElement();
      expect(view.get('controller.sshKeyError')).to.be.null;
    });
    it('should create popover', function () {
      view.didInsertElement();
      expect(App.popover.calledOnce).to.equal(true);
    });
  });

  describe('#providingSSHKeyRadioButton', function() {
    var v;

    beforeEach(function() {
      v = view.get('providingSSHKeyRadioButton').create({
        controller: Em.Object.create({
          content: {
            installOptions: {
              useSsh: true,
              manualInstall: true
            }
          }
        })
      });
    });

    describe('#checked', function() {
      it('should be equal to controller.content.installOptions.useSsh', function () {
        v.set('controller.content.installOptions.useSsh', false);
        expect(v.get('checked')).to.equal(false);
        v.set('controller.content.installOptions.useSsh', true);
        expect(v.get('checked')).to.equal(true);
      });
    });

    describe('#click', function() {
      it('should update controller.content.installOptions.useSsh', function () {
        v.set('controller.content.installOptions.useSsh', false);
        v.click();
        expect(v.get('controller.content.installOptions.useSsh')).to.equal(true);
      });
      it('should update controller.content.installOptions.manualInstall', function () {
        v.set('controller.content.installOptions.manualInstall', true);
        v.click();
        expect(v.get('controller.content.installOptions.manualInstall')).to.equal(false);
      });
    });

  });

  describe('#manualRegistrationRadioButton', function() {
    var v;

    beforeEach(function() {
      v = view.get('manualRegistrationRadioButton').create({
        controller: Em.Object.create({
          content: {
            installOptions: {
              useSsh: true,
              manualInstall: true
            }
          }
        })
      });
    });

    describe('#checked', function() {
      it('should be equal to controller.content.installOptions.manualInstall', function () {
        v.set('controller.content.installOptions.manualInstall', false);
        expect(v.get('checked')).to.equal(false);
        v.set('controller.content.installOptions.manualInstall', true);
        expect(v.get('checked')).to.equal(true);
      });
    });

    describe('#click', function() {
      it('should update controller.content.installOptions.useSsh', function () {
        v.set('controller.content.installOptions.useSsh', true);
        v.click();
        expect(v.get('controller.content.installOptions.useSsh')).to.equal(false);
      });
      it('should update controller.content.installOptions.manualInstall', function () {
        v.set('controller.content.installOptions.manualInstall', false);
        v.click();
        expect(v.get('controller.content.installOptions.manualInstall')).to.equal(true);
      });
    });

  });

  describe('#textFieldView', function() {
    var v;

    beforeEach(function() {
      v = view.get('textFieldView').create();
    });

    describe('#disabled', function() {
      it('should be inverted to isEnabled', function () {
        v.set('isEnabled', false);
        expect(v.get('disabled')).to.equal(true);
        v.set('isEnabled', true);
        expect(v.get('disabled')).to.equal(false);
      });
    });

  });

});

describe('App.SshKeyFileUploader', function() {

  beforeEach(function() {
    view = App.SshKeyFileUploader.create();
  });

});

});

;require.register("test/views/wizard/step3/hostLogPopupBody_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step3/hostLogPopupBody_view');
var view;
describe('App.WizardStep3HostLogPopupBody', function() {

  beforeEach(function() {
    view = App.WizardStep3HostLogPopupBody.create({
      parentView: Em.Object.create({
        host: Em.Object.create()
      })
    });
  });

  describe('#textArea', function() {

    var v;

    beforeEach(function() {
      v = view.get('textArea').create();
    });

    describe('#value', function() {
      it('should be equal to content', function() {
        var c = 'Relax, you are doing fine';
        v.set('content', c);
        expect(v.get('value')).to.equal(c);
      });
    });

  });

  describe('#bootLog', function() {
    it('should be equal to parentView.host.bootLog', function() {
      var log = 'i wanna play a game';
      view.set('parentView.host.bootLog', log);
      expect(view.get('bootLog')).to.equal(log);
    });
  });

});
});

;require.register("test/views/wizard/step3/hostWarningPopupBody_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var lazyloading = require('utils/lazy_loading');
require('views/wizard/step3/hostWarningPopupBody_view');
var view;

describe('App.WizardStep3HostWarningPopupBody', function() {

  beforeEach(function() {
    view = App.WizardStep3HostWarningPopupBody.create({
      didInsertElement: Em.K,
      $: function() {
        return Em.Object.create({
          toggle: Em.K
        })
      }
    });
  });

  describe('#onToggleBlock', function() {
    it('should toggle', function() {
      var context = Em.Object.create({isCollapsed: false});
      view.onToggleBlock({context: context});
      expect(context.get('isCollapsed')).to.equal(true);
      view.onToggleBlock({context: context});
      expect(context.get('isCollapsed')).to.equal(false);
    });
  });

  describe('#showHostsPopup', function() {
    it('should call App.ModalPopup.show', function() {
      sinon.stub(App.ModalPopup, 'show', Em.K);
      view.showHostsPopup({context: []});
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      App.ModalPopup.show.restore();
    });
  });

  describe('#categoryWarnings', function() {
    it('should return empty array', function() {
      var warningsByHost = null;
      view.reopen({warningsByHost: warningsByHost});
      expect(view.get('categoryWarnings')).to.eql([]);
    });
    it('should return filtered warnings', function() {
      var warningsByHost = [
        {name: 'c', warnings: [{}, {}, {}]},
        {name: 'd', warnings: [{}]}
      ];
      view.reopen({warningsByHost: warningsByHost, category: 'c'});
      expect(view.get('categoryWarnings.length')).to.equal(3);
    });
  });

  describe('#warningHostsNamesCount', function() {
    it('should parse warnings', function() {
      view.set('bodyController', Em.Object.create({
        repoCategoryWarnings: [
          {hostsNames: ['h1', 'h4']}
        ],
        diskCategoryWarnings: [
          {hostsNames: ['h2', 'h5']}
        ],
        warningsByHost: [
          {},
          { name: 'h1', warnings: [{}, {}, {}] },
          { name: 'h2', warnings: [{}, {}, {}] },
          { name: 'h3', warnings: [] }
        ]
      }));
      expect(view.warningHostsNamesCount()).to.equal(4);
    });
  });

  describe('#hostSelectView', function() {

    var v;

    beforeEach(function() {
      v = view.get('hostSelectView').create();
    });

    describe('#click', function() {
      Em.A([
          {
            isLoaded: false,
            isLazyLoading: true,
            e: true
          },
          {
            isLoaded: true,
            isLazyLoading: true,
            e: false
          },
          {
            isLoaded: false,
            isLazyLoading: false,
            e: false
          },
          {
            isLoaded: true,
            isLazyLoading: false,
            e: false
          }
        ]).forEach(function (test) {
          it('isLoaded: ' + test.isLoaded.toString() + ', isLazyLoading: ' + test.isLazyLoading.toString(), function () {
            v.reopen({
              isLoaded: test.isLoaded,
              isLazyLoading: test.isLazyLoading
            });
            sinon.spy(lazyloading, 'run');
            v.click();
            if (test.e) {
              expect(lazyloading.run.calledOnce).to.equal(true);
            }
            else {
              expect(lazyloading.run.called).to.equal(false);
            }
            lazyloading.run.restore();
          });
        });
    });

  });

  describe('#contentInDetails', function() {
    var content = [
      {category: 'firewall', warnings: [{name: 'n1'}, {name: 'n2'}, {name: 'n3'}]},
      {category: 'fileFolders', warnings: [{name: 'n4'}, {name: 'n5'}, {name: 'n6'}]},
      {category: 'reverseLookup', warnings: [{name: 'n19', hosts: ["h1"]}]},
      {
        category: 'process',
        warnings: [
          {name: 'n7', hosts:['h1', 'h2'], user: 'u1', pid: 'pid1'},
          {name: 'n8', hosts:['h2'], user: 'u2', pid: 'pid2'},
          {name: 'n9', hosts:['h3'], user: 'u1', pid: 'pid3'}
        ]
      },
      {category: 'package', warnings: [{name: 'n10'}, {name: 'n11'}, {name: 'n12'}]},
      {category: 'service', warnings: [{name: 'n13'}, {name: 'n14'}, {name: 'n15'}]},
      {category: 'user', warnings: [{name: 'n16'}, {name: 'n17'}, {name: 'n18'}]}
    ], warningsByHost = [
      {},
      {name: 'c', warnings: [{}, {}, {}]},
      {name: 'd', warnings: [{}]}
    ];
    beforeEach(function() {
      view.reopen({content: content, warningsByHost: warningsByHost});
    });
    it('should map hosts', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('c d')).to.equal(true);
    });
    it('should map firewall warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('n1<br>n2<br>n3')).to.equal(true);
    });
    it('should map fileFolders warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('n4 n5 n6')).to.equal(true);
    });
    it('should map process warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('(h1,u1,pid1)')).to.equal(true);
      expect(newContent.contains('(h2,u1,pid1)')).to.equal(true);
      expect(newContent.contains('(h2,u2,pid2)')).to.equal(true);
      expect(newContent.contains('(h3,u1,pid3)')).to.equal(true);
    });
    it('should map package warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('n10 n11 n12')).to.equal(true);
    });
    it('should map service warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('n13 n14 n15')).to.equal(true);
    });
    it('should map user warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('n16 n17 n18')).to.equal(true);
    });
    it('should map reverse lookup warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('h1')).to.equal(true);
    });
  });

});
});

;require.register("test/views/wizard/step3/hostWarningPopupFooter_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step3/hostWarningPopupFooter_view');
var view;

describe('App.WizardStep3HostWarningPopupFooter', function() {

  beforeEach(function() {
    view = App.WizardStep3HostWarningPopupFooter.create();
    view.reopen({footerController: Em.Object.create()});
  });

  describe('#progressWidth', function() {
    it('based on footerController.checksUpdateProgress', function() {
      view.set('footerController.checksUpdateProgress', 42);
      expect(view.get('progressWidth')).to.equal('width:42%');
    });
  });

  describe('#isUpdateInProgress', function() {
    var tests = Em.A([
      {checksUpdateProgress: 0, e: false},
      {checksUpdateProgress: 100, e: false},
      {checksUpdateProgress: 50, e: true}
    ]);
    tests.forEach(function(test) {
      it(test.checksUpdateProgress, function() {
        view.set('footerController.checksUpdateProgress', test.checksUpdateProgress);
        expect(view.get('isUpdateInProgress')).to.equal(test.e);
      });
    });
  });

  describe('#updateStatusClass', function() {
    var tests = Em.A([
      {checksUpdateStatus: 'SUCCESS', e: 'text-success'},
      {checksUpdateStatus: 'FAILED', e: 'text-error'},
      {checksUpdateStatus: 'PANIC', e: null}
    ]);
    tests.forEach(function(test) {
      it(test.checksUpdateStatus, function() {
        view.set('footerController.checksUpdateStatus', test.checksUpdateStatus);
        if (Em.isNone(test.e)) {
          expect(view.get('updateStatusClass')).to.be.null;
        }
        else {
          expect(view.get('updateStatusClass')).to.equal(test.e);
        }
      })
    });
  });

  describe('#updateStatus', function() {
    var tests = Em.A([
      {checksUpdateStatus: 'SUCCESS', e: Em.I18n.t('installer.step3.warnings.updateChecks.success')},
      {checksUpdateStatus: 'FAILED', e: Em.I18n.t('installer.step3.warnings.updateChecks.failed')},
      {checksUpdateStatus: 'PANIC', e: null}
    ]);
    tests.forEach(function(test) {
      it(test.checksUpdateStatus, function() {
        view.set('footerController.checksUpdateStatus', test.checksUpdateStatus);
        if (Em.isNone(test.e)) {
          expect(view.get('updateStatus')).to.be.null;
        }
        else {
          expect(view.get('updateStatus')).to.equal(test.e);
        }
      })
    });
  });

});
});

;require.register("test/views/wizard/step3_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('messages');
require('views/wizard/step3_view');
var v;
describe('App.WizardStep3View', function () {

  var view = App.WizardStep3View.create({
    monitorStatuses: function () {
    },
    content: [
      Em.Object.create({
        name: 'host1',
        bootStatus: 'PENDING',
        isChecked: false
      }),
      Em.Object.create({
        name: 'host2',
        bootStatus: 'PENDING',
        isChecked: true
      }),
      Em.Object.create({
        name: 'host3',
        bootStatus: 'PENDING',
        isChecked: true
      })
    ],
    pageContent: function () {
      return this.get('content');
    }.property('content')
  });

  describe('#watchSelection', function () {
    it('2 of 3 hosts selected', function () {
      view.watchSelection();
      expect(view.get('noHostsSelected')).to.equal(false);
      expect(view.get('selectedHostsCount')).to.equal(2);
    });
    it('all hosts selected', function () {
      view.selectAll();
      view.watchSelection();
      expect(view.get('noHostsSelected')).to.equal(false);
      expect(view.get('selectedHostsCount')).to.equal(3);
    });
    it('none hosts selected', function () {
      view.unSelectAll();
      view.watchSelection();
      expect(view.get('noHostsSelected')).to.equal(true);
      expect(view.get('selectedHostsCount')).to.equal(0);
    });
  });

  describe('#selectAll', function () {
    it('select all hosts', function () {
      view.selectAll();
      expect(view.get('content').everyProperty('isChecked', true)).to.equal(true);
    });
  });

  describe('#unSelectAll', function () {
    it('unselect all hosts', function () {
      view.unSelectAll();
      expect(view.get('content').everyProperty('isChecked', false)).to.equal(true);
    });
  });

  var testCases = Em.A([
    {
      title: 'none hosts',
      content: [],
      result: {
        "ALL": 0,
        "RUNNING": 0,
        "REGISTERING": 0,
        "REGISTERED": 0,
        "FAILED": 0
      }
    },
    {
      title: 'all hosts RUNNING',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'RUNNING'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'RUNNING'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'RUNNING'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 3,
        "REGISTERING": 0,
        "REGISTERED": 0,
        "FAILED": 0
      }
    },
    {
      title: 'all hosts REGISTERING',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'REGISTERING'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'REGISTERING'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'REGISTERING'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 0,
        "REGISTERING": 3,
        "REGISTERED": 0,
        "FAILED": 0
      }
    },
    {
      title: 'all hosts REGISTERED',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'REGISTERED'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'REGISTERED'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'REGISTERED'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 0,
        "REGISTERING": 0,
        "REGISTERED": 3,
        "FAILED": 0
      }
    },
    {
      title: 'all hosts FAILED',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'FAILED'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'FAILED'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'FAILED'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 0,
        "REGISTERING": 0,
        "REGISTERED": 0,
        "FAILED": 3
      }
    },
    {
      title: 'first host is FAILED, second is RUNNING, third is REGISTERED',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'FAILED'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'RUNNING'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'REGISTERED'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 1,
        "REGISTERING": 0,
        "REGISTERED": 1,
        "FAILED": 1
      }
    },
    {
      title: 'two hosts is REGISTERING, one is REGISTERED',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'REGISTERING'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'REGISTERING'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'REGISTERED'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 0,
        "REGISTERING": 2,
        "REGISTERED": 1,
        "FAILED": 0
      }
    }
  ]);

  describe('#countCategoryHosts', function () {
    testCases.forEach(function (test) {
      it(test.title, function () {
        view.set('content', test.content);
        view.countCategoryHosts();
        view.get('categories').forEach(function (category) {
          expect(category.get('hostsCount')).to.equal(test.result[category.get('hostsBootStatus')])
        })
      });
    }, this);
  });

  describe('#doFilter', function () {
    testCases.forEach(function (test) {
      describe(test.title, function () {
        view.get('categories').forEach(function (category) {
          it('. Selected category - ' + category.get('hostsBootStatus'), function () {
            view.set('content', test.content);
            view.reopen({
              selectedCategory: category
            });
            view.doFilter();
            expect(view.get('filteredContent').length).to.equal(test.result[category.get('hostsBootStatus')])
          });
        });
      });
    }, this);
  });

  describe('#monitorStatuses', function() {
    var tests = Em.A([
      {
        controller: Em.Object.create({bootHosts: Em.A([])}),
        m: 'Empty hosts list',
        e: {status: 'alert-warn', linkText: ''}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: false}),
        m: 'isWarningsLoaded false',
        e: {status: 'alert-info', linkText: ''}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: true, isHostHaveWarnings: true}),
        m: 'isWarningsLoaded true, isHostHaveWarnings true',
        e: {status: 'alert-warn', linkText: Em.I18n.t('installer.step3.warnings.linkText')}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: true, repoCategoryWarnings: ['']}),
        m: 'isWarningsLoaded true, repoCategoryWarnings not empty',
        e: {status: 'alert-warn', linkText: Em.I18n.t('installer.step3.warnings.linkText')}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: true, diskCategoryWarnings: ['']}),
        m: 'isWarningsLoaded true, diskCategoryWarnings not empty',
        e: {status: 'alert-warn', linkText: Em.I18n.t('installer.step3.warnings.linkText')}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: true, diskCategoryWarnings: [], repoCategoryWarnings: []}),
        m: 'isWarningsLoaded true, diskCategoryWarnings is empty, repoCategoryWarnings is empty',
        e: {status: 'alert-success', linkText: Em.I18n.t('installer.step3.noWarnings.linkText')}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{bootStatus: 'FAILED'}]), isWarningsLoaded: true, diskCategoryWarnings: [], repoCategoryWarnings: []}),
        m: 'isWarningsLoaded true, diskCategoryWarnings is empty, repoCategoryWarnings is empty, all failed',
        e: {status: 'alert-warn', linkText: ''}
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        v = App.WizardStep3View.create({
          controller: test.controller
        });
        v.monitorStatuses();
        expect(v.get('status')).to.equal(test.e.status);
        expect(v.get('linkText')).to.equal(test.e.linkText);
      });
    });
  });

  describe('#retrySelectedHosts', function() {
    it('should set active category "All"', function() {
      view.set('controller', Em.Object.create({retrySelectedHosts: Em.K, registeredHosts: []}));
      view.retrySelectedHosts();
      expect(view.get('categories').findProperty('hostsBootStatus', 'ALL').get('isActive')).to.equal(true);
    });
  });

  describe('#selectCategory', function() {
    var tests = Em.A(['ALL','RUNNING','REGISTERING','REGISTERED','FAILED']);
    tests.forEach(function(test) {
      it('should set active category "' + test + '"', function() {
        view.set('controller', Em.Object.create({retrySelectedHosts: Em.K, registeredHosts: []}));
        view.selectCategory({context:Em.Object.create({hostsBootStatus:test})});
        expect(view.get('categories').findProperty('hostsBootStatus', test).get('isActive')).to.equal(true);
      });
    });
  });

  describe('#countCategoryHosts', function() {
    it('should set host count for each category', function() {
      view.set('content', Em.A([
        Em.Object.create({bootStatus: 'RUNNING'}),
        Em.Object.create({bootStatus: 'REGISTERING'}),
        Em.Object.create({bootStatus: 'REGISTERED'}),
        Em.Object.create({bootStatus: 'FAILED'})
      ]));
      view.countCategoryHosts();
      expect(view.get('categories').mapProperty('hostsCount')).to.eql([4,1,1,1,1]);
    });
  });

  describe('#hostBootStatusObserver', function() {
    it('should call "Em.run.once" three times', function() {
      sinon.spy(Em.run, 'once');
      view.hostBootStatusObserver();
      expect(Em.run.once.calledThrice).to.equal(true);
      expect(Em.run.once.firstCall.args[1]).to.equal('countCategoryHosts');
      expect(Em.run.once.secondCall.args[1]).to.equal('filter');
      expect(Em.run.once.thirdCall.args[1]).to.equal('monitorStatuses');
      Em.run.once.restore();
    });
  });

  describe('#watchSelection', function() {
    describe('should set "pageChecked"', function() {
      var tests = Em.A([
        {pageContent: Em.A([]),m:'false if empty "pageContent"', e: false},
        {pageContent: Em.A([{isChecked: false}]),m:'false if not-empty "pageContent" and not all "isChecked" true', e: false},
        {pageContent: Em.A([{isChecked: true}]),m:'true if not-empty "pageContent" and all "isChecked" true', e: false}
      ]);
      tests.forEach(function(test) {
        it(test.m, function() {
          view.set('pageContent', test.pageContent);
          view.watchSelection();
          expect(view.get('pageChecked')).to.equal(test.e);
        });
      });
    });
    describe('should set "noHostsSelected" and "selectedHostsCount"', function() {
      var tests = Em.A([
        {pageContent: Em.A([]),content:Em.A([]),m:' - "true", "0" if content is empty',e:{selectedHostsCount: 0, noHostsSelected: true}},
        {pageContent: Em.A([]),content:Em.A([Em.Object.create({isChecked: false})]),m:' - "true", "0" if no one isChecked',e:{selectedHostsCount: 0, noHostsSelected: true}},
        {pageContent: Em.A([]),content:Em.A([Em.Object.create({isChecked: true}),Em.Object.create({isChecked: false})]),m:' - "false", "1" if one isChecked',e:{selectedHostsCount: 1, noHostsSelected: false}}
      ]);
      tests.forEach(function(test) {
        it(test.m, function() {
          view.set('pageContent', test.pageContent);
          view.set('content', test.content);
          view.watchSelection();
          expect(view.get('noHostsSelected')).to.equal(test.e.noHostsSelected);
          expect(view.get('selectedHostsCount')).to.equal(test.e.selectedHostsCount);
        });
      });
    });
  });

  describe('#watchSelectionOnce', function() {
    it('should call "Em.run.once" one time', function() {
      sinon.spy(Em.run, 'once');
      view.watchSelectionOnce();
      expect(Em.run.once.calledOnce).to.equal(true);
      expect(Em.run.once.firstCall.args[1]).to.equal('watchSelection');
      Em.run.once.restore();
    });
  });

  describe('#selectedCategory', function() {
    it('should equal category with isActive = true', function() {
      view.get('categories').findProperty('hostsBootStatus', 'FAILED').set('isActive', true);
      expect(view.get('selectedCategory.hostsBootStatus')).to.equal('FAILED');
    });
  });

  describe('#onPageChecked', function() {
    var tests = Em.A([
      {
        selectionInProgress: true,
        pageContent: [Em.Object.create({isChecked: true}), Em.Object.create({isChecked: false})],
        pageChecked: true,
        m: 'shouldn\'t do nothing if selectionInProgress is true',
        e: [true, false]
      },
      {
        selectionInProgress: false,
        pageContent: [Em.Object.create({isChecked: true}), Em.Object.create({isChecked: false})],
        pageChecked: true,
        m: 'should set each isChecked to pageChecked value',
        e: [true, true]
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        v = App.WizardStep3View.create({
          'pageContent': test.pageContent,
          'pageChecked': test.pageChecked,
          'selectionInProgress': test.selectionInProgress
        });
        v.onPageChecked();
        expect(v.get('pageContent').mapProperty('isChecked')).to.eql(test.e);
      });
    });
  });

  describe('#didInsertElement', function() {
    beforeEach(function() {
      v = App.WizardStep3View.create({
        controller: Em.Object.create({
          loadStep: Em.K
        })
      });
      sinon.spy(v.get('controller'), 'loadStep');
    });
    afterEach(function() {
      v.get('controller').loadStep.restore();
    });
    it('should call loadStep', function() {
      v.didInsertElement();
      expect(v.get('controller').loadStep.calledOnce).to.equal(true);
    });
  });

  describe('#categoryObject', function() {
    var o;
    beforeEach(function() {
      v = App.WizardStep3View.create();
      o = v.get('categoryObject').create();
    });

    describe('#label', function() {
      it('should use value and hostCount', function() {
        o.setProperties({
          value: 'abc',
          hostsCount: 3
        });
        expect(o.get('label')).to.equal('abc (3)');
      });
    });

    describe('#itemClass', function() {
      it('should depends on isActive', function() {
        o.set('isActive', true);
        expect(o.get('itemClass')).to.equal('active');
        o.set('isActive', false);
        expect(o.get('itemClass')).to.equal('');
      });
    });

  });

});

var wView;
describe('App.WizardHostView', function() {

  beforeEach(function() {
    wView = App.WizardHostView.create({
      hostInfo: {},
      controller: Em.Object.create({
        removeHost: Em.K,
        retryHost: Em.K
      })
    });
    sinon.spy(wView.get('controller'), 'retryHost');
    sinon.spy(wView.get('controller'), 'removeHost');
  });

  afterEach(function() {
    wView.get('controller').retryHost.restore();
    wView.get('controller').removeHost.restore();
  });

  describe('#retry', function() {
    it('should call controller.retryHost', function() {
      wView.retry();
      expect(wView.get('controller').retryHost.calledWith({})).to.equal(true);
      expect(wView.get('controller').retryHost.calledOnce).to.equal(true);
    });
  });

  describe('#remove', function() {
    it('should call controller.removeHost', function() {
      wView.remove();
      expect(wView.get('controller').removeHost.calledWith({})).to.equal(true);
      expect(wView.get('controller').removeHost.calledOnce).to.equal(true);
    });
  });

});

});

;require.register("test/views/wizard/step5_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/wizard/step5_view');
var view;

describe('App.WizardStep5View', function() {

  beforeEach(function() {
    view = App.WizardStep5View.create({
      controller: App.WizardStep5Controller.create({})
    });
  });

  describe('#didInsertElement', function() {
    it('should call controller.loadStep', function() {
      sinon.stub(view.get('controller'), 'loadStep', Em.K);
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
      view.get('controller').loadStep.restore();
    });
  });

  describe('#shouldUseInputs', function() {
    it('should based on hosts count', function() {
      view.set('controller.hosts', d3.range(0, 25).map(function() {return {};}));
      expect(view.get('shouldUseInputs')).to.be.false;
      view.set('controller.hosts', d3.range(0, 26).map(function() {return {};}));
      expect(view.get('shouldUseInputs')).to.be.true;
      view.set('controller.hosts', d3.range(0, 24).map(function() {return {};}));
      expect(view.get('shouldUseInputs')).to.be.false;
    });
  });

});

describe('App.SelectHostView', function() {

  beforeEach(function() {
    view = App.SelectHostView.create({
      controller: App.WizardStep5Controller.create({}),
      $: function() {return {typeahead: function(){return {on: Em.K}}}},
      updateErrorStatus: Em.K
    });
  });

  describe('#click', function() {

    beforeEach(function() {
      sinon.stub(view, 'initContent', Em.K);
    });

    afterEach(function() {
      view.initContent.restore();
    });

    it('should call initContent', function() {
      view.click();
      expect(view.initContent.calledOnce).to.be.true;
    });

  });

  describe('#didInsertElement', function() {

    it('should set value', function() {
      view.set('value', '');
      view.set('component', {selectedHost: 'h1'});
      view.didInsertElement();
      expect(view.get('value')).to.equal('h1');
    });

  });

  describe('#changeHandler', function() {

    beforeEach(function() {
      view.set('component', {component_name: 'ZOOKEEPER_SERVER', zId: 1});
      view.set('controller.hosts', [Em.Object.create({host_info: 'h1 info', host_name: 'h1'})]);
      view.set('value', 'h1 info');
      view.set('controller.rebalanceComponentHostsCounter', 0);
      view.set('controller.componentToRebalance', '');
      sinon.stub(view.get('controller'), 'assignHostToMaster', Em.K);
      sinon.stub(view.get('controller'), 'updateIsHostNameValidFlag', Em.K);
      sinon.stub(view, 'shouldChangeHandlerBeCalled', function() {return true;});
    });

    afterEach(function() {
      view.get('controller').assignHostToMaster.restore();
      view.get('controller').updateIsHostNameValidFlag.restore();
      view.shouldChangeHandlerBeCalled.restore();
    });

    it('shouldn\'t do nothing if view is destroyed', function() {
      view.set('state', 'destroyed');
      expect(view.get('controller').assignHostToMaster.called).to.be.false;
    });

    it('should call assignHostToMaster', function() {
      view.changeHandler();
      expect(view.get('controller').assignHostToMaster.calledWith('ZOOKEEPER_SERVER', 'h1', 1));
    });

    it('should increment rebalanceComponentHostsCounter if component it is multiple', function() {
      view.set('component', {component_name: 'ZOOKEEPER_SERVER'});
      view.changeHandler();
      expect(view.get('controller.rebalanceComponentHostsCounter')).to.equal(1);
    });

    it('should set componentToRebalance', function() {
      view.changeHandler();
      expect(view.get('controller.componentToRebalance')).to.equal('ZOOKEEPER_SERVER');
    });

  });

});

describe('App.InputHostView', function() {

  beforeEach(function() {
    view = App.InputHostView.create({
      controller: App.WizardStep5Controller.create({}),
      $: function() {return {typeahead: function(){return {on: Em.K}}}},
      updateErrorStatus: Em.K
    });
  });

  describe('#didInsertElement', function() {

    beforeEach(function() {
      sinon.stub(view, 'initContent', Em.K);
      view.set('content', [Em.Object.create({host_name: 'h1', host_info: 'h1 info'})]);
      view.set('component', {selectedHost: 'h1'});
    });

    afterEach(function() {
      view.initContent.restore();
    });

    it('should call initContent', function() {
      view.didInsertElement();
      expect(view.initContent.calledOnce).to.equal(true);
    });

    it('should set selectedHost host_info to value', function() {
      view.set('value', '');
      view.didInsertElement();
      expect(view.get('value')).to.equal('h1 info');
    });

  });

  describe('#changeHandler', function() {

    beforeEach(function() {
      view.set('component', {component_name: 'ZOOKEEPER_SERVER', zId: 1});
      view.set('controller.hosts', [Em.Object.create({host_info: 'h1 info', host_name: 'h1'})]);
      view.set('value', 'h1 info');
      view.set('controller.rebalanceComponentHostsCounter', 0);
      view.set('controller.componentToRebalance', '');
      sinon.stub(view.get('controller'), 'assignHostToMaster', Em.K);
      sinon.stub(view.get('controller'), 'updateIsHostNameValidFlag', Em.K);
      sinon.stub(view, 'shouldChangeHandlerBeCalled', function() {return true;});
    });

    afterEach(function() {
      view.get('controller').assignHostToMaster.restore();
      view.get('controller').updateIsHostNameValidFlag.restore();
      view.shouldChangeHandlerBeCalled.restore();
    });

    it('shouldn\'t do nothing if view is destroyed', function() {
      view.set('state', 'destroyed');
      expect(view.get('controller').assignHostToMaster.called).to.be.false;
    });

    it('should call assignHostToMaster', function() {
      view.changeHandler();
      expect(view.get('controller').assignHostToMaster.calledWith('ZOOKEEPER_SERVER', 'h1', 1));
    });

    it('should increment rebalanceComponentHostsCounter if component it is multiple', function() {
      view.set('component', {component_name: 'ZOOKEEPER_SERVER'});
      view.changeHandler();
      expect(view.get('controller.rebalanceComponentHostsCounter')).to.equal(1);
    });

    it('should set componentToRebalance', function() {
      view.changeHandler();
      expect(view.get('controller.componentToRebalance')).to.equal('ZOOKEEPER_SERVER');
    });

  });

  describe('#getAvailableHosts', function() {
    var tests = Em.A([
      {
        hosts: Em.A([]),
        selectedHost: 'h2',
        componentName: 'ZOOKEEPER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({component_name: 'ZOOKEEPER_SERVER', selectedHost: 'h1'})
        ]),
        m: 'Empty hosts',
        e: []
      },
      {
        hosts: Em.A([
          Em.Object.create({host_name: 'h1'}),
          Em.Object.create({host_name: 'h2'})
        ]),
        selectedHost: 'h2',
        componentName: 'c1',
        selectedServicesMasters: Em.A([
          Em.Object.create({component_name: 'c2', selectedHost: 'h1'})
        ]),
        m: 'Two hosts',
        e: ['h1', 'h2']
      },
      {
        hosts: Em.A([
          Em.Object.create({host_name: 'h1'}),
          Em.Object.create({host_name: 'h2'})
        ]),
        selectedHost: 'h2',
        componentName: 'ZOOKEEPER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({component_name: 'ZOOKEEPER_SERVER', selectedHost: 'h1'})
        ]),
        m: 'Two hosts, ZOOKEEPER_SERVER',
        e: ['h2']
      },
      {
        hosts: Em.A([
          Em.Object.create({host_name: 'h1'}),
          Em.Object.create({host_name: 'h2'})
        ]),
        selectedHost: 'h2',
        componentName: 'HBASE_MASTER',
        selectedServicesMasters: Em.A([
          Em.Object.create({component_name: 'HBASE_MASTER', selectedHost: 'h1'})
        ]),
        m: 'Two hosts, HBASE_MASTER',
        e: ['h2']
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        view.set('controller.hosts', test.hosts);
        view.set('component', {component_name: test.componentName});
        view.set('controller.selectedServicesMasters', test.selectedServicesMasters);
        var r = view.getAvailableHosts();
        expect(r.mapProperty('host_name')).to.eql(test.e);
      });
    });
  });

  describe('#rebalanceComponentHostsOnce', function() {
    var tests = Em.A([
      {
        componentName: 'c1',
        componentToRebalance: 'c2',
        content: [{}],
        m: 'componentName not equal to componentToRebalance',
        e: {
          initContent: false
        }
      },
      {
        componentName: 'c2',
        componentToRebalance: 'c2',
        content: [{}],
        m: 'componentName equal to componentToRebalance',
        e: {
          initContent: true
        }
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        view.set('content', test.content);
        view.set('component', {component_name: test.componentName});
        view.set('controller.componentToRebalance', test.componentToRebalance);
        sinon.stub(view, 'initContent', Em.K);
        view.rebalanceComponentHostsOnce();
        expect(view.initContent.calledOnce).to.equal(test.e.initContent);
        view.initContent.restore();
      });
    });
  });

  describe('#initContent', function() {
    var tests = Em.A([
      {
        hosts: 25,
        m: 'not lazy loading, 25 hosts, no selected host',
        e: 25
      },
      {
        hosts: 25,
        h: 4,
        m: 'not lazy loading, 25 hosts, one selected host',
        e: 25
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        view.reopen({getAvailableHosts: function() {return d3.range(0, test.hosts).map(function(indx){return Em.Object.create({host_name: indx})});}});
        if (test.h) {
          view.set('selectedHost', test.h);
        }
        view.initContent();
        expect(view.get('content.length')).to.equal(test.e);
      });
    });
  });

  describe('#change', function() {

    beforeEach(function() {
      sinon.stub(view, 'changeHandler', Em.K);
    });

    afterEach(function() {
      view.changeHandler.restore();
    });

    it('shouldn\'t do nothing if view is destroyed', function() {
      view.set('controller.hostNameCheckTrigger', false);
      view.set('state', 'destroyed');
      view.change();
      expect(view.get('controller.hostNameCheckTrigger')).to.equal(false);
    });

    it('should toggle hostNameCheckTrigger', function() {
      view.set('controller.hostNameCheckTrigger', false);
      view.change();
      expect(view.get('controller.hostNameCheckTrigger')).to.equal(true);
    });

  });

});

describe('App.RemoveControlView', function() {

  beforeEach(function() {
    view = App.RemoveControlView.create({
      controller: App.WizardStep5Controller.create({})
    });
  });

  describe('#click', function() {
    beforeEach(function() {
      sinon.stub(view.get('controller'), 'removeComponent', Em.K);
    });
    afterEach(function() {
      view.get('controller').removeComponent.restore();
    });
    it('should call removeComponent', function() {
      view.set('zId', 1);
      view.set('componentName', 'c1');
      view.click();
      expect(view.get('controller').removeComponent.calledWith('c1', 1)).to.equal(true);
    });
  });

});

describe('App.AddControlView', function() {

  beforeEach(function() {
    view = App.AddControlView.create({
      controller: App.WizardStep5Controller.create({})
    });
  });

  describe('#click', function() {

    beforeEach(function() {
      sinon.stub(view.get('controller'), 'addComponent', Em.K);
    });

    afterEach(function() {
      view.get('controller').addComponent.restore();
    });

    it('should call addComponent', function() {
      view.set('componentName', 'c1');
      view.click();
      expect(view.get('controller').addComponent.calledWith('c1')).to.equal(true);
    });

  });

});

});

;require.register("test/views/wizard/step6_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('utils/helper');
require('utils/string_utils');
require('views/wizard/step6_view');
var view;

describe('App.WizardStep6View', function() {

  beforeEach(function() {
    view = App.WizardStep6View.create({
      controller: App.WizardStep6Controller.create()
    });
  });

  describe('#content', function() {
    it('should be same to controller.hosts', function() {
      view.set('content', []);
      var d = [{}, {}];
      view.set('controller.hosts', d);
      expect(view.get('content')).to.eql(d);
    });
  });

  describe('#filteredContent', function() {
    it('should be same to content', function() {
      view.set('content', []);
      var d = [{}, {}];
      view.set('controller.hosts', d);
      expect(view.get('filteredContent')).to.eql(d);
    });
  });

  describe('#didInsertElement', function() {
    beforeEach(function() {
      sinon.stub(view.get('controller'), 'loadStep', Em.K);
      sinon.stub(App, 'tooltip', Em.K);
      sinon.stub(view, 'setLabel', Em.K);
    });
    afterEach(function() {
      view.get('controller').loadStep.restore();
      App.tooltip.restore();
      view.setLabel.restore();
    });
    it('should call loadStep', function() {
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
    });
    it('should create tooltip', function() {
      view.didInsertElement();
      expect(App.tooltip.calledOnce).to.equal(true);
    });
    it('should call setLabel if not controller.isMasters', function() {
      view.set('controller.isMasters', false);
      view.didInsertElement();
      expect(view.setLabel.calledOnce).to.equal(true);
    });
    it('shouldn\'t call setLabel if controller.isMasters', function() {
      view.set('controller.isMasters', true);
      view.didInsertElement();
      expect(view.setLabel.called).to.equal(false);
    });
  });

  describe('#setLabel', function() {
    var tests = Em.A([
      {
        clients: [{display_name: 'c1'}],
        m: 'One client',
        e: 'c1'
      },
      {
        clients: [{display_name: 'c1'}, {display_name: 'c2'}],
        m: 'Two clients',
        e: 'c1 and c2.'
      },
      {
        clients: [{display_name: 'c1'}, {display_name: 'c2'}, {display_name: 'c3'}],
        m: 'Three clients',
        e: 'c1, c2 and c3.'
      },
      {
        clients: [{display_name: 'c1'}, {display_name: 'c2'}, {display_name: 'c3'}, {display_name: 'c4'}],
        m: 'Four clients',
        e: 'c1, c2, c3 and c4.'
      },
      {
        clients: [{display_name: 'c1'}, {display_name: 'c2'}, {display_name: 'c3'}, {display_name: 'c4'}, {display_name: 'c5'}],
        m: 'Five clients',
        e: 'c1, c2, c3, c4 and c5.'
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        view.set('controller.content', {clients: test.clients});
        view.setLabel();
        expect(view.get('label').endsWith(test.e)).to.equal(true);
      });
    });
  });
  
  describe('#checkboxView', function() {
    it('should call checkCallback', function() {
      var v = view.get('checkboxView').create({
        controller: App.WizardStep6Controller.create()
      });
      sinon.stub(v.get('controller'), 'checkCallback', Em.K);
      v.click();
      expect(v.get('controller').checkCallback.calledOnce).to.equal(true);
      v.get('controller').checkCallback.restore();
    });
  });

});

describe('App.WizardStep6HostView', function() {

  beforeEach(function() {
    view = App.WizardStep6HostView.create({
      controller: App.WizardStep6Controller.create()
    });
  });

  describe('#didInsertElement', function() {
    beforeEach(function() {
      sinon.stub(App, 'popover', Em.K);
    });
    afterEach(function() {
      App.popover.restore();
    });
    it('should create popover if not controller.isMasters', function() {
      sinon.stub(view.get('controller'), 'getMasterComponentsForHost', function() {return [{}, {}];});
      view.set('controller.isMasters', false);
      view.didInsertElement();
      expect(App.popover.calledOnce).to.equal(true);
      view.get('controller').getMasterComponentsForHost.restore();
    });
    it('shouldn\'t create popover if controller.isMasters', function() {
      view.set('controller.isMasters', true);
      view.didInsertElement();
      expect(App.popover.called).to.equal(false);
    });
    it('shouldn\'t create popover if controller.getMasterComponentsForHost returns empty array', function() {
      sinon.stub(view.get('controller'), 'getMasterComponentsForHost', function() {return [];});
      view.set('controller.isMasters', true);
      view.didInsertElement();
      expect(App.popover.called).to.equal(false);
      view.get('controller').getMasterComponentsForHost.restore();
    });
  });

});
});

;require.register("test/views/wizard/step8_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('utils/helper');
require('utils/string_utils');
require('views/wizard/step8_view');
var view;

describe('App.WizardStep8View', function() {

  beforeEach(function() {
    view = App.WizardStep8View.create();
  });

  describe('#didInsertElement', function() {
    it('should call loadStep', function() {
      view.set('controller', Em.Object.create({
        loadStep: Em.K
      }));
      sinon.spy(view.get('controller'), 'loadStep');
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
      view.get('controller').loadStep.restore();
    });
  });

  describe('#printReview', function() {
    it('should call jqprint', function() {
      sinon.stub($.fn, 'jqprint', Em.K);
      view.printReview();
      expect($.fn.jqprint.calledOnce).to.equal(true);
      $.fn.jqprint.restore();
    });
  });

  describe('#showLoadingIndicator', function() {
    it('should hide existing popup', function() {
      var popup = App.ModalPopup.show({});
      view.set('modalPopup', popup);
      view.set('controller', {isSubmitDisabled: false});
      view.showLoadingIndicator();
      expect(Em.isNone(view.get('popup'))).to.equal(true);
    });
    it('if popup exists shouldn\'t create another', function() {
      view.set('modalPopup', App.ModalPopup.show({}));
      view.set('controller', {isSubmitDisabled: true});
      sinon.spy(App.ModalPopup, 'show');
      view.showLoadingIndicator();
      expect(App.ModalPopup.show.called).to.equal(false);
      App.ModalPopup.show.restore();
    });
    it('if popup doesn\'t exist should create another', function() {
      view.set('modalPopup', null);
      view.reopen({controller: {isSubmitDisabled: true}});
      sinon.spy(App.ModalPopup, 'show');
      view.showLoadingIndicator();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      App.ModalPopup.show.restore();
    });

    describe('#bodyClass', function() {

      beforeEach(function() {
        view.set('modalPopup', null);
        view.reopen({controller: {isSubmitDisabled: true}});
      });

      describe('#autoHide', function() {
        it('should be called if controller.servicesInstalled is true', function() {
          view.showLoadingIndicator();
          var v = view.get('modalPopup').get('bodyClass').create();
          v.reopen({controller: {servicesInstalled: false}, parentView: Em.Object.create({hide: Em.K})});
          sinon.spy(v.get('parentView'), 'hide');
          v.set('controller.servicesInstalled', true);
          expect(v.get('parentView').hide.calledOnce).to.equal(true);
          v.get('parentView').hide.restore();
        });
        it('shouldn\'t be called if controller.servicesInstalled is false', function() {
          view.showLoadingIndicator();
          var v = view.get('modalPopup').get('bodyClass').create();
          v.reopen({controller: {servicesInstalled: false}, parentView: Em.Object.create({hide: Em.K})});
          sinon.spy(v.get('parentView'), 'hide');
          v.set('controller.servicesInstalled', false);
          expect(v.get('parentView').hide.called).to.equal(false);
          v.get('parentView').hide.restore();
        });
      });

      describe('#ajaxQueueChangeObs', function() {
        it('should set barWidth and message', function() {
          view.showLoadingIndicator();
          var v = view.get('modalPopup').get('bodyClass').create();
          v.reopen({controller: {ajaxQueueLength: 12, ajaxRequestsQueue: Em.Object.create({queue: []})}});
          v.set('controller.ajaxRequestsQueue.queue', [{}, {}, {}, {}]);
          expect(v.get('barWidth')).to.equal('width: ' + (8 / 12 * 100) + '%;');
          expect(v.get('message')).to.equal(Em.I18n.t('installer.step8.deployPopup.message').format(8, 12));
        });
      });

    });
  });

});
});

;require.register("test/views/wizard/step9/hostLogPopupBody_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step9/hostLogPopupBody_view');
var view;

describe('App.WizardStep9HostLogPopupBodyView', function() {

  beforeEach(function() {
    view = App.WizardStep9HostLogPopupBodyView.create({
      parentView: Em.Object.create({
        host: Em.Object.create()
      })
    });
  });

  describe('#isHeartbeatLost', function() {
    it('should depends on parentView.host.status', function() {
      view.set('parentView.host.status', 'success');
      expect(view.get('isHeartbeatLost')).to.equal(false);
      view.set('parentView.host.status', 'heartbeat_lost');
      expect(view.get('isHeartbeatLost')).to.equal(true);
    });
  });

  describe('#isNoTasksScheduled', function() {
    it('should be same to parentView.host.isNoTasksForInstall', function() {
      view.set('parentView.host.isNoTasksForInstall', true);
      expect(view.get('isNoTasksScheduled')).to.equal(true);
      view.set('parentView.host.isNoTasksForInstall', false);
      expect(view.get('isNoTasksScheduled')).to.equal(false);
    });
  });

  describe('#visibleTasks', function() {
    Em.A([
        {
          value: 'pending',
          f: ['pending', 'queued']
        },
        {
          value: 'in_progress',
          f: ['in_progress']
        },
        {
          value: 'failed',
          f: ['failed']
        },
        {
          value: 'completed',
          f: ['completed']
        },
        {
          value: 'aborted',
          f: ['aborted']
        },
        {
          value: 'timedout',
          f: ['timedout']
        },
        {
          value: 'all'
        }
      ]).forEach(function(test) {
        it(test.value, function() {
          view.reopen({
            category: Em.Object.create({value: test.value}),
            tasks: Em.A([
              {status: 'pending', isVisible: false},
              {status: 'queued', isVisible: false},
              {status: 'in_progress', isVisible: false},
              {status: 'failed', isVisible: false},
              {status: 'completed', isVisible: false},
              {status: 'aborted', isVisible: false},
              {status: 'timedout', isVisible: false}
            ])
          });
          view.visibleTasks();
          var visibleTasks = view.get('tasks').filter(function(task) {
            if (test.f) {
              return test.f.contains(task.status);
            }
            return true;
          });
          expect(visibleTasks.everyProperty('isVisible', true)).to.equal(true);
        });
    });
  });

  describe('#backToTaskList', function() {
    it('should call destroyClipBoard', function() {
      sinon.stub(view, 'destroyClipBoard', Em.K);
      view.backToTaskList();
      expect(view.destroyClipBoard.calledOnce).to.equal(true);
      view.destroyClipBoard.restore();
    });
    it('should set isLogWrapHidden to true', function() {
      view.set('isLogWrapHidden', false);
      view.backToTaskList();
      expect(view.get('isLogWrapHidden')).to.equal(true);
    });
  });

  describe('#getStartedTasks', function() {
    it('should return tasks with some status', function() {
      var logTasks = Em.A([
        {Tasks: {}}, {Tasks: {status: 's'}}, {Tasks: {status: null}}, {Tasks: {status: 'v'}}
      ]);
      expect(view.getStartedTasks({logTasks: logTasks}).length).to.equal(2);
    });
  });

  describe('#openedTask', function() {
    it('should return currently open task', function() {
      var task = Em.Object.create({id: 2});
      view.reopen({
        tasks: Em.A([
          Em.Object.create({id: 1}),
          Em.Object.create({id: 3}),
          task,
          Em.Object.create({id: 4})
        ])
      });
      view.set('parentView.c', {currentOpenTaskId: 2});
      expect(view.get('openedTask.id')).to.equal(2);
    });
  });

  describe('#tasks', function() {
    var testTask = {
      Tasks: {
        status: 'init',
        id: 1,
        request_id: 2,
        role: 'PIG',
        stderr: 'stderr',
        stdout: 'stdout',
        host_name: 'host1',
        command: 'Cmd'
      }
    };

    it('should map tasks', function() {
      view.set('parentView.host.logTasks', [testTask]);
      var t = view.get('tasks');
      expect(t.length).to.equal(1);
      var first = t[0];
      expect(first.get('id')).to.equal(1);
      expect(first.get('requestId')).to.equal(2);
      expect(first.get('command')).to.equal('cmd');
      expect(first.get('role')).to.equal('Pig');
      expect(first.get('stderr')).to.equal('stderr');
      expect(first.get('stdout')).to.equal('stdout');
      expect(first.get('isVisible')).to.equal(true);
      expect(first.get('hostName')).to.equal('host1');
    });

    it('should set cog icon', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'pending';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-cog');
    });

    it('should set cog icon (2)', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'queued';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-cog');
    });

    it('should set cogs icon', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'in_progress';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-cogs');
    });

    it('should set ok icon', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'completed';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-ok');
    });

    it('should set icon-exclamation-sign icon', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'failed';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-exclamation-sign');
    });

    it('should set minus icon', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'aborted';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-minus');
    });

    it('should set time icon', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'timedout';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-time');
    });

  });

  describe('#toggleTaskLog', function() {
    it('isLogWrapHidden is true', function() {
      var taskInfo = {
        id: 1,
        requestId: 2
      };
      view.set('isLogWrapHidden', true);
      view.set('parentView.c', Em.Object.create({loadCurrentTaskLog: Em.K}));
      sinon.spy(view.get('parentView.c'), 'loadCurrentTaskLog');
      view.toggleTaskLog({context: taskInfo});
      expect(view.get('isLogWrapHidden')).to.equal(false);
      expect(view.get('parentView.c.currentOpenTaskId')).to.equal(taskInfo.id);
      expect(view.get('parentView.c.currentOpenTaskRequestId')).to.equal(taskInfo.requestId);
      expect(view.get('parentView.c').loadCurrentTaskLog.calledOnce).to.equal(true);
      view.get('parentView.c').loadCurrentTaskLog.restore();
    });
    it('isLogWrapHidden is false', function() {
      var taskInfo = {};
      view.set('isLogWrapHidden', false);
      view.set('parentView.c', Em.Object.create({loadCurrentTaskLog: Em.K}));
      view.toggleTaskLog({context: taskInfo});
      expect(view.get('isLogWrapHidden')).to.equal(true);
      expect(view.get('parentView.c.currentOpenTaskId')).to.equal(0);
      expect(view.get('parentView.c.currentOpenTaskRequestId')).to.equal(0);
    });
  });

});
});

;require.register("test/views/wizard/step9_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step9_view');

var v;
describe('App.WizardStep9View', function () {
  beforeEach(function () {
    v = App.WizardStep9View.create({
      controller: App.WizardStep9Controller.create()
    });
  });
  var view = App.WizardStep9View.create({
    onStatus: function () {
    },
    content: [],
    pageContent: function () {
      return this.get('content');
    }.property('content')
  });
  var testCases = [
    {
      title: 'none hosts',
      content: [],
      result: {
        "all": 0,
        "inProgress": 0,
        "warning": 0,
        "success": 0,
        "failed": 0
      }
    },
    {
      title: 'all hosts inProgress',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'in_progress'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'info'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'pending'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 3,
        "warning": 0,
        "success": 0,
        "failed": 0
      }
    },
    {
      title: 'all hosts warning',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'warning'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'warning'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'warning'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 0,
        "warning": 3,
        "success": 0,
        "failed": 0
      }
    },
    {
      title: 'all hosts success',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'success'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'success'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'success'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 0,
        "warning": 0,
        "success": 3,
        "failed": 0
      }
    },
    {
      title: 'all hosts failed',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'failed'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'failed'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'heartbeat_lost'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 0,
        "warning": 0,
        "success": 0,
        "failed": 3
      }
    },
    {
      title: 'first host is failed, second is warning, third is success',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'failed'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'success'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'warning'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 0,
        "warning": 1,
        "success": 1,
        "failed": 1
      }
    },
    {
      title: 'two hosts is inProgress, one is success',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'pending'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'in_progress'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'success'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 2,
        "warning": 0,
        "success": 1,
        "failed": 0
      }
    }
  ];

  describe('#countCategoryHosts', function () {
    testCases.forEach(function (test) {
      it(test.title, function () {
        view.set('content', test.content);
        view.countCategoryHosts();
        view.get('categories').forEach(function (category) {
          expect(category.get('hostsCount')).to.equal(test.result[category.get('hostStatus')])
        })
      });
    }, this);
  });

  describe('#doFilter', function () {
    testCases.forEach(function (test) {
      describe(test.title, function () {
        view.get('categories').forEach(function (category) {
          it('. Selected category - ' + category.get('hostStatus'), function () {
            view.set('content', test.content);
            view.reopen({selectedCategory: category});
            view.doFilter();
            expect(view.get('filteredContent').length).to.equal(test.result[category.get('hostStatus')])
          });
        })
      });
    }, this);
  });

  describe('#isStepCompleted', function () {
    it('should be true if progress is 100', function () {
      v.set('controller.progress', '100');
      expect(v.get('isStepCompleted')).to.equal(true);
    });
    it('should be false if progress isn\'t 100', function () {
      v.set('controller.progress', '50');
      expect(v.get('isStepCompleted')).to.equal(false);
    });
  });

  describe('#content', function () {
    it('should be equal to controller.hosts', function () {
      sinon.stub(v, 'hostStatusObserver', Em.K);
      var hosts = [
        {},
        {},
        {}
      ];
      v.set('controller.hosts', hosts);
      expect(v.get('content')).to.eql(hosts);
      v.hostStatusObserver.restore();
    });
  });

  describe('#categoryObject', function () {
    it('label should contains value and hostsCount', function () {
      var value = 'v',
        hostsCount = 10,
        o = v.get('categoryObject').create({value: value, hostsCount: hostsCount});
      expect(o.get('label')).to.equal(value + ' (' + hostsCount + ')');
    });
    it('itemClass should depends on isActive', function () {
      var o = v.get('categoryObject').create();
      o.set('isActive', false);
      expect(o.get('itemClass')).to.equal('');
      o.set('isActive', true);
      expect(o.get('itemClass')).to.equal('active');
    });
  });

  describe('#isHostHeartbeatLost', function () {
    Em.A([
        {
          hostsWithHeartbeatLost: [],
          m: 'should be false if hostsWithHeartbeatLost is empty',
          e: false
        },
        {
          hostsWithHeartbeatLost: [
            {},
            {}
          ],
          m: 'should be true if hostsWithHeartbeatLost contains some values',
          e: true
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          v.set('controller.hostsWithHeartbeatLost', test.hostsWithHeartbeatLost);
          expect(v.get('isHostHeartbeatLost')).to.equal(test.e);
        })
      });
  });

  describe('#barWidth', function () {
    it('should depends on controller.progress', function () {
      var w = '25';
      v.set('controller.progress', w);
      expect(v.get('barWidth')).to.equal('width: ' + w + '%;');
    });
  });

  describe('#progressMessage', function () {
    it('should depends on controller.progress', function () {
      var w = '25';
      v.set('controller.progress', w);
      expect(v.get('progressMessage').contains(w)).to.equal(true);
    });
  });

  describe('#showAllHosts', function () {
    it('should set active to category with all hosts', function () {
      v.get('categories').findProperty('hostStatus', 'inProgress').set('isActive', true);
      v.showAllHosts();
      var allCategory = v.get('categories').findProperty('hostStatus', 'all');
      expect(allCategory.get('isActive')).to.equal(true);
      expect(v.get('categories').without(allCategory).everyProperty('isActive', false)).to.equal(true);
    });
  });

  describe('#didInsertElement', function () {
    beforeEach(function () {
      sinon.stub(v, 'onStatus', Em.K);
      sinon.stub(v.get('controller'), 'navigateStep', Em.K);
    });
    afterEach(function () {
      v.onStatus.restore();
      v.get('controller').navigateStep.restore();
    });
    it('should call onStatus', function () {
      v.didInsertElement();
      expect(v.onStatus.calledOnce).to.equal(true);
    });
    it('should call navigateStep', function () {
      v.didInsertElement();
      expect(v.get('controller').navigateStep.calledOnce).to.equal(true);
    });
  });

  describe('#selectCategory', function () {
    it('should set isActive true to selected category', function () {
      var event = {context: Em.Object.create({hostStatus: 'inProgress'})},
        c = v.get('categories').findProperty('hostStatus', 'inProgress');
      c.set('isActive', false);
      v.selectCategory(event);
      expect(c.get('isActive')).to.equal(true);
    });
  });

  describe('#onStatus', function () {
    Em.A([
        {
          status: 'success',
          e: {
            barColor: 'progress-success',
            resultMsg: Em.I18n.t('installer.step9.status.success'),
            resultMsgColor: 'alert-success'
          }
        },
        {
          status: 'info',
          e: {
            barColor: 'progress-info',
            resultMsg: ''
          }
        },
        {
          status: 'warning',
          e: {
            barColor: 'progress-warning',
            resultMsg: Em.I18n.t('installer.step9.status.warning'),
            resultMsgColor: 'alert-warning'
          }
        },
        {
          status: 'failed',
          e: {
            barColor: 'progress-danger',
            resultMsgColor: 'alert-error'
          }
        }
      ]).forEach(function (test) {
        it(test.status, function () {
          v.set('controller.status', test.status);
          v.onStatus();
          Em.keys(test.e).forEach(function (k) {
            expect(v.get(k)).to.equal(test.e[k]);
          });
        });
      });
    Em.A([
        {
          hostsWithHeartbeatLost: [
            {},
            {}
          ],
          startCallFailed: false,
          m: 'heartbeat lost for 2 hosts',
          resultMsg: Em.I18n.t('installer.step9.status.hosts.heartbeat_lost').format(2)
        },
        {
          hostsWithHeartbeatLost: [],
          startCallFailed: true,
          m: 'heartbeat not lost, startCallFailed true',
          resultMsg: Em.I18n.t('installer.step9.status.start.services.failed')
        },
        {
          hostsWithHeartbeatLost: [],
          startCallFailed: false,
          m: 'heartbeat not lost, startCallFailed false',
          resultMsg: Em.I18n.t('installer.step9.status.failed')
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          v.set('controller.hostsWithHeartbeatLost', test.hostsWithHeartbeatLost);
          v.set('controller.startCallFailed', test.startCallFailed);
          v.set('controller.status', 'failed');
          v.onStatus();
          expect(v.get('resultMsg')).to.equal(test.resultMsg);
        });
      });
  });

  describe('#hostWithInstallFailed', function () {
    it('popup property failedHosts should be equal to hostsWithHeartbeatLost', function () {
      var hostsWithHeartbeatLost = [
        {},
        {}
      ];
      v.set('controller.hostsWithHeartbeatLost', hostsWithHeartbeatLost);
      var body = v.hostWithInstallFailed().get('bodyClass').create();
      expect(body.get('failedHosts')).to.eql(hostsWithHeartbeatLost);
    });
  });

});

var hv;
describe('App.HostStatusView', function () {
  beforeEach(function () {
    hv = App.HostStatusView.create();
  });
  var tests = [
    {
      p: 'isFailed',
      tests: [
        {
          obj: {
            status: 'failed',
            progress: 100
          },
          e: true
        },
        {
          obj: {
            status: 'failed',
            progress: 99
          },
          e: false
        },
        {
          obj: {
            status: 'success',
            progress: 100
          },
          e: false
        },
        {
          obj: {
            status: 'success',
            progress: 99
          },
          e: false
        }
      ]
    },
    {
      p: 'isSuccess',
      tests: [
        {
          obj: {
            status: 'success',
            progress: 100
          },
          e: true
        },
        {
          obj: {
            status: 'success',
            progress: 99
          },
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: 100
          },
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: 99
          },
          e: false
        }
      ]
    },
    {
      p: 'isWarning',
      tests: [
        {
          obj: {
            status: 'warning',
            progress: 100
          },
          e: true
        },
        {
          obj: {
            status: 'warning',
            progress: 99
          },
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: 100
          },
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: 99
          },
          e: false
        }
      ]
    }
  ];
  tests.forEach(function (test) {
    describe(test.p, function () {
      test.tests.forEach(function (t) {
        var hostStatusView = App.HostStatusView.create();
        it('obj.progress = ' + t.obj.progress + '; obj.status = ' + t.obj.status, function () {
          hostStatusView.set('obj', t.obj);
          expect(hostStatusView.get(test.p)).to.equal(t.e);
        });
      });
    });
  });

  describe('#barWidth', function () {
    it('should depends of obj.progress', function () {
      hv.set('obj', {progress: '25'});
      expect(hv.get('barWidth')).to.equal('width: 25%;');
    });
  });

  describe('#didInsertElement', function () {
    it('should call onStatus', function () {
      sinon.stub(hv, 'onStatus', Em.K);
      hv.didInsertElement();
      expect(hv.onStatus.calledOnce).to.equal(true);
      hv.onStatus.restore();
    });
  });

  describe('#onStatus', function () {
    Em.A([
        {
          obj: {
            status: 'info'
          },
          e: {
            barColor: 'progress-info'
          }
        },
        {
          obj: {
            status: 'warning'
          },
          e: {
            barColor: 'progress-warning'
          }
        },
        {
          obj: {
            status: 'warning',
            progress: '100'
          },
          e: {
            barColor: 'progress-warning',
            'obj.message': Em.I18n.t('installer.step9.host.status.warning')
          }
        },
        {
          obj: {
            status: 'failed'
          },
          e: {
            barColor: 'progress-danger'
          }
        },
        {
          obj: {
            status: 'failed',
            progress: '100'
          },
          e: {
            barColor: 'progress-danger',
            'obj.message': Em.I18n.t('installer.step9.host.status.failed')
          }
        },
        {
          obj: {
            status: 'heartbeat_lost'
          },
          e: {
            barColor: 'progress-danger'
          }
        },
        {
          obj: {
            status: 'heartbeat_lost',
            progress: '100'
          },
          e: {
            barColor: 'progress-danger',
            'obj.message': Em.I18n.t('installer.step9.host.heartbeat_lost')
          }
        }
      ]).forEach(function (test) {
        it(JSON.stringify(test.obj), function () {
          hv.set('obj', test.obj);
          hv.onStatus();
          Em.keys(test.e).forEach(function (k) {
            expect(hv.get(k)).to.equal(test.e[k]);
          });
        });
      });
    Em.A([
        {
          obj: {
            status: 'success',
            progress: '100'
          },
          progress: '35',
          e: true
        },
        {
          obj: {
            status: 'success',
            progress: '100'
          },
          progress: '34',
          e: false
        },
        {
          obj: {
            status: 'success',
            progress: '99'
          },
          progress: '35',
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: '100'
          },
          progress: '35',
          e: false
        }
      ]).forEach(function (test) {
        it(JSON.stringify(test.obj) + ' ' + test.progress, function() {
          hv.set('barColor', '');
          hv.set('obj', test.obj);
          hv.set('obj.message', '');
          hv.set('controller', {progress: test.progress});
          hv.onStatus();
          expect(hv.get('obj.message') === Em.I18n.t('installer.step9.host.status.success')).to.equal(test.e);
          expect(hv.get('barColor') === 'progress-success').to.equal(test.e);
        });
      });
  });

  describe('#hostLogPopup', function() {
    describe('#onClose', function() {
      beforeEach(function() {
        hv.set('controller', {currentOpenTaskId: 123});
        hv.set('obj', Em.Object.create());
      });
      it('popup should clear currentOpenTaskId', function() {
        hv.hostLogPopup().onClose();
        expect(hv.get('controller.currentOpenTaskId')).to.equal(0);
      });
      it('onClose popup should hide popup', function() {
        var p = hv.hostLogPopup();
        sinon.spy(p, 'hide');
        p.onClose();
        expect(p.hide.calledOnce).to.equal(true);
      });
    });
  });

});

});

;
//# sourceMappingURL=test.js.map